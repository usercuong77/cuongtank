<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Battle 2D - Final Fix V4</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: 'Consolas', 'Courier New', monospace;
            color: white;
            user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        /* --- UI LAYER --- */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD: G√≥c tr√°i tr√™n */
        #hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
        }
        .hud-text {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
        }
        .highlight { color: #4CAF50; }
        .wave-text { color: #FFD700; font-size: 1.5rem; }

        /* HUD: G√≥c ph·∫£i tr√™n - Buffs */
        #hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .buff-icon {
            display: inline-block;
            padding: 5px 10px;
            margin-top: 5px;
            border-radius: 4px;
            font-size: 0.9rem;
            background: rgba(0,0,0,0.6);
            border: 1px solid white;
        }

        /* WEAPON & SKILL BAR */
        #bottomBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }


#playersHudRow{
    display:flex;
    gap: 22px;
    align-items: flex-end;
    justify-content: center;
    width: min(980px, 96vw);
}

#playersHudRow.twoP{
    justify-content: space-between;
    gap: 18px;
}

#playersHudRow.twoP .playerHud{
    width: 48%;
}

.hudDivider{
    width: 2px;
    min-height: 190px;
    background: rgba(255,255,255,0.16);
    border-radius: 2px;
    align-self: stretch;
    margin: 0 8px;
    display: none;
}

#playersHudRow.twoP .hudDivider{
    display: block;
}

/* tighter on narrow screens */
@media (max-width: 980px){
    #playersHudRow{ width: 96vw; }
    #healthBarContainer, #healthBarContainer2{ width: min(360px, 46vw); }
    #playersHudRow.twoP{ gap: 12px; }
    .hudDivider{ margin: 0 4px; min-height: 175px; }
}

.playerHud{
    display:flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
}
/* Make per-player HUD a bit smaller on short screens */
@media (max-height: 760px){
    #playersHudRow{ gap: 14px; }
    #healthBarContainer, #healthBarContainer2{ width: 320px; }
    .slot{ width: 54px; height: 54px; }
}

        #weaponBar, #skillBar, #weaponBar2, #skillBar2 {
            display: flex;
            gap: 10px;
        }

        .slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 8px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #777;
            transition: all 0.2s;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .slot.active {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,255,255,0.4);
            background: rgba(60, 60, 60, 0.9);
        }

        .slot .key-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.7rem;
            color: #aaa;
        }

        .slot .icon {
            font-size: 0.9rem;
            text-align: center;
            line-height: 1.1;
            margin-bottom: 2px;
        }

        .slot .level-indicator {
            font-size: 0.7rem;
            color: #FFD700;
            margin-top: 2px;
        }

        /* ULTIMATE BAR */
        #ultiContainer {
            width: 400px;
            height: 10px;
            background: #333;
            border: 1px solid #FFD700;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 5px;
            position: relative;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        #ultiBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFAB00);
            transition: width 0.2s;
            box-shadow: 0 0 10px #FFD700;
        }
        #ultiText {
            position: absolute;
            top: -20px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 5px black;
        }

        /* Cooldown Overlay */
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            transition: height 0.1s linear;
            background: rgba(0, 0, 0, 0.78);
            background-image: linear-gradient(135deg,
                rgba(255,255,255,0.14) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255,255,255,0.14) 50%,
                rgba(255,255,255,0.14) 75%,
                transparent 75%,
                transparent);
            background-size: 14px 14px;
        }

        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.85rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 2px 0 #000, 0 0 8px rgba(0,0,0,0.8);
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(0,0,0,0.25);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.08s linear;
        }

/* HUD: Thanh m√°u */
        #healthBarContainer, #healthBarContainer2 {
            position: relative;
            width: 400px;
            height: 20px;
            background: #222;
            border: 2px solid #555;
            border-radius: 4px;
            overflow: hidden;
        }

        .hpLabel{
            display:inline-block;
            padding: 1px 6px;
            margin-right: 6px;
            border-radius: 999px;
            font-size: 0.65rem;
            line-height: 1.2;
            letter-spacing: 0.5px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.25);
            box-shadow: 0 2px 8px rgba(0,0,0,0.45);
        }
        #healthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.2s;
        }
        #shieldOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 191, 255, 0.5);
            display: none;
        }

        /* BOSS HP BAR */
        #bossHealthContainer {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 30px;
            background: #222;
            border: 3px solid #d32f2f;
            border-radius: 4px;
            overflow: hidden;
            display: none; 
            z-index: 10;
        }
        #bossHealthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #d32f2f, #b71c1c);
            transition: width 0.2s;
        }
        #bossName {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        /* SCREENS */
        #startScreen{
            position: fixed;
            inset: 0;
            top: 0;
            left: 0;
            transform: none;
            background: rgba(10,10,10,0.96);
            padding: 22px 26px;
            border-radius: 0;
            border: 2px solid #4CAF50;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.24);
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: stretch;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            z-index: 100;
        }

        #gameOverScreen, #victoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            padding: 50px;
            border-radius: 15px;
            border: 2px solid #4CAF50;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 400px;
            z-index: 100;
        }

        h1 { margin: 0 0 20px; font-size: 3rem; color: #4CAF50; text-transform: uppercase; letter-spacing: 3px; }
        h2 { margin: 0 0 15px; color: #ff4444; font-size: 2.5rem; }
        p { color: #ccc; margin-bottom: 10px; font-size: 1.1rem; }
        
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 30px;
            transition: all 0.2s;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
        }
        .btn:hover { background: #45a049; transform: scale(1.05); box-shadow: 0 0 20px #4CAF50; }

        /* --- SHOP UI FIX: keep BUY buttons consistent (avoid giant/shifted buttons) --- */
        #shopModal .btn {
            padding: 10px 12px;
            font-size: 0.95rem;
            margin-top: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        #shopModal #btnShopContinue {
            width: auto;
            padding: 12px 16px;
            font-size: 1rem;
            margin-top: 0;
        }
        .hidden { display: none !important; }

        .key-guide {
            display: grid;
            grid-template-columns: auto auto;
            gap: 10px;
            text-align: left;
            margin-top: 20px;
            font-size: 0.9rem;
            color: #888;
        }
        .key { color: white; font-weight: bold; background: #333; padding: 2px 6px; border-radius: 4px; }
        
        #world-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 0.8rem;
            color: #555;
        }

    
        /* --- MAX EDITION UX TWEAKS --- */
        #weaponBar .weapon-slot, .weapon-slot, #weaponBar .slot { width: 60px; height: 60px; }
        #settingsModal input[type="range"] { width: 100%; }
        #settingsModal input[type="checkbox"] { transform: scale(1.2); }
        #maxTopBar .btn:hover { transform: scale(1.03); box-shadow: 0 0 12px rgba(255,255,255,0.15); }


        /* --- Admin code modal (hidden) --- */
        #adminCodeModal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:99999}
        #adminCodeModal.hidden{display:none}
        #adminCodePanel{pointer-events:auto;width:min(520px,92vw);background:#0b0f0c;border:2px solid rgba(24,255,106,.9);border-radius:14px;box-shadow:0 0 30px rgba(24,255,106,.25);padding:18px}
        #adminCodePanel h3{margin:0 0 10px;color:#18ff6a;letter-spacing:2px}
        #adminCodeInput{pointer-events:auto;width:100%;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#090b0a;color:#fff;font-size:16px;outline:none}
        #adminCodeMsg{margin-top:10px;font-size:13px;min-height:18px;color:rgba(255,255,255,.8)}


        /* --- Copyright badge --- */
        #copyrightBadge{
            position:fixed;
            top:14px;
            right:14px;
            z-index:100000;
            padding:6px 8px;
            border-radius:10px;
            border:1px solid rgba(24,255,106,.22);
            background:rgba(0,0,0,.18);
            color:rgba(24,255,106,.70);
            font-size:11px;
            letter-spacing:0.6px;
            user-select:none;
            pointer-events:none;
            backdrop-filter: blur(6px);
        }


        /* VietKey confirm modal */
        #vietkeyModal{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.55); z-index:100001;}
        #vietkeyModal.hidden{display:none;}
        #vietkeyPanel{width:min(560px,92vw); background:#0b0f0c; border:2px solid rgba(24,255,106,.55); border-radius:14px;
                      box-shadow:0 0 30px rgba(24,255,106,.22); padding:16px 18px;}
        .vietkeyTip{margin-top:14px; font-size:12px; color:rgba(255,255,255,.78); text-align:center;}
        .vietkeyTip b{color:#18ff6a;}


        /* ============================================
           UI POLISH v25 ‚Äî Weapon & Skill Cards
           (Card style for weapon slots + Q/E/R slots)
           ============================================ */

        /* Layout spacing */
        #weaponBar, #skillBar { gap: 12px; }

        /* Shared card base (skills + weapons) */
        .slot, .weapon-slot {
            width: 62px;
            height: 62px;
            border-radius: 14px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            overflow: hidden;
            cursor: default;
            user-select: none;

            /* Glass + depth */
            background:
                radial-gradient(circle at 30% 22%, rgba(255,255,255,0.16), rgba(255,255,255,0) 48%),
                linear-gradient(180deg, rgba(14, 16, 22, 0.92), rgba(0, 0, 0, 0.72));
            border: 2px solid rgba(255,255,255,0.14);
            box-shadow:
                0 12px 22px rgba(0,0,0,0.55),
                inset 0 0 0 1px rgba(255,255,255,0.06);
            backdrop-filter: blur(6px);
            transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease, filter 120ms ease;
        }

        /* Shine + subtle scanlines */
        .slot::before, .weapon-slot::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0) 55%);
            opacity: 0.85;
            pointer-events: none;
        }
        .slot::after, .weapon-slot::after {
            content: "";
            position: absolute;
            left: -50%;
            top: -50%;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(
                0deg,
                rgba(255,255,255,0.045) 0px,
                rgba(255,255,255,0.045) 1px,
                rgba(0,0,0,0) 4px,
                rgba(0,0,0,0) 7px
            );
            opacity: 0.08;
            transform: rotate(12deg);
            pointer-events: none;
        }

        /* Micro hover (desktop) */
        @media (hover:hover) {
            .slot:hover, .weapon-slot:hover {
                transform: translateY(-1px) scale(1.04);
                box-shadow:
                    0 16px 28px rgba(0,0,0,0.62),
                    inset 0 0 0 1px rgba(255,255,255,0.08);
            }
        }

        /* Key label */
        .slot .key-number, .weapon-slot .key-number {
            position: absolute;
            top: 4px;
            left: 5px;
            font-size: 11px;
            letter-spacing: 0.4px;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.12);
            color: rgba(255,255,255,0.78);
            text-shadow: 0 1px 0 rgba(0,0,0,0.55);
        }

        /* Icon text */
        .slot .icon, .weapon-slot .icon {
            font-size: 12px;
            line-height: 1.05;
            text-align: center;
            padding: 0 4px;
            color: rgba(255,255,255,0.88);
            text-shadow: 0 2px 0 rgba(0,0,0,0.38);
        }

        /* Level chip */
        .slot .level-indicator, .weapon-slot .level-indicator {
            position: absolute;
            bottom: 4px;
            right: 5px;
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 999px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.12);
            color: #FFD54F;
            text-shadow: 0 1px 0 rgba(0,0,0,0.55);
        }

        /* Cooldown overlay looks like tinted glass */
        .cooldown-overlay {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 0%;
            background: linear-gradient(180deg, rgba(0,0,0,0.08), rgba(0,0,0,0.78));
            border-top: 1px solid rgba(255,255,255,0.08);
            pointer-events: none;
        }

        .cooldown-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: 900;
            padding: 2px 7px;
            border-radius: 999px;
            background: rgba(0,0,0,0.60);
            border: 1px solid rgba(255,255,255,0.12);
            color: rgba(255,255,255,0.92);
            text-shadow: 0 1px 0 rgba(0,0,0,0.6);
            opacity: 0;
            pointer-events: none;
        }

        /* Active weapon slot (selected) */
        .weapon-slot.active {
            transform: translateY(-1px) scale(1.12);
            border-color: rgba(255,255,255,0.92) !important;
            filter: drop-shadow(0 0 10px currentColor);
            box-shadow:
                0 18px 34px rgba(0,0,0,0.68),
                inset 0 0 0 1px rgba(255,255,255,0.10);
        }

        /* Skill ready pulse (when cooldown is done) */
        .slot.ready {
            border-color: currentColor;
            box-shadow:
                0 12px 24px rgba(0,0,0,0.58),
                inset 0 0 0 1px rgba(255,255,255,0.08);
            animation: uiReadyPulse 1.15s ease-in-out infinite;
        }
        @keyframes uiReadyPulse {
            0%, 100% { filter: drop-shadow(0 0 0px transparent); }
            50% { filter: drop-shadow(0 0 10px currentColor); }
        }

        /* Skill on cooldown slightly muted */
        .slot.cooling { opacity: 0.92; }

        /* Mobile scale */
        @media (max-width: 560px) {
            .slot, .weapon-slot { width: 54px; height: 54px; border-radius: 12px; }
            .slot .icon, .weapon-slot .icon { font-size: 11px; }
            .slot .key-number, .weapon-slot .key-number { font-size: 10px; padding: 1px 5px; }
            .slot .level-indicator, .weapon-slot .level-indicator { font-size: 9px; padding: 1px 5px; }
        }

    

        /* ===== START SCREEN FULLSCREEN LAYOUT (v34) ===== */
        #startScreen{
            width: 100vw;
            height: 100vh;
            aspect-ratio: auto;
            padding: 22px 26px;
            align-items: stretch;
            justify-content: stretch;
            gap: 0;
        }
        #startScreen .start16{
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        #startScreen .startTop{
            display:flex;
            gap:16px;
            align-items:flex-start;
            justify-content:space-between;
        }
        #startScreen .startTitleWrap{
            text-align:left;
            padding: 6px 0 0 4px;
        }
        #startScreen .startTitle{
            font-size: clamp(24px, 3.2vw, 46px);
            font-weight: 900;
            letter-spacing: 4px;
            color: #4CAF50;
            text-transform: uppercase;
            text-shadow: 0 0 18px rgba(76,175,80,0.25);
            line-height: 1.05;
        }
        #startScreen .startSubtitle{
            margin-top: 6px;
            color: #9be7b0;
            opacity: 0.9;
            font-size: clamp(12px, 1.2vw, 14px);
            text-align:left;
        }
        #startScreen .startHints{
            text-align:left;
            max-width: 520px;
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 10px 12px;
        }
        
        /* Start screen SETTINGS button: keep it visible (not covered by hints/logo) */
        #btnSettingsStart{
            position: absolute !important;
            top: 18px !important;
            right: 560px !important; /* sits in the empty top-right area left of the hints box */
            z-index: 220 !important;
        }
        @media (max-width: 1280px){
            #btnSettingsStart{ right: 360px !important; }
        }
        @media (max-width: 980px){
            #btnSettingsStart{ right: 14px !important; top: 74px !important; }
        }
#startScreen .hintLine{
            font-size: clamp(12px, 1.15vw, 14px);
            color: #ccc;
            margin: 3px 0;
            line-height: 1.25;
        }
        #startScreen .hintLine b{ color:#fff; }
        #startScreen .hintLine.warn{ color:#ff7777; }
        #startScreen .hintLine.danger{ color:#ff4aa6; }

        #startScreen .startMain{
            flex: 1;
            display: grid;
            grid-template-columns: 0.95fr 1.35fr;
            gap: 14px;
            min-height: 0;
        }
        #startScreen .startLeft,
        #startScreen .startRight{
            background: rgba(0,0,0,0.22);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 14px;
            padding: 12px;
            min-height: 0;
        }
        #startScreen .panelTitle{
            font-weight: 900;
            letter-spacing: 0.7px;
            color: #FFD700;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: left;
        }
        #startScreen .systemList{
            display:flex;
            flex-direction:column;
            gap: 10px;
            overflow:auto;
            padding-right: 4px;
            max-height: calc(100% - 140px);
        }
        #startScreen .sysItem{
            display:grid;
            grid-template-columns: 18px 86px 1fr;
            align-items:center;
            gap: 10px;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(10,10,10,0.35);
            cursor:pointer;
            transition: transform 120ms ease, border-color 120ms ease, background 120ms ease, box-shadow 120ms ease;
            text-align:left;
        }
        #startScreen .sysItem:hover{
            transform: translateY(-1px);
            border-color: rgba(76,175,80,0.35);
            box-shadow: 0 0 16px rgba(76,175,80,0.10);
        }
        #startScreen .sysItem.active{
            border-color: rgba(76,175,80,0.65);
            box-shadow: 0 0 22px rgba(76,175,80,0.22);
            background: rgba(20,20,20,0.55);
        }
        #startScreen .sysItem input{
            transform: translateY(1px);
        }
        #startScreen .sysMini{
            width: 84px;
            height: 56px;
            border-radius: 10px;
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.10);
        }
        #startScreen .sysName{
            font-weight: 900;
            font-size: 15px;
            color:#eaeaea;
        }
        #startScreen .sysDesc{
            font-size: 12px;
            color:#aaa;
            margin-top: 2px;
            line-height: 1.2;
        }
        #startScreen .leftFootNote{
            margin-top: 10px;
            font-size: 12px;
            color:#8fdba6;
            text-align:left;
            opacity: 0.9;
        }
        #startScreen .keyGuideWide{
            margin-top: 10px;
            display:grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 12px;
            align-items:center;
        }
        #startScreen .kg{
            display:flex;
            gap:10px;
            align-items:center;
            justify-content:flex-start;
            color:#cfcfcf;
            font-size: 12px;
        }
        #startScreen .kg .key{
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.16);
            border-radius: 7px;
            padding: 4px 8px;
            font-weight: 800;
            color:#fff;
            min-width: 56px;
            text-align:center;
        }

        #startScreen .startRight{
            display:flex;
            flex-direction:column;
            gap: 12px;
        }
        #startScreen .previewWrap{
            background: rgba(0,0,0,0.18);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 10px;
        }
        #startScreen #systemPreview{
            width: 100%;
            height: auto;
            border-radius: 14px;
            background: radial-gradient(circle at 50% 30%, rgba(255,255,255,0.06), rgba(0,0,0,0.40) 65%);
            border: 1px solid rgba(255,255,255,0.10);
        }
        #startScreen .previewMeta{
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-top: 8px;
            gap: 10px;
            flex-wrap:wrap;
        }
        #startScreen .sysTagline{
            font-weight: 800;
            color:#eaeaea;
            font-size: 13px;
            opacity: 0.95;
            text-align:left;
        }
        #startScreen .progressLine{
            font-size: 12px;
            color:#bbb;
            opacity: 0.9;
        }
        #startScreen .progressLine span{ color:#4CAF50; font-weight:900; }

        #startScreen .skillsWrap{
            flex:1;
            background: rgba(0,0,0,0.18);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 10px;
            min-height: 0;
            overflow:auto;
        }
        #startScreen .systemDetails{
            display:flex;
            flex-direction:column;
            gap: 10px;
        }
        #startScreen .skillCard{
            display:grid;
            grid-template-columns: 46px 1fr;
            gap: 10px;
            align-items:flex-start;
            padding: 10px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(10,10,10,0.35);
        }
        #startScreen .skillKey{
            width: 46px;
            height: 46px;
            border-radius: 12px;
            display:flex;
            align-items:center;
            justify-content:center;
            font-weight: 1000;
            color:#fff;
            letter-spacing: 0.5px;
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.06);
        }
        #startScreen .skillName{
            font-weight: 900;
            color:#fff;
            font-size: 14px;
        }
        #startScreen .skillDesc{
            color:#cfcfcf;
            font-size: 12px;
            margin-top: 3px;
            line-height: 1.25;
        }
        #startScreen .skillStats{
            margin-top: 6px;
            font-size: 12px;
            color:#9bb3ff;
            opacity: 0.95;
        }

        #startScreen .startBottom{
            display:flex;
            justify-content:center;
            align-items:center;
        }
        #startScreen .startBtnBig{
            font-size: 1.35rem;
            padding: 14px 54px;
            border-radius: 14px;
            box-shadow: 0 0 24px rgba(76,175,80,0.25);
        }


        #startScreen .saveRow{
            display:flex;
            justify-content:center;
            align-items:center;
            gap: 12px;
            margin: 10px 0 12px;
            flex-wrap: wrap;
            pointer-events: auto;
        }
        #startScreen .saveBtnContinue{
            background: linear-gradient(180deg, rgba(0,200,255,0.35), rgba(0,200,255,0.10));
            border: 1px solid rgba(0,200,255,0.45);
            box-shadow: 0 0 26px rgba(0,200,255,0.20);
        }
        #startScreen .saveBtnContinue:hover{
            box-shadow: 0 0 34px rgba(0,200,255,0.32);
            transform: translateY(-1px);
        }
        #startScreen .saveBtnClear{
            font-size: 0.98rem;
            padding: 11px 18px;
            border-radius: 12px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 0 18px rgba(255,255,255,0.08);
            opacity: 0.92;
        }
        #startScreen .saveBtnClear:hover{
            opacity: 1;
            transform: translateY(-1px);
        }
        @media (max-width: 900px){
            #startScreen{ padding: 14px; }
            #startScreen .startMain{ grid-template-columns: 1fr; }
            #startScreen .systemList{ max-height: none; }
            #startScreen .keyGuideWide{ grid-template-columns: 1fr 1fr; }
        }

        /* ===== START SCREEN 16:9 LAYOUT HOTFIX (v28) =====
           - Widen frame a bit
           - Give Skills panel more real estate (flex column on right)
           =============================================== */
        #startScreen{
            width: 100vw;
            height: 100vh;
            padding: 16px;
        }
        #startScreen .startMain{
            grid-template-columns: 0.90fr 1.45fr;
            gap: 16px;
        }
        #startScreen .startRight{
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
            min-height: 0;
        }
        #startScreen .previewWrap{
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #startScreen #systemPreview{
            max-height: 44vh;
        }
        #startScreen .skillsWrap{
            flex: 1 1 auto;
            min-height: 0;
            overflow: auto;
            padding: 12px;
        }
        #startScreen .systemDetails{
            padding-bottom: 10px;
        }

        /* ===== START SCREEN 16:9 LAYOUT HOTFIX (v29) =====
           - Move Deploy + Best stats to LEFT column
           - Let Skills panel extend further down
           =============================================== */
        #startScreen .startLeft{
            display:flex;
            flex-direction:column;
            gap: 10px;
        }
        #startScreen .systemList{
            flex: 1 1 auto;
            max-height: none;
            overflow:auto;
        }
        #startScreen .leftActions{
            margin-top: 10px;
            display:flex;
            flex-direction:column;
            gap: 10px;
        }
        #startScreen .leftActions .startBtnBig{
            width: 100%;
            padding: 14px 20px;
            font-size: 1.18rem;
            border-radius: 14px;
        }
        #startScreen .leftStats{
            font-size: 12px;
            color:#bbb;
            text-align:center;
            opacity: 0.95;
        }
        #startScreen .leftStats span{ color:#4CAF50; font-weight:900; }
        #startScreen #systemPreview{
            width: min(100%, calc(46vh * 16 / 9));
            height: auto;
            max-height: 46vh;
            margin: 0 auto;
        }



        /* ============================================
           START UI v30: Equalize Preview (blue) + Skills (yellow)
           - Preview & skill panels share 50/50 height
           - Remove canvas max-height cap
           - Keep Best Score/Best Wave only in left panel
        ============================================ */
        #startScreen .startRight{
            display:flex;
            flex-direction:column;
            gap:12px;
            min-height:0;
        }
        #startScreen .previewWrap{
            flex: 1 1 0 !important;
            min-height:0;
            display:flex;
            flex-direction:column;
            gap:10px;
        }
        #startScreen #systemPreview{
            flex: 1 1 0 !important;
            width:100%;
            height:100% !important;
            max-height:none !important;
        }
        #startScreen .previewMeta{
            margin-top:auto;
        }
        #startScreen .skillsWrap{
            flex: 1 1 0 !important;
            min-height:0;
            overflow:auto;
        }


        /* ===== PHASE 1: MODE SELECTOR (Hard/Easy, 1P/2P) ===== */
        #startScreen{ overflow-y:auto; overscroll-behavior: contain; }
        #startScreen .start16{ height:auto; min-height:100%; }
        #startScreen .modeBox{
            margin-top: 10px;
            background: rgba(0,0,0,0.20);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 14px;
            padding: 10px 10px 8px;
        }
        #startScreen .modeTitle{
            font-weight: 900;
            letter-spacing: 0.7px;
            color: #9be7b0;
            font-size: 12px;
            margin-bottom: 8px;
            text-align:left;
            opacity: 0.95;
        }
        #startScreen .modeRow{
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:10px;
            margin: 6px 0;
        }
        #startScreen .modeLabel{
            font-size: 12px;
            color:#bbb;
            min-width: 78px;
            text-align:left;
        }
        #startScreen .modeSeg{
            display:flex;
            gap:8px;
            flex-wrap:wrap;
            justify-content:flex-end;
        }
        #startScreen .modeSeg label{
            display:flex;
            align-items:center;
            gap:6px;
            padding: 6px 10px;
            border-radius: 12px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            cursor: pointer;
            user-select:none;
        }
        #startScreen .modeSeg input{
            accent-color: #4CAF50;
        }
        #startScreen .modeSeg span{
            font-size: 12px;
            color:#eee;
            font-weight: 800;
            letter-spacing: 0.4px;
        }
        #startScreen .modeSelect{
            width: 100%;
            max-width: 230px;
            padding: 7px 10px;
            border-radius: 12px;
            background: rgba(0,0,0,0.25);
            color: #eee;
            border: 1px solid rgba(255,255,255,0.14);
            outline: none;
            font-family: inherit;
        }
        #startScreen .modeNote{
            margin-top: 6px;
            font-size: 11px;
            color: rgba(255,255,255,0.75);
            text-align:left;
            line-height: 1.25;
        }
        @media (max-height: 760px){
            #startScreen .startMain{ flex: 0 0 auto; }
        }


        /* ===== WELCOME OVERLAY (pre-menu) ===== */
        #welcomeOverlay{
            position:fixed;
            inset:0;
            display:none;
            align-items:center;
            justify-content:center;
            background:transparent;
            z-index:999999;
            padding:18px;
        }
        #welcomeCard{
            width:min(760px, 94vw);
            max-height:min(78vh, 640px);
            overflow:auto;
            background:rgba(18, 20, 26, 0.92);
            border:1px solid rgba(255,255,255,0.12);
            border-radius:18px;
            padding:22px 22px 18px;
            box-shadow:0 30px 90px rgba(0,0,0,0.55);
            backdrop-filter: blur(10px);
        }
        #welcomeCard h2{
            margin:0 0 10px 0;
            font-size:26px;
            letter-spacing:0.5px;
            color:#ffe36e;
            text-shadow:0 0 10px rgba(255,227,110,0.25);
        }
        #welcomeCard p{
            margin:8px 0;
            line-height:1.45;
            opacity:0.95;
        }
        #welcomeCard a{
            color:#8fd3ff;
            text-decoration:none;
            border-bottom:1px dotted rgba(143,211,255,0.55);
        }
        #welcomeCard a:hover{ opacity:0.95; }

/* --- Welcome glow + bounce (Phase 12 polish) --- */
#welcomeCard{
    /* slightly brighter but still dark */
    background: linear-gradient(180deg, rgba(32, 36, 52, 0.96), rgba(18, 20, 26, 0.92));
    border: 1px solid rgba(255,255,255,0.14);
    box-shadow:
        0 30px 90px rgba(0,0,0,0.55),
        0 0 46px rgba(143,211,255,0.08),
        inset 0 1px 0 rgba(255,255,255,0.06);
}

#welcomeCard a{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:3px 10px;
    border-radius:999px;
    color:#d8f0ff;
    text-decoration:none;
    border:1px solid rgba(143,211,255,0.28);
            border-bottom:none;
    background: rgba(143,211,255,0.10);
    box-shadow: 0 0 0 rgba(143,211,255,0);
    transform: translateZ(0);
    will-change: transform, box-shadow, background;
    transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease, border-color 140ms ease, color 140ms ease;
}
#welcomeCard a:hover{
    opacity:1;
    transform: translateY(-2px) scale(1.03);
    background: rgba(143,211,255,0.16);
    border-color: rgba(143,211,255,0.45);
    box-shadow: 0 10px 28px rgba(0,0,0,0.30), 0 0 18px rgba(143,211,255,0.32);
}
#welcomeCard a:active{
    transform: translateY(0px) scale(0.98);
    box-shadow: 0 6px 18px rgba(0,0,0,0.28), 0 0 12px rgba(143,211,255,0.22);
}
#welcomeCard a:focus-visible{
    outline:none;
    box-shadow: 0 10px 28px rgba(0,0,0,0.30), 0 0 0 2px rgba(143,211,255,0.35), 0 0 18px rgba(143,211,255,0.32);
}

#welcomeContinueBtn{
    transform: translateZ(0);
    will-change: transform, box-shadow, filter;
    transition: transform 140ms ease, box-shadow 140ms ease, filter 140ms ease;
}
#welcomeContinueBtn:hover{
    transform: translateY(-2px) scale(1.02);
    filter: brightness(1.06);
    box-shadow: 0 14px 30px rgba(0,0,0,0.40), 0 0 22px rgba(255,227,110,0.26);
}
#welcomeContinueBtn:active{
    transform: translateY(0px) scale(0.98);
    filter: brightness(0.98);
    box-shadow: 0 10px 22px rgba(0,0,0,0.35), 0 0 18px rgba(255,227,110,0.18);
}
#welcomeContinueBtn:focus-visible{
    outline:none;
    box-shadow: 0 14px 30px rgba(0,0,0,0.40), 0 0 0 2px rgba(255,227,110,0.35), 0 0 22px rgba(255,227,110,0.26);
}

        #welcomeCard .welcomeRow{
            margin-top:14px;
            display:flex;
            gap:10px;
            flex-wrap:wrap;
            align-items:center;
            justify-content:flex-end;
        }
        #welcomeContinueBtn{
            cursor:pointer;
            border:none;
            border-radius:14px;
            padding:10px 16px;
            font-weight:700;
            color:#0f1116;
            background:linear-gradient(180deg, #ffe36e, #f5c84a);
            box-shadow:0 10px 22px rgba(0,0,0,0.35), 0 0 18px rgba(255,227,110,0.18);
        }
        #welcomeContinueBtn:active{ transform: translateY(0px) scale(0.98); filter: brightness(0.98); }
        #welcomeHint{
            font-size:12px;
            opacity:0.8;
            margin-right:auto;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div id="gameUI" class="ui-layer hidden">
        <div id="hud-top-left">
            <div class="hud-text wave-text">WAVE <span id="waveVal">1</span></div>
            <div id="fpsCounter" class="hud-text hidden" style="font-size: 1.0rem; font-weight: 800; color:#FFD700;">FPS: <span id="fpsVal">0</span></div>
            <div class="hud-text">ƒêi·ªÉm: <span id="scoreVal" class="highlight">0</span></div>
            <div class="hud-text">V√†ng: <span id="goldVal" class="highlight" style="color:#FFD700;">0</span></div>
            <div class="hud-text" style="font-size: 0.9rem; color: #aaa;">K·∫ª ƒë·ªãch: <span id="enemyCount">0</span></div>
        </div>

        <div id="hud-top-right">
            <div id="buffsContainer"></div>
        </div>

        <!-- BOSS HP BAR -->
        <div id="bossHealthContainer">
            <div id="bossHealthBar"></div>
            <div id="bossName">MECHA BOSS</div>
        </div>

        <!-- WEAPON & SKILL UI -->
        <div id="bottomBar">
            <div id="ultiContainer">
                <div id="ultiText">B√ÉO L·ª¨A (Space)</div>
                <div id="ultiBar"></div>
            </div>

            <div id="playersHudRow">
                <!-- P1 HUD -->
                <div class="playerHud" id="hudP1">
                    <div id="healthBarContainer">
                        <div id="shieldOverlay"></div>
                        <div id="healthBar"></div>
                        <div style="position: absolute; top: 0; left: 0; width: 100%; text-align: center; line-height: 20px; font-size: 0.7rem; font-weight: bold; text-shadow: 1px 1px 0 #000;">
                            <span class="hpLabel">P1</span>&nbsp;<span id="hpText">100/100</span>
                        </div>
                    </div>

                    <div id="skillBar">
                        <div class="slot" id="skill-clone" style="border-color: #29B6F6; color: #29B6F6;">
                            <div class="key-number">Q</div>
                            <div class="icon">Ph√¢n<br>Th√¢n</div>
                            <div class="cooldown-overlay" id="cd-clone"></div>
                            <div class="cooldown-text" id="cdt-clone"></div>
                        </div>
                        <div class="slot" id="skill-stealth" style="border-color: #AB47BC; color: #AB47BC;">
                            <div class="key-number">E</div>
                            <div class="icon">T√†ng<br>H√¨nh</div>
                            <div class="cooldown-overlay" id="cd-stealth"></div>
                            <div class="cooldown-text" id="cdt-stealth"></div>
                        </div>
                        <div class="slot" id="skill-vampirism" style="border-color: #FF5252; color: #FF5252;">
                            <div class="key-number">R</div>
                            <div class="icon">H√∫t<br>M√°u</div>
                            <div class="cooldown-overlay" id="cd-vampirism"></div>
                            <div class="cooldown-text" id="cdt-vampirism"></div>
                        </div>
                    </div>

                    <div id="weaponBar"></div>
                </div>

                <div class="hudDivider" id="hudDivider" aria-hidden="true"></div>

                <!-- P2 HUD (Phase 10.1) -->
                <div class="playerHud" id="hudP2" style="display:none;">
                    <div id="healthBarContainer2">
                        <div id="shieldOverlay2"></div>
                        <div id="healthBar2"></div>
                        <div style="position: absolute; top: 0; left: 0; width: 100%; text-align: center; line-height: 20px; font-size: 0.7rem; font-weight: bold; text-shadow: 1px 1px 0 #000;">
                            <span class="hpLabel">P2</span>&nbsp;<span id="hpText2">100/100</span>
                        </div>
                    </div>

                    <div id="skillBar2">
                        <div class="slot" id="skill2-clone" style="border-color: #29B6F6; color: #29B6F6;">
                            <div class="key-number">1</div>
                            <div class="icon">Ph√¢n<br>Th√¢n</div>
                            <div class="cooldown-overlay" id="cd2-clone"></div>
                            <div class="cooldown-text" id="cdt2-clone"></div>
                        </div>
                        <div class="slot" id="skill2-stealth" style="border-color: #AB47BC; color: #AB47BC;">
                            <div class="key-number">2</div>
                            <div class="icon">T√†ng<br>H√¨nh</div>
                            <div class="cooldown-overlay" id="cd2-stealth"></div>
                            <div class="cooldown-text" id="cdt2-stealth"></div>
                        </div>
                        <div class="slot" id="skill2-vampirism" style="border-color: #FF5252; color: #FF5252;">
                            <div class="key-number">3</div>
                            <div class="icon">H√∫t<br>M√°u</div>
                            <div class="cooldown-overlay" id="cd2-vampirism"></div>
                            <div class="cooldown-text" id="cdt2-vampirism"></div>
                        </div>
                    </div>

                    <div id="weaponBar2"></div>
                </div>
            </div>
        </div>

<div id="world-info">Map Size: 3x | Bug Fixed | Cleaned</div>
    </div>


    <!-- Welcome Overlay (pre-menu) -->
    <div id="welcomeOverlay" role="dialog" aria-modal="true" aria-label="Ch√†o m·ª´ng">
        <div id="welcomeCard">
            <h2>Ch√∫c b·∫°n ch∆°i game vui v·∫ª! üéÆ</h2>
            <p>Tr∆∞·ªõc khi v√†o menu ch·ªçn h·ªá xe, h√£y chu·∫©n b·ªã tinh th·∫ßn ‚Äúc√†y‚Äù th·∫≠t ƒë√£ üòÑ</p>
            <p><b>G·ª£i √Ω nhanh:</b> Hard d√πng chu·ªôt ƒë·ªÉ ng·∫Øm/b·∫Øn ‚Ä¢ Easy/2P t·ª± ng·∫Øm t·ª± b·∫Øn.</p>
            <p><b>Li√™n h·ªá support:</b> <a href="https://www.facebook.com/lvmedits" target="_blank" rel="noopener">C∆∞·ªùng ƒë·∫πp trai</a></p>
            <div class="welcomeRow">
                <div id="welcomeHint">Ch·ªâ b·∫•m n√∫t ƒë·ªÉ ti·∫øp t·ª•c</div>
                <button id="welcomeContinueBtn" type="button">Ok C∆∞·ªùng ƒë·∫πp trai</button>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen">
        <button class="btn" id="btnSettingsStart" style="position:absolute; top:14px; right:14px; z-index:160; margin-top:0; padding:10px 14px; font-size:0.9rem; background:#222; border:1px solid rgba(255,255,255,0.18); box-shadow:0 0 18px rgba(255,255,255,0.08);">SETTINGS</button>
        <div class="start16">
            <div class="startTop">
                <div class="startTitleWrap">
                    <div class="startTitle">TANK BATTLE 2D</div>
                    <div class="startSubtitle">Ch·ªçn h·ªá xe ‚Äî xem preview & k·ªπ nƒÉng</div>
                </div>
                <div class="startHints">
                    <div class="hintLine">Nh·∫∑t <b>2 s√∫ng gi·ªëng nhau</b> ƒë·ªÉ <b>N√ÇNG C·∫§P</b> (t·ªëi ƒëa Lv.5).</div>
                    <div class="hintLine warn">ƒê·∫°n th∆∞·ªùng kh√¥ng bao gi·ªù m·∫•t, ch·ªâ b·ªã h·∫° c·∫•p.</div>
                    <div class="hintLine danger">C·∫¢NH B√ÅO: Boss s·∫Ω ph√° h·ªßy m·ªçi v·∫≠t c·∫£n!</div>
                </div>
            </div>

            <div class="startMain">
                <!-- LEFT: System list -->
                <div class="startLeft">
                    <div class="panelTitle">CH·ªåN H·ªÜ XE TƒÇNG</div>

                    <div id="systemList" class="systemList">
                        <label class="sysItem" data-sys="default">
                            <input type="radio" name="tankSystem" value="default" checked />
                            <canvas class="sysMini" data-sys="default" width="84" height="56"></canvas>
                            <div class="sysText">
                                <div class="sysName">Chi·∫øn Binh</div>
                                <div class="sysDesc">Ph√¢n th√¢n ‚Ä¢ T√†ng h√¨nh ‚Ä¢ H√∫t m√°u</div>
                            </div>
                        </label>

                        <label class="sysItem" data-sys="speed">
                            <input type="radio" name="tankSystem" value="speed" />
                            <canvas class="sysMini" data-sys="speed" width="84" height="56"></canvas>
                            <div class="sysText">
                                <div class="sysName">T·ªëc ƒê·ªô</div>
                                <div class="sysDesc">L∆∞·ªõt ‚Ä¢ Mi·ªÖn th∆∞∆°ng ‚Ä¢ Cu·ªìng t·ªëc</div>
                            </div>
                        </label>

                        <label class="sysItem" data-sys="engineer">
                            <input type="radio" name="tankSystem" value="engineer" />
                            <canvas class="sysMini" data-sys="engineer" width="84" height="56"></canvas>
                            <div class="sysText">
                                <div class="sysName">K·ªπ S∆∞</div>
                                <div class="sysDesc">Th√°p ph√°o ‚Ä¢ S·ª≠a ch·ªØa ‚Ä¢ Xung EMP</div>
                            </div>
                        </label>

                        <label class="sysItem" data-sys="juggernaut">
                            <input type="radio" name="tankSystem" value="juggernaut" />
                            <canvas class="sysMini" data-sys="juggernaut" width="84" height="56"></canvas>
                            <div class="sysText">
                                <div class="sysName">Gi√°p S·∫Øt</div>
                                <div class="sysDesc">Gi√°p ph·∫£n ‚Ä¢ C√∫ h√∫c ‚Ä¢ Ph√°o ƒë√†i</div>
                            </div>
                        </label>

                        <label class="sysItem" data-sys="mage">
                            <input type="radio" name="tankSystem" value="mage" />
                            <canvas class="sysMini" data-sys="mage" width="84" height="56"></canvas>
                            <div class="sysText">
                                <div class="sysName">Ph√°p S∆∞</div>
                                <div class="sysDesc">H·ªèa c·∫ßu ‚Ä¢ D·ªãch chuy·ªÉn ‚Ä¢ B√£o tuy·∫øt</div>
                            </div>
                        </label>
                    </div>

                    <div class="leftFootNote">
                        Tip: <b>t·∫Øt VietKey / b·ªô g√µ ti·∫øng Vi·ªát</b> (chuy·ªÉn EN) ƒë·ªÉ di chuy·ªÉn m∆∞·ª£t m√†.
                    </div>

                    <div class="keyGuideWide">
                        <div class="kg"><span class="key">WASD</span><span>Di chuy·ªÉn</span></div>
                        <div class="kg"><span class="key">Chu·ªôt</span><span>Ng·∫Øm &amp; B·∫Øn</span></div>
                        <div class="kg"><span class="key">1‚Äì6</span><span>Ch·ªçn s√∫ng</span></div>
                        <div class="kg"><span class="key">Q/E/R</span><span>K·ªπ nƒÉng</span></div>
                        <div class="kg"><span class="key">P</span><span>T·∫°m d·ª´ng</span></div>
                        <div class="kg"><span class="key">ESC</span><span>Settings</span></div>
                    </div>

                    <div class="leftActions">
                        
                    <div class="modeBox" id="modeBox">
                        <div class="modeTitle">CH·∫æ ƒê·ªò</div>

                        <div class="modeRow">
                            <div class="modeLabel">ƒê·ªô kh√≥</div>
                            <div class="modeSeg">
                                <label><input type="radio" name="modeDifficulty" value="hard" checked><span>Hard</span></label>
                                <label><input type="radio" name="modeDifficulty" value="easy"><span>Easy</span></label>
                            </div>
                        </div>

                        <div class="modeRow">
                            <div class="modeLabel">Ng∆∞·ªùi ch∆°i</div>
                            <div class="modeSeg">
                                <label><input type="radio" name="modePlayers" value="1" checked><span>1P</span></label>
                                <label><input type="radio" name="modePlayers" value="2"><span>2P</span></label>
                            </div>
                        </div>

                        <div class="modeRow hidden" id="p2SystemRow">
                            <div class="modeLabel">P2 h·ªá</div>
                            <select id="p2SystemSelect" class="modeSelect">
                                <option value="default">Chi·∫øn Binh</option>
                                <option value="speed">T·ªëc ƒê·ªô</option>
                                <option value="engineer">K·ªπ S∆∞</option>
                                <option value="juggernaut">Gi√°p S·∫Øt</option>
                                <option value="mage">Ph√°p S∆∞</option>
                            </select>
                        </div>

                        <div class="modeNote" id="modeNote">Hard 1P: chu·ªôt ng·∫Øm + click b·∫Øn (Phase 1 ch·ªâ l∆∞u mode, ch∆∞a ƒë·ªïi gameplay).</div>
                    </div>

                        
                        <div class="saveRow">
                            <button class="btn startBtnBig saveBtnContinue hidden" id="continueBtn" type="button">TI·∫æP T·ª§C</button>
                            <button class="btn saveBtnClear hidden" id="clearSaveBtn" type="button">X√ìA SAVE</button>
                        </div>
                        <button class="btn startBtnBig" id="startBtn">TRI·ªÇN KHAI</button>
                        <div class="leftStats">Best Score: <span id="startBestScore">0</span> ‚Ä¢ Best Wave: <span id="startBestWave">0</span></div>
                    </div>
                </div>

                <!-- RIGHT: Preview + Skills -->
                <div class="startRight">
                    <div class="previewWrap">
                        <div class="panelTitle">PREVIEW</div>
                        <canvas id="systemPreview" width="640" height="360"></canvas>
                        <div class="previewMeta">
                            <div id="sysTagline" class="sysTagline">‚Äî</div>
</div>
                    </div>

                    <div class="skillsWrap">
                        <div class="panelTitle">B·∫¢NG CHI√äU</div>
                        <div id="systemDetails" class="systemDetails"></div>
                    </div>
                </div>
            </div>
</div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden">
        <h2>TH·∫§T B·∫†I</h2>
        <p>B·∫°n ƒë√£ d·ª´ng b∆∞·ªõc t·∫°i Wave <span id="finalWave" style="color: yellow">0</span></p>
        <p>T·ªïng ƒëi·ªÉm: <span id="finalScore" style="color: white; font-weight: bold; font-size: 2rem;">0</span></p>
        <button class="btn" id="restartBtn" style="background: #d32f2f;">CH∆†I L·∫†I</button>
        <button class="btn" id="menuBtnGO" style="background:#333; margin-top:12px;">V·ªÄ MENU</button>
    </div>


    <!-- Victory Screen -->
    <div id="victoryScreen" class="hidden">
        <h2 style="color:#4CAF50;">CHI·∫æN TH·∫ÆNG</h2>
        <p>B·∫°n ƒë√£ h·∫° Boss t·∫°i Wave <span id="victoryWave" style="color: yellow">0</span></p>
        <p>T·ªïng ƒëi·ªÉm: <span id="victoryScore" style="color: white; font-weight: bold; font-size: 2rem;">0</span></p>
        <p style="margin-top:8px; color:#aaa; font-size:0.95rem;">
            K·ª∑ l·ª•c: Score <span id="victoryBestScore" style="color:#4CAF50; font-weight:800;">0</span> ‚Äî
            Wave <span id="victoryBestWave" style="color:#4CAF50; font-weight:800;">0</span>
        </p>
        <button class="btn" id="victoryRestartBtn" style="background:#18ff6a; color:#041a0c;">CH∆†I L·∫†I</button>
        <button class="btn" id="victoryEndlessBtn" style="background:#FFD54F; color:#1b1300; margin-top:12px;">CH∆†I TI·∫æP (ENDLESS)</button>
        <button class="btn" id="victoryMenuBtn" style="background:#333; margin-top:12px;">V·ªÄ MENU</button>
    </div>


    
    <!-- MAX UI: Settings + Stats -->
    <div id="maxTopBar" class="hidden" style="position:absolute; top:20px; left:50%; transform:translateX(-50%); display:flex; gap:10px; align-items:center; z-index:200; pointer-events:auto;">
        <button class="btn" id="btnPause" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#333; border:1px solid #555;">PAUSE (P)</button>
        <button class="btn" id="btnSettings" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#333; border:1px solid #555;">SETTINGS (Esc)</button>
        <button class="btn" id="btnSaveQuit" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#2b2b2b; border:1px solid #777;">SAVE &amp; QUIT</button>
    </div>

    <div id="settingsModal" class="hidden" style="position:absolute; inset:0; background:rgba(0,0,0,0.75); z-index:300; display:flex; align-items:center; justify-content:center; pointer-events:auto;">
        <div style="width:min(620px,92vw); background:rgba(10,10,10,0.95); border:2px solid #4CAF50; border-radius:14px; padding:22px; box-shadow:0 0 30px rgba(76,175,80,0.25);">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                <div style="font-size:1.4rem; font-weight:800; color:#4CAF50; letter-spacing:1px;">SETTINGS</div>
                <button class="btn" id="btnCloseSettings" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#d32f2f;">CLOSE</button>
            </div>

            <div style="margin-top:16px; display:grid; grid-template-columns: 1fr; gap:14px; color:#ddd;">
                <div style="display:grid; grid-template-columns: 160px 1fr 70px; gap:10px; align-items:center;">
                    <div>√Çm l∆∞·ª£ng</div>
                    <input id="setVolume" type="range" min="0" max="1" step="0.01" />
                    <div id="setVolumeVal" style="text-align:right; color:#FFD700; font-weight:700;">100%</div>
                </div>

                <div style="display:grid; grid-template-columns: 160px 1fr 70px; gap:10px; align-items:center;">
    <div>√Çm l∆∞·ª£ng Music</div>
    <input id="setMusicVolume" type="range" min="0" max="1" step="0.01" />
    <div id="setMusicVolumeVal" style="text-align:right; color:#FFD700; font-weight:700;">70%</div>
</div>

<div style="display:grid; grid-template-columns: 160px 1fr 70px; gap:10px; align-items:center;">
                    <div>FPS cap</div>
                    <input id="setFpsCap" type="range" min="30" max="120" step="1" />
                    <div id="setFpsCapVal" style="text-align:right; color:#FFD700; font-weight:700;">60</div>
                </div>

                <div style="display:flex; gap:16px; flex-wrap:wrap;">
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setShake" type="checkbox" /> Screen shake</label>
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setMinimap" type="checkbox" /> Minimap</label>
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setFps" type="checkbox" /> FPS Counter</label>
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setAutoSave" type="checkbox" /> Auto Save</label>
                </div>

                <div style="padding:10px 12px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.12); border-radius:10px;">
                    <div style="font-weight:800; margin-bottom:6px; color:#FFD700;">PROGRESS</div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                        <div>Best Score: <span id="bestScore" style="color:#4CAF50; font-weight:800;">0</span></div>
                        <div>Best Wave: <span id="bestWave" style="color:#4CAF50; font-weight:800;">0</span></div>
                    </div>
                    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                        <button class="btn" id="btnSaveNow" style="margin-top:0; padding:10px 14px; font-size:0.9rem;">SAVE</button>
                        <button class="btn" id="btnResetSave" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#444; border:1px solid #666;">RESET SAVE</button>
                    </div>
                    </div>

                <div style="font-size:0.9rem; color:#888; line-height:1.4;">
                    Hotkeys: <span class="key">P</span> Pause/Resume, <span class="key">Esc</span> Settings, <span class="key">M</span> Minimap, <span class="key">F</span> FPS.
                </div>
            </div>
        </div>
    </div>

    <!-- SHOP (Wave Complete) -->
    <div id="shopModal" class="hidden" style="position:absolute; inset:0; background:rgba(0,0,0,0.78); z-index:320; display:flex; align-items:center; justify-content:center; pointer-events:auto;">
        <div style="width:min(760px,94vw); background:rgba(10,10,10,0.96); border:2px solid #FFD700; border-radius:16px; padding:22px; box-shadow:0 0 30px rgba(255,215,0,0.18);">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                <div style="font-size:1.35rem; font-weight:900; color:#FFD700; letter-spacing:1px;">SHOP</div>
                <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
                    <div style="font-weight:900; color:#FFD700;">GOLD: <span id="shopGold">0</span></div>
                    <div style="color:#aaa; font-weight:700;">Next wave: <span id="shopNextWave" style="color:#4CAF50;">2</span></div>
                </div>
            </div>

            <div style="margin-top:14px; color:#cfcfcf; font-size:0.95rem; line-height:1.35;">
                Ch·ªçn n√¢ng c·∫•p b·∫±ng v√†ng (B∆∞·ªõc 2E/2F: Magnet Range +30px v√† Armor -5% ƒë√£ mua ƒë∆∞·ª£c).
            </div>

            <div id="shopCards" style="margin-top:16px; display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:12px;">
                <div class="shopCard" style="background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Max HP</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">+25% Max HP</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upMaxHpLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyMaxHp" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upMaxHpCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Damage %</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">+10% Damage</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upDmgLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyDmg" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upDmgCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Fire Rate</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">-5% Cooldown</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upFireRateLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyFireRate" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upFireRateCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">ƒê·ªông C∆°</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">+5% T·ªëc ƒê·ªô</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upSpeedLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuySpeed" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upSpeedCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>

                <div class="shopCard" style="background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Pickup Range</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">+30px Magnet</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upMagnetLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyMagnet" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upMagnetCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Armor</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">-5% Damage Taken</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upArmorLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyArmor" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upArmorCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>

            </div>
<div class="shopCard" data-fixed="1" style="background:rgba(76,175,80,0.10); border:1px solid rgba(76,175,80,0.35); border-radius:14px; padding:14px;">
    <div style="font-weight:900; color:#fff;">H·ªìi M√°u 30%</div>
    <div style="margin-top:6px; color:#999; font-size:0.9rem;">H·ªìi 30% Max HP (kh√¥ng h·ªìi sinh)</div>
    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Gi√°: <span id="upHeal30Cost" style="color:#FFD700; font-weight:900;">200</span>G</div>
    <button class="btn" id="btnBuyHeal30" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span>200<span style="opacity:0.9;">G)</span></button>
</div>

            <div style="margin-top:16px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
                <div style="font-size:0.9rem; color:#888;">Nh·∫•n <span class="key">Enter</span> ƒë·ªÉ ti·∫øp t·ª•c.</div>
                <button class="btn" id="btnShopContinue" style="margin-top:0; padding:12px 16px;">CONTINUE</button>
            </div>
        </div>
    </div>
    <script>
(function(){

console.log("BUILD:", "v54-shopInit-nestingFix");
/* ===== BACKGROUND MUSIC (BGM) =====
   Folder structure (same level as this HTML):
     Music/Background music/*.mp3   (menu)
     Music/Music in games/*.mp3     (in-game)
   OR (lowercase):
     music/Background music/*.mp3
     music/Music in games/*.mp3

   IMPORTANT (Browser limitation):
   - A page cannot "see" what's inside a folder unless the server provides directory listing,
     OR you provide a manifest file (playlist.txt / playlist.json / playlist.m3u).
   - VSCode Live Server usually blocks folder listing, so use playlist.txt for reliable auto play.

   playlist.txt format: one mp3 filename per line (must match exactly).
   Playback starts after a user gesture (Welcome OK / Start) due to browser autoplay rules.
*/
(function(){
  if (window.BGM) return;

  const state = {
    ctx: 'menu',
    discovered: false,
    playlists: { menu: [], game: [] },
    idx: { menu: 0, game: 0 },
    audio: null,
    lastUrl: null,
    muted: false,
    userVol: 0.7,
    vol: { menu: 0.45, game: 0.42 },
    rootPicked: null,
  };

  // Sync with saved settings (if available)
  try{
    const s = window.State && window.State.save && window.State.save.settings;
    if(s && typeof s.musicVolume === 'number') state.userVol = s.musicVolume;
  }catch(e){}

  const isMp3 = (name) => /\.mp3$/i.test(name || '');
  const niceName = (url) => {
    try {
      const u = new URL(url, location.href);
      const p = (u.pathname || '').split('/').pop() || '';
      return decodeURIComponent(p);
    } catch (e) { return String(url || ''); }
  };
  const uniq = (arr) => Array.from(new Set(arr));
  const uniqKeepOrder = (arr) => {
    const seen = new Set();
    const out = [];
    for (const v of arr){
      if(seen.has(v)) continue;
      seen.add(v);
      out.push(v);
    }
    return out;
  };
  const sortByName = (urls) => urls.slice().sort((a,b) =>
    niceName(a).localeCompare(niceName(b), 'vi', { numeric: true, sensitivity: 'base' })
  );

  function absBase(relDir){
    // relDir can be "./Music/Background music/" etc
    try { return new URL(relDir, location.href).toString(); } catch(e){ return relDir; }
  }

  async function loadPlaylistFile(relDir){
    const dir = absBase(relDir);
    const candidates = ['playlist.json', 'playlist.txt', 'playlist.m3u'];
    for(const file of candidates){
      try{
        const url = new URL(file, dir).toString();
        const res = await fetch(url, { cache: 'no-store' });
        if(!res.ok) continue;

        if(file.endsWith('.json')){
          const data = await res.json();
          let arr = Array.isArray(data) ? data : (data && Array.isArray(data.tracks) ? data.tracks : []);
          const out = [];
          for(const item of arr){
            if(typeof item !== 'string') continue;
            const line = item.trim();
            if(!isMp3(line)) continue;
            try{ out.push(new URL(line, dir).toString()); }catch(e){}
          }
          return uniqKeepOrder(out);
        }else{
          const txt = await res.text();
          const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          const out = [];
          for(const line0 of lines){
            const line = line0.trim();
            if(!line || line.startsWith('#')) continue;
            if(!isMp3(line)) continue;
            try{ out.push(new URL(line, dir).toString()); }catch(e){}
          }
          return uniqKeepOrder(out);
        }
      }catch(e){}
    }
    return null; // not found
  }

  async function listMp3FromDirListing(relDir){
    const dir = absBase(relDir);
    try{
      const res = await fetch(dir, { cache: 'no-store' });
      if(!res.ok) return [];
      const txt = await res.text();

      // Parse typical directory listings (python http.server / nginx autoindex / apache)
      const reHref = /href\s*=\s*["']([^"']+)["']/ig;
      let m; const out = [];
      while((m = reHref.exec(txt))){
        const href = m[1];
        if(!href) continue;
        if(href === '../' || href.startsWith('?') || href.startsWith('#')) continue;
        if(!isMp3(href)) continue;
        try{ out.push(new URL(href, dir).toString()); }catch(e){}
      }
      return sortByName(uniq(out));
    }catch(e){
      return [];
    }
  }

  async function autoDiscover(){
    if(state.discovered) return;
    state.discovered = true;

    // Support both "music" and "Music"
    const roots = ['./music/', './Music/'];
    let pickedRoot = null;

    for(const root of roots){
      const menuRel = root + 'Background music/';
      const gameRel = root + 'Music in games/';

      // Prefer playlist file (works on Live Server), fallback to directory listing
      const [menuManifest, gameManifest] = await Promise.all([
        loadPlaylistFile(menuRel),
        loadPlaylistFile(gameRel),
      ]);

      const [menuList, gameList] = await Promise.all([
        (menuManifest !== null) ? Promise.resolve(menuManifest) : listMp3FromDirListing(menuRel),
        (gameManifest !== null) ? Promise.resolve(gameManifest) : listMp3FromDirListing(gameRel),
      ]);

      if ((menuList && menuList.length) || (gameList && gameList.length)){
        state.playlists.menu = menuList || [];
        state.playlists.game = gameList || [];
        pickedRoot = root;
        break;
      }
    }

    // Fallback: if only one playlist exists, use it for both contexts (so you still hear music)
    if(!state.playlists.menu.length && state.playlists.game.length){
      state.playlists.menu = state.playlists.game.slice();
    }
    if(!state.playlists.game.length && state.playlists.menu.length){
      state.playlists.game = state.playlists.menu.slice();
    }

    state.rootPicked = pickedRoot;

    const total = state.playlists.menu.length + state.playlists.game.length;
    if (total === 0) {
      try {
        console.log('[BGM] No tracks found.');
        console.log('[BGM] Checked roots:', roots);
        console.log('[BGM] Live Server usually blocks folder listing, so use playlist.txt:');
        console.log('  Music/Background music/playlist.txt');
        console.log('  Music/Music in games/playlist.txt');
      } catch(e){}
    } else {
      try {
        console.log('[BGM] Using root:', pickedRoot || '(unknown)');
        console.log('[BGM] Tracks:', {
          menu: state.playlists.menu.map(niceName),
          game: state.playlists.game.map(niceName)
        });
      } catch(e){}
    }
  }

  function ensureAudio(){
    if(state.audio) return state.audio;
    const a = document.createElement('audio');
    a.preload = 'auto';
    a.loop = false;
    a.autoplay = false;
    a.crossOrigin = 'anonymous';
    a.addEventListener('ended', () => next());
    a.addEventListener('error', () => { setTimeout(() => next(), 180); });
    state.audio = a;
    return a;
  }

  function applyVolume(){
    const a = state.audio;
    if(!a) return;
    a.volume = state.muted ? 0 : ((state.vol[state.ctx] ?? 0.40) * (state.userVol ?? 1));
  }

  function setMusicVolume(v){
    const n = Math.max(0, Math.min(1, Number(v)));
    state.userVol = isNaN(n) ? 0.7 : n;
    applyVolume();
  }

  function setSrc(url){
    const a = ensureAudio();
    if(state.lastUrl && typeof state.lastUrl === 'string' && state.lastUrl.startsWith('blob:')){
      try { URL.revokeObjectURL(state.lastUrl); } catch(e){}
    }
    state.lastUrl = url;
    a.src = url;
  }

  function currentList(){
    return state.playlists[state.ctx] || [];
  }

  async function playCurrent(){
    await autoDiscover();
    const list = currentList();
    if(!list.length) return;

    let i = state.idx[state.ctx] || 0;
    if(i < 0) i = 0;
    if(i >= list.length) i = 0;
    state.idx[state.ctx] = i;

    const url = list[i];
    setSrc(url);
    applyVolume();

    try{
      const p = state.audio.play();
      if(p && p.catch) p.catch(()=>{});
    }catch(e){}
  }

  function next(){
    const list = currentList();
    if(!list.length) return;
    state.idx[state.ctx] = ((state.idx[state.ctx] || 0) + 1) % list.length;
    playCurrent();
  }

  function setContext(ctx){
    state.ctx = (ctx === 'game') ? 'game' : 'menu';
    if(state.audio){
      if(!state.audio.paused) playCurrent();
      else applyVolume();
    }
  }

  async function onUserGesture(ctx){
    setContext(ctx);
    ensureAudio();
    await playCurrent();
  }

  function mute(v=true){
    state.muted = !!v;
    applyVolume();
  }

  window.BGM = { setContext, onUserGesture, next, mute, setMusicVolume, _state: state };
})();

/* ===== WELCOME OVERLAY (pre-menu) ===== */
(function(){
  const overlay = document.getElementById('welcomeOverlay');
  const startScreen = document.getElementById('startScreen');
  const btn = document.getElementById('welcomeContinueBtn');
  if(!overlay || !startScreen || !btn) return;
  if(window.__WELCOME_OVERLAY_INITED__) return;
  window.__WELCOME_OVERLAY_INITED__ = true;

  // Show welcome card on top of start menu (no dim background)
  overlay.style.display = 'flex';

  const close = () => {
    overlay.style.display = 'none';
  };

  // Only button click can close
  btn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if(e.stopImmediatePropagation) e.stopImmediatePropagation();
    try{ window.BGM && window.BGM.onUserGesture && window.BGM.onUserGesture('menu'); }catch(_e){}
    close();
  }, { passive: false });
})();


const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        

        // --- MAX EDITION: Settings / Save / Audio / Pause / FPS ---
        const MAX = (() => {
            const SAVE_KEY = "tank_battle_max_save_v1";

            const defaultSave = {
                bestScore: 0,
                bestWave: 0,
                settings: {
                    volume: 0.8,
                    musicVolume: 0.7,
                    fpsCap: 60,
                    shake: true,
                    minimap: true,
                    fps: false,
                    autoSave: true
                }
            };

            const Storage = {
                load() {
                    try {
                        const raw = localStorage.getItem(SAVE_KEY);
                        if (!raw) return structuredClone(defaultSave);
                        const data = JSON.parse(raw);
                        return {
                            ...structuredClone(defaultSave),
                            ...data,
                            settings: { ...structuredClone(defaultSave.settings), ...(data.settings || {}) }
                        };
                    } catch (e) {
                        console.warn("Save load failed:", e);
                        return structuredClone(defaultSave);
                    }
                },
                save(saveObj) {
                    try { localStorage.setItem(SAVE_KEY, JSON.stringify(saveObj)); }
                    catch (e) { console.warn("Save write failed:", e); }
                },
                reset() { localStorage.removeItem(SAVE_KEY); }
            };

            // Tiny WebAudio synth (no external files)
            const Audio = {
                ctx: null,
                master: null,
                enabled: true,
                init() {
                this.paused = false;
                    if (this.ctx) return;
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                        this.master = this.ctx.createGain();
                        this.master.gain.value = 0.8;
                        this.master.connect(this.ctx.destination);
                    } catch (e) {
                        console.warn("Audio disabled:", e);
                        this.enabled = false;
                    }
                },
                setVolume(v) {
                    if (!this.master) return;
                    this.master.gain.value = Math.max(0, Math.min(1, v));
                },
                ping(freq, dur, type="sine", gain=0.08) {
                    if (!this.enabled) return;
                    this.init();
                    if (!this.ctx) return;
                    const t0 = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.type = type;
                    osc.frequency.value = freq;
                    g.gain.value = gain;
                    osc.connect(g);
                    g.connect(this.master);
                    g.gain.setValueAtTime(gain, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                    osc.start(t0);
                    osc.stop(t0 + dur);
                },
                shoot() { this.ping(520, 0.06, "square", 0.05); this.ping(260, 0.05, "sine", 0.03); },
                hit()   { this.ping(180, 0.08, "sawtooth", 0.05); },
                boom()  { this.ping(90, 0.18, "sawtooth", 0.08); this.ping(60, 0.22, "square", 0.05); },
                ulti()  { this.ping(140, 0.35, "sawtooth", 0.10); this.ping(70, 0.45, "square", 0.08); },
                ting() { this.ping(1040, 0.08, "sine", 0.06); this.ping(1560, 0.10, "triangle", 0.045); }
            };

            const State = {
                save: Storage.load(),
                paused: false,
                fps: { last: performance.now(), frames: 0, value: 0 },
                applySettings() {
                    const s = this.save.settings;
                    Audio.setVolume(s.volume);
                                        if (window.BGM && typeof window.BGM.setMusicVolume === "function") { window.BGM.setMusicVolume(s.musicVolume); }
const fpsEl = document.getElementById("fpsCounter");
                    if (fpsEl) fpsEl.classList.toggle("hidden", !s.fps);
                },
                updateBest(score, wave) {
                    let changed = false;
                    if (score > this.save.bestScore) { this.save.bestScore = score; changed = true; }
                    if (wave > this.save.bestWave) { this.save.bestWave = wave; changed = true; }
                    if (changed && this.save.settings.autoSave) Storage.save(this.save);
                    this.syncSettingsUI();
                },
                syncSettingsUI() {
                    const bs = document.getElementById("bestScore");
                    const bw = document.getElementById("bestWave");
                    if (bs) bs.textContent = this.save.bestScore;
                    if (bw) bw.textContent = this.save.bestWave;

                    const s = this.save.settings;
                    const vol = document.getElementById("setVolume");
                    const volVal = document.getElementById("setVolumeVal");
                                        const mv = document.getElementById("setMusicVolume");
                    const mvVal = document.getElementById("setMusicVolumeVal");
const cap = document.getElementById("setFpsCap");
                    const capVal = document.getElementById("setFpsCapVal");
                    const sh = document.getElementById("setShake");
                    const mm = document.getElementById("setMinimap");
                    const fp = document.getElementById("setFps");
                    const as = document.getElementById("setAutoSave");

                    if (vol) vol.value = s.volume;
                    if (volVal) volVal.textContent = Math.round(s.volume * 100) + "%";
                                        if (mv) mv.value = (typeof s.musicVolume === "number" ? s.musicVolume : 0.7);
                    if (mvVal) mvVal.textContent = Math.round((typeof s.musicVolume === "number" ? s.musicVolume : 0.7) * 100) + "%";
if (cap) cap.value = s.fpsCap;
                    if (capVal) capVal.textContent = String(s.fpsCap);
                    if (sh) sh.checked = !!s.shake;
                    if (mm) mm.checked = !!s.minimap;
                    if (fp) fp.checked = !!s.fps;
                    if (as) as.checked = !!s.autoSave;
                }
            };

            const UI = {
                init() {
                    // Buttons
                    const topBar = document.getElementById("maxTopBar");
                    const btnSettings = document.getElementById("btnSettings");
                    const btnClose = document.getElementById("btnCloseSettings");
                    const btnPause = document.getElementById("btnPause");
                    const modal = document.getElementById("settingsModal");

                                        const btnSettingsStart = document.getElementById("btnSettingsStart");
const open = () => { if (modal) modal.classList.remove("hidden"); };
                    const close = () => { if (modal) modal.classList.add("hidden"); };

                    if (btnSettings) btnSettings.addEventListener("click", open);
                    if (btnSettingsStart) btnSettingsStart.addEventListener("click", open);
                    if (btnClose) btnClose.addEventListener("click", close);
                    if (btnPause) btnPause.addEventListener("click", () => Toggle.pause());

                    // Settings controls
                    const vol = document.getElementById("setVolume");
                    const mv  = document.getElementById("setMusicVolume");
                    const cap = document.getElementById("setFpsCap");
                    const sh  = document.getElementById("setShake");
                    const mm  = document.getElementById("setMinimap");
                    const fp  = document.getElementById("setFps");
                    const as  = document.getElementById("setAutoSave");

                    const saveNow = document.getElementById("btnSaveNow");
                    const resetSave = document.getElementById("btnResetSave");

                    if (vol) vol.addEventListener("input", () => {
                        State.save.settings.volume = parseFloat(vol.value);
                        State.applySettings();
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (mv) mv.addEventListener("input", () => {
    State.save.settings.musicVolume = parseFloat(mv.value);
    State.applySettings();
    State.syncSettingsUI();
    if (State.save.settings.autoSave) Storage.save(State.save);
});

if (cap) cap.addEventListener("input", () => {
                        const v = parseInt(cap.value, 10);
                        State.save.settings.fpsCap = Math.max(30, Math.min(120, isNaN(v) ? 60 : v));
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
if (sh) sh.addEventListener("change", () => {
                        State.save.settings.shake = !!sh.checked;
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (mm) mm.addEventListener("change", () => {
                        State.save.settings.minimap = !!mm.checked;
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (fp) fp.addEventListener("change", () => {
                        State.save.settings.fps = !!fp.checked;
                        State.applySettings();
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (as) as.addEventListener("change", () => {
                        State.save.settings.autoSave = !!as.checked;
                        State.syncSettingsUI();
                        Storage.save(State.save);
                    });

                    if (saveNow) saveNow.addEventListener("click", () => Storage.save(State.save));
                    if (resetSave) resetSave.addEventListener("click", () => { Storage.reset(); State.save = Storage.load(); State.applySettings(); State.syncSettingsUI(); });

                    // Hotkeys (works alongside your Input system)
                    window.addEventListener("keydown", (e) => {
                        const code = e.code || "";
                        const k = (e.key || "").toLowerCase();

                        // ESC toggles Settings (works even when an input keeps focus)
                        if (k === "escape" || code === "Escape") {
                            e.preventDefault();
                            if (modal && !modal.classList.contains("hidden")) close(); else open();
                            return;
                        }

                        // If user is typing into a text field, don't steal their hotkeys.
                        const tgt = e.target;
                        if (tgt) {
                            const tag = tgt.tagName;
                            const type = (tag === "INPUT" ? (tgt.getAttribute("type") || "").toLowerCase() : "");
                            const textLike = (tag === "TEXTAREA") || tgt.isContentEditable ||
                                             (tag === "INPUT" && ["text","password","search","email","number","tel","url"].includes(type));
                            if (textLike) return;
                        }

                        // Prevent key-repeat from toggling pause on/off instantly.
                        if (e.repeat) return;

                        // Use e.code so hotkeys still work under IME (VietKey/UniKey).
                        if (k === "p" || code === "KeyP") { e.preventDefault(); Toggle.pause(); return; }
                        if (k === "m" || code === "KeyM") { State.save.settings.minimap = !State.save.settings.minimap; State.syncSettingsUI(); if (State.save.settings.autoSave) Storage.save(State.save); return; }
                        if (k === "f" || code === "KeyF") { State.save.settings.fps = !State.save.settings.fps; State.applySettings(); State.syncSettingsUI(); if (State.save.settings.autoSave) Storage.save(State.save); return; }
});
                    // (v30) Start screen stats are shown in left panel (leftStats). No extra DOM injection here.
// keep top bar visible only in game
                    const uiLayer = document.getElementById("gameUI");
                    const updateTop = () => {
                        const inGame = uiLayer && !uiLayer.classList.contains("hidden");
                        if (topBar) topBar.classList.toggle("hidden", !inGame);
                    };
                    setInterval(updateTop, 250);

                    State.applySettings();
                    State.syncSettingsUI();
                }
            };

            const Toggle = {
                pause() {
                    State.paused = !State.paused;
                    if (State.paused) {
                        if (typeof Game !== "undefined") Game.paused = true;
                    } else {
                        if (typeof Game !== "undefined") { Game.paused = false; requestAnimationFrame(loop); }
                    }
                }
            };

            return { State, Storage, Audio, UI, Toggle };
        })();

// --- 1. CONFIGURATION ---
        
        let WORLD_WIDTH = window.innerWidth * 3;
        let WORLD_HEIGHT = window.innerHeight * 3;
        const MINIMAP_SIZE = 150;
        const MINIMAP_MARGIN = 20;

        const COLORS = {
            player: '#4CAF50',
            playerTurret: '#2E7D32',
            clone: '#29B6F6', 
            cloneTurret: '#0288D1',
            shield: 'rgba(0, 191, 255, 0.4)',
            text: '#fff',
            obstacle: '#546E7A',
            obstacleBorder: '#37474F'
        };

        const ENEMY_TYPES = {
            RED: { id: 'RED', name: 'L√≠nh th∆∞·ªùng', color: '#e53935', hp: 45, maxHp: 45, speed: 2.5, damage: 10, score: 10, radius: 18, behavior: 'CHASE', fireRate: 3000, bulletSpeed: 5.5, bulletDmg: 8 , gold: 10 },
            BLACK: { id: 'BLACK', name: 'H·∫°ng n·∫∑ng', color: '#212121', hp: 200, maxHp: 200, speed: 1.0, damage: 30, score: 50, radius: 28, behavior: 'CHASE_SLOW', outline: '#757575', fireRate: 4000, bulletSpeed: 4, bulletDmg: 20 , gold: 25 },
            YELLOW: { id: 'YELLOW', name: 'Trinh s√°t', color: '#FFD700', hp: 25, maxHp: 25, speed: 4.5, damage: 5, score: 25, radius: 14, behavior: 'ORBIT', fireRate: 1200, bulletSpeed: 7.5, bulletDmg: 5 , gold: 15 },
            PURPLE: { id: 'PURPLE', name: 'B·∫Øn t·ªâa', color: '#9C27B0', hp: 40, maxHp: 40, speed: 1.8, damage: 15, score: 40, radius: 20, behavior: 'SNIPER', fireRate: 3500, bulletSpeed: 11, bulletDmg: 25 , gold: 40 },
            BOSS: { id: 'BOSS', name: 'MECHA BOSS', color: '#D50000', hp: 2000, maxHp: 2000, speed: 1.5, damage: 50, score: 1000, radius: 60, behavior: 'BOSS', fireRate: 2000, bulletSpeed: 8, bulletDmg: 20 , gold: 300 }
        };

        const BULLET_TYPES = {
            NORMAL: { id: 'NORMAL', name: 'Th∆∞·ªùng', color: '#FFF', damage: 20, speed: 12, cooldown: 350, radius: 4 },
            ROCKET: { id: 'ROCKET', name: 'Rocket', color: '#FF5722', damage: 90, speed: 9, cooldown: 650, radius: 6, special: 'EXPLODE', explosionRadius: 130, splashFactor: 0.75 , homingRange: 500, turnSpeed: 0.2 },
            STUN: { id: 'STUN', name: 'Cho√°ng', color: '#00BCD4', damage: 15, speed: 14, cooldown: 450, radius: 5, effect: { type: 'STUN', duration: 1500 } },
            LIGHTNING: { id: 'LIGHTNING', name: 'S·∫•m S√©t', color: '#FFEB3B', damage: 45, speed: 18, cooldown: 600, radius: 4, special: 'CHAIN', chainRange: 300, chainCount: 3, chainDmgFactor: 0.7 },
            FIRE: { id: 'FIRE', name: 'ƒê·∫°n L·ª≠a', color: '#FF5722', damage: 20, speed: 13, cooldown: 250, radius: 6, effect: { type: 'BURN', duration: 3000, tickInterval: 500, tickDamage: 8 } },
            PIERCING: { id: 'PIERCING', name: 'Xuy√™n', color: '#E91E63', damage: 60, speed: 22, cooldown: 700, radius: 6, special: 'PIERCE', pierceCount: 4 },
            HOMING: { id: 'HOMING', name: 'ƒêu·ªïi', color: '#7C4DFF', damage: 25, speed: 11, cooldown: 450, radius: 5, special: 'HOMING', homingRange: 500, turnSpeed: 0.2 }
        };

        // --- Global cap: Fire Rate upgrade max level (based on NORMAL gun) ---
        function getFireRateMaxLv() {
            const baseCd = (BULLET_TYPES && BULLET_TYPES.NORMAL && BULLET_TYPES.NORMAL.cooldown) ? BULLET_TYPES.NORMAL.cooldown : 700;
            const target = 80;      // ms (same as clamp in Player.shoot)
            const mult = 0.95;      // -5% cooldown per level
            if (baseCd <= target) return 0;
            const lv = Math.ceil(Math.log(target / baseCd) / Math.log(mult));
            return Math.max(0, lv);
        }



        const ITEM_TYPES = {
            HP_PACK: { id: 'HP_PACK', color: '#4CAF50', label: '+HP', type: 'HEAL', value: 30, duration: 8000 },
            SHIELD: { id: 'SHIELD', color: '#2196F3', label: 'SHIELD', type: 'BUFF', buffType: 'shield', buffDuration: 8000, duration: 8000 },
            RAPID_FIRE: { id: 'RAPID_FIRE', color: '#FF9800', label: 'RAPID', type: 'BUFF', buffType: 'rapid', buffDuration: 8000, value: 0.5, duration: 8000 },
            AMMO_NORMAL: { id: 'AMMO_NORMAL', color: '#FFF', label: 'NORMAL', type: 'WEAPON', weaponId: 'NORMAL', duration: 15000 },
            AMMO_STUN: { id: 'AMMO_STUN', color: '#00BCD4', label: 'STUN', type: 'WEAPON', weaponId: 'STUN', duration: 15000 },
            AMMO_LIGHTNING: { id: 'AMMO_LIGHTNING', color: '#FFEB3B', label: 'LIGHT', type: 'WEAPON', weaponId: 'LIGHTNING', duration: 15000 },
            AMMO_FIRE: { id: 'AMMO_FIRE', color: '#FF5722', label: 'FIRE', type: 'WEAPON', weaponId: 'FIRE', duration: 15000 },
            AMMO_PIERCE: { id: 'AMMO_PIERCE', color: '#E91E63', label: 'PIERCE', type: 'WEAPON', weaponId: 'PIERCING', duration: 15000 },
            AMMO_HOMING: { id: 'AMMO_HOMING', color: '#7C4DFF', label: 'HOMING', type: 'WEAPON', weaponId: 'HOMING', duration: 15000 }
        };

        const SKILL_CONFIG = {
            // H·ªá Chi·∫øn Binh (default)
            CLONE: { cooldown: 14000, duration: 8000, hp: 150 },
            STEALTH: { cooldown: 11000, duration: 3000 },
            VAMPIRISM: { cooldown: 18000, duration: 4000, leechPercent: 0.2, capPerSecond: 20 }
        };

        // --- S0: Tank System (3 systems) + Skill Framework ---
        // Note: Internal skill keys remain 'clone/stealth/vampirism' as 3 fixed slots (Q/E/R)
        // to keep the existing UI overlay ids (cd-clone/cd-stealth/cd-vampirism) stable.
        const TANK_SYSTEMS = {
            default: {
                id: 'default',
                name: 'H·ªá Chi·∫øn Binh',
                skills: {
                    clone:     { key: 'Q', labelHTML: 'Ph√¢n<br>Th√¢n',   color: '#29B6F6', cooldown: SKILL_CONFIG.CLONE.cooldown,     duration: SKILL_CONFIG.CLONE.duration },
                    stealth:   { key: 'E', labelHTML: 'T√†ng<br>H√¨nh',   color: '#AB47BC', cooldown: SKILL_CONFIG.STEALTH.cooldown,   duration: SKILL_CONFIG.STEALTH.duration },
                    vampirism: { key: 'R', labelHTML: 'H√∫t<br>M√°u',     color: '#FF5252', cooldown: SKILL_CONFIG.VAMPIRISM.cooldown, duration: SKILL_CONFIG.VAMPIRISM.duration }
                }
            },
            speed: {
                id: 'speed',
                name: 'H·ªá T·ªëc ƒê·ªô',
                skills: {
                    // Q / E / R slots gi·ªØ nguy√™n (clone/stealth/vampirism) ƒë·ªÉ UI kh√¥ng ƒë·ªïi
                    // Q: Dash
                    clone:     { key: 'Q', labelHTML: 'L∆∞·ªõt',          color: '#4FC3F7', cooldown: 3000,  duration: 250, dashSpeedMult: 3.2 },
                    // E: Phase (mi·ªÖn th∆∞∆°ng ng·∫Øn)
                    stealth:   { key: 'E', labelHTML: 'Mi·ªÖn<br>Th∆∞∆°ng',         color: '#81D4FA', cooldown: 10000, duration: 1000 },
                    // R: Adrenaline (buff)
                    vampirism: { key: 'R', labelHTML: 'Cu·ªìng<br>T·ªëc',         color: '#29B6F6', cooldown: 14000, duration: 4000, speedMult: 1.25, fireMult: 0.5, damageMult: 1.3 }
                }
            },
            engineer: {
                id: 'engineer',
                name: 'H·ªá K·ªπ S∆∞',
                skills: {
                    // Q: Turret ƒë·∫∑t th√°p t·ª± b·∫Øn
                    clone:     { key: 'Q', labelHTML: 'Th√°p<br>Ph√°o',        color: '#81C784', cooldown: 12000, duration: 10000, maxTurrets: 1, range: 650, fireRate: 320, bulletColor: '#66BB6A', bulletDmgMult: 0.65 },
                    // E: Repair h·ªìi m√°u t·ª©c th√¨
                    stealth:   { key: 'E', labelHTML: 'S·ª≠a<br>Ch·ªØa',        color: '#A5D6A7', cooldown: 16000, heal: 30 },
                    // R: EMP cho√°ng di·ªán r·ªông (Boss mi·ªÖn nhi·ªÖm theo Enemy.applyEffect)
                    vampirism: { key: 'R', labelHTML: 'Xung<br>EMP',           color: '#00E5FF', cooldown: 18000, radius: 1020, stunDuration: 2400 }
                }
            },
            juggernaut: {
                id: 'juggernaut',
                name: 'H·ªá Gi√°p S·∫Øt',
                skills: {
                    // J0: ch·ªâ khung UI + cooldown. Logic s·∫Ω tri·ªÉn khai ·ªü J1/J2/J3
                    // Q: Reflective Shield
                    clone:     { key: 'Q', labelHTML: 'Gi√°p<br>Ph·∫£n', color: '#FFD54F', cooldown: 12000, duration: 5000, castText: 'J0: GI√ÅP PH·∫¢N L·ª∞C' },
                    // E: Battering Ram
                    stealth:   { key: 'E', labelHTML: 'C√∫<br>H√∫c',   color: '#FFCA28', cooldown: 8000,  duration: 400, ramSpeedMult: 3.0, impactBase: 60, impactPerWave: 3, knockback: 95, castText: 'J0: C√ö H√öC' },
                    // R: Siege Mode
                    vampirism: { key: 'R', labelHTML: 'Ph√°o<br>ƒê√†i', color: '#FFC107', cooldown: 25000, duration: 6000, castText: 'J0: PH√ÅO ƒê√ÄI' }
                }
            }

        
            ,
            mage: {
                id: 'mage',
                name: 'Ph√°p S∆∞',
                color: '#7B1FA2',
                skills: {
                    clone: {
                        key: 'Q',
                        labelHTML: 'H·ªèa<br>C·∫ßu',
                        color: '#FF5722',
                        cooldown: 2000,
                        fireballBase: 60,
                        fireballDmgMult: 3.2,
                        fireballRadius: 36,
                        fireballSpeed: 4,
                        explosionRadius: 320,
                        splashFactor: 0.85,
                        castText: 'Q: H·ªéA C·∫¶U'
                    },
                    stealth: {
                        key: 'E',
                        labelHTML: 'D·ªãch<br>Chuy·ªÉn',
                        color: '#E040FB',
                        cooldown: 5500,
                        castText: 'E: D·ªäCH CHUY·ªÇN'
                    },
                    vampirism: {
                        key: 'R',
                        labelHTML: 'B√£o<br>Tuy·∫øt',
                        color: '#00E5FF',
                        cooldown: 16000,
                        duration: 5500,
                        radius: 220,
                        innerRadius: 70,
                        moveSpeed: 220,      // px/second, realtime theo n√≤ng s√∫ng
                        tickInterval: 400,
                        tickDamage: 28,
                        slowFactor: 0.5,
                        slowDuration: 900,
                        castText: 'R: B√ÉO TUY·∫æT'
                    }
                }
            }};

        function getTankSystem(id) {
            return TANK_SYSTEMS[id] || TANK_SYSTEMS.default;
        }

        function getSystemSkillDef(systemId, skillKey) {
            const sys = getTankSystem(systemId);
            return (sys && sys.skills && sys.skills[skillKey]) ? sys.skills[skillKey] : getTankSystem('default').skills[skillKey];
        }


        // --- 2. CAMERA SYSTEM ---
        const Camera = {
            x: 0, y: 0,
            update(player) {
                if (!player || isNaN(player.x) || isNaN(player.y)) return;
                this.x = player.x - canvas.width / 2;
                this.y = player.y - canvas.height / 2;
                this.x = Math.max(0, Math.min(this.x, WORLD_WIDTH - canvas.width));
                this.y = Math.max(0, Math.min(this.y, WORLD_HEIGHT - canvas.height));
                if (isNaN(this.x)) this.x = 0;
                if (isNaN(this.y)) this.y = 0;
            }
        };

        // --- 3. CLASSES ---
        class GameObject {
            constructor(x, y, radius) {
                this.x = x || 0; this.y = y || 0; this.radius = radius; this.markedForDeletion = false;
            }
            validatePosition() { if (isNaN(this.x)) this.x = 0; if (isNaN(this.y)) this.y = 0; }
        }

        // --- IMPROVED PARTICLE CLASS (New Types) ---
        class Particle extends GameObject {
            constructor(x, y, options) {
                super(x, y, options.size || Math.random() * 3 + 1);
                this.velocity = options.velocity || { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 };
                this.color = options.color || 'white';
                this.alpha = 1;
                this.life = options.life || 1.0;
                this.decay = options.decay || 0.02;
                this.type = options.type || 'circle'; // circle, spark, shockwave, smoke, debris
                this.maxRadius = options.maxRadius || 0; // For shockwave
                this.glowBlur = options.glowBlur || 0;
                this.glowColor = options.glowColor || this.color;
            }
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                
                // Friction depends on type
                if (this.type === 'debris') {
                    this.velocity.x *= 0.95; this.velocity.y *= 0.95;
                } else if (this.type === 'smoke') {
                    this.velocity.x *= 0.98; this.velocity.y *= 0.98;
                    this.radius += 0.2; // Smoke expands
                } else {
                    this.velocity.x *= 0.9; this.velocity.y *= 0.9;
                }

                this.alpha -= this.decay;
                if (this.alpha <= 0) this.markedForDeletion = true;
                this.validatePosition();
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.alpha);
                
                if(this.type === 'shockwave') {
                    // Expanding ring
                    if (this.glowBlur > 0) { ctx.shadowBlur = this.glowBlur; ctx.shadowColor = this.glowColor; }
                    const progress = 1 - this.alpha;
                    const currentRad = this.radius + (this.maxRadius - this.radius) * progress;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentRad, 0, Math.PI*2);
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3 * this.alpha;
                    ctx.stroke();
                } else if (this.type === 'spark') {
                    // Thin line/spark
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, 2, 2);
                } else if (this.type === 'debris') {
                    // Irregular shape
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.alpha * 10);
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.radius/2, -this.radius/2, this.radius, this.radius);
                } else if (this.type === 'smoke') {
                    // Soft circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                } else {
                    // Standard circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x; this.y = y; this.width = width; this.height = height;
            }
            draw() {
                ctx.save();
                ctx.fillStyle = COLORS.obstacle;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#263238'; // Shadow
                ctx.fillRect(this.x + 5, this.y + this.height, this.width - 5, 10); 
                ctx.fillRect(this.x + this.width, this.y + 5, 10, this.height - 5); 
                ctx.strokeStyle = COLORS.obstacleBorder;
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.stroke();
                ctx.restore();
            }
        }

        class Pickup extends GameObject {
            constructor(x, y, config) {
                super(x, y, 15);
                this.config = config;
                this.spawnTime = Date.now();
                this.maxLifeTime = config.duration;
                this.floatOffset = 0;
            }
            update() {
                this.floatOffset = Math.sin(Date.now() / 200) * 3;
                if (Date.now() - this.spawnTime > this.maxLifeTime) this.markedForDeletion = true;
                this.validatePosition();
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y + this.floatOffset);
                ctx.shadowBlur = 15; ctx.shadowColor = this.config.color;
                // Ultra GFX compatibility: ensure we always use a valid color string
                const __baseColor = (typeof __safeColor === 'function')
                    ? __safeColor(this.config && this.config.color, '#FFFFFF')
                    : ((this.config && this.config.color) ? this.config.color : '#FFFFFF');
                ctx.fillStyle = __baseColor;
                ctx.fillRect(-12, -12, 24, 24);
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
                ctx.strokeRect(-12, -12, 24, 24);
                ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center';
                ctx.fillText(this.config.label, 0, 4);
                const lifePercent = 1 - (Date.now() - this.spawnTime) / this.maxLifeTime;
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(-12, 14, 24 * lifePercent, 3);
                ctx.restore();
            }
        }


        // --- COIN / GOLD DROP ---
        class Coin extends GameObject {
            constructor(x, y, value) {
                super(x, y, 10);
                this.value = value || 1;
                this.spawnTime = Date.now();
                this.maxLifeTime = 12000; // 12s r·ªìi t·ª± bi·∫øn m·∫•t (t·ªëi ∆∞u)
                const ang = Math.random() * Math.PI * 2;
                const sp = 2.2 + Math.random() * 1.8;
                this.vx = Math.cos(ang) * sp;
                this.vy = Math.sin(ang) * sp - 1.2;
                this.rot = Math.random() * Math.PI * 2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.92;
                this.vy *= 0.92;
                this.rot += 0.2;
                if (Date.now() - this.spawnTime > this.maxLifeTime) this.markedForDeletion = true;
                this.validatePosition();
            }
            draw() {
                const t = (Date.now() - this.spawnTime) / this.maxLifeTime;
                const alpha = t > 0.85 ? Math.max(0, 1 - (t - 0.85) / 0.15) : 1;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = alpha;
                ctx.shadowBlur = 16; ctx.shadowColor = '#FFD700';
                const squish = 0.25 + Math.abs(Math.sin(this.rot)) * 0.75;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8 * squish, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFF4C2'; ctx.lineWidth = 2;
                ctx.stroke();
                ctx.globalAlpha = alpha * 0.35;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(-2, -2, 2.2 * squish, 3.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // --- IMPROVED BULLET CLASS (Trail & Glow) ---
        class Bullet extends GameObject {
            constructor(x, y, angle, typeKey, config, owner = 'PLAYER') {
                super(x, y, config.radius);
                this.angle = angle;
                this.typeKey = typeKey;
                this.config = config; 
                this.owner = owner; 
                this.velocity = { x: Math.cos(angle) * config.speed, y: Math.sin(angle) * config.speed };
                if(isNaN(this.velocity.x)) this.velocity.x = 0;
                if(isNaN(this.velocity.y)) this.velocity.y = 0;
                this.hitList = [];
                this.pierceCount = config.special === 'PIERCE' ? config.pierceCount : 0;
                
                // Trail system
                this.trail = []; 
                this.maxTrailLength = 8;
            }

            update() {
                // Add position to trail (skip for Fireball to avoid long streak)
                if (!this.config.noTrail && this.typeKey !== 'FIREBALL') {
                    this.trail.push({x: this.x, y: this.y});
                    if(this.trail.length > this.maxTrailLength) this.trail.shift();
                } else {
                    // keep trail empty
                    this.trail.length = 0;
                }

                // Homing Logic
                if ((this.config.special === 'HOMING' || this.typeKey === 'ROCKET') && this.owner === 'PLAYER') {
                    let nearest = null; let minDst = (this.config.homingRange != null) ? this.config.homingRange : 500;
                    Game.enemies.forEach(e => {
                        if(isNaN(e.x) || isNaN(e.y)) return;
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDst) { minDst = d; nearest = e; }
                    });
                    if (nearest) {
                        const desiredAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        if(!isNaN(desiredAngle)) {
                            const desiredVx = Math.cos(desiredAngle) * this.config.speed;
                            const desiredVy = Math.sin(desiredAngle) * this.config.speed;
                            const turnSpeed = (this.config.turnSpeed != null) ? this.config.turnSpeed : 0.2;
                            this.velocity.x = this.velocity.x * (1 - turnSpeed) + desiredVx * turnSpeed;
                            this.velocity.y = this.velocity.y * (1 - turnSpeed) + desiredVy * turnSpeed;
                            const currentSpeed = Math.hypot(this.velocity.x, this.velocity.y);
                            if (currentSpeed > 0 && !isNaN(currentSpeed)) {
                                this.velocity.x = (this.velocity.x / currentSpeed) * this.config.speed;
                                this.velocity.y = (this.velocity.y / currentSpeed) * this.config.speed;
                            }
                        }
                    }
                }

                // Update angle to match current velocity (for ROCKET drawing)


                if (this.typeKey === 'ROCKET') {


                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);


                }



                this.x += this.velocity.x;
                this.y += this.velocity.y;
                if (this.x < 0 || this.x > WORLD_WIDTH || this.y < 0 || this.y > WORLD_HEIGHT) {
                    this.markedForDeletion = true;
                }
                this.validatePosition();
            }

            draw() {
                ctx.save();

                // --- TR∆Ø·ªúNG H·ª¢P 1: V·∫º ROCKET (H√¨nh t√™n l·ª≠a) ---
                if (this.typeKey === 'ROCKET') {
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle); // Xoay theo h∆∞·ªõng bay

                    // 1. V·∫Ω ƒëu√¥i l·ª≠a (Thruster)
                    const flicker = Math.random() * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(255, 87, 34, ${flicker})`; // M√†u cam l·ª≠a
                    ctx.beginPath();
                    ctx.moveTo(-10, -4);
                    ctx.lineTo(-25 - Math.random()*10, 0); // ƒêu√¥i l·ª≠a d√†i ng·∫´u nhi√™n
                    ctx.lineTo(-10, 4);
                    ctx.fill();

                    // 2. V·∫Ω th√¢n (H√¨nh tr·ª•)
                    ctx.fillStyle = '#424242'; // M√†u x√°m ƒëen qu√¢n ƒë·ªôi
                    ctx.fillRect(-10, -6, 20, 12); // D√†i 20, R·ªông 12

                    // Vi·ªÅn th√¢n cho r√µ
                    ctx.strokeStyle = '#212121';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-10, -6, 20, 12);

                    // 3. V·∫Ω ƒë·∫ßu ƒë·∫°n (Tam gi√°c)
                    ctx.fillStyle = '#D50000'; // ƒê·∫ßu ƒë·ªè nguy hi·ªÉm
                    ctx.beginPath();
                    ctx.moveTo(10, -6);  // G√≥c tr√™n th√¢n
                    ctx.lineTo(24, 0);   // M≈©i nh·ªçn
                    ctx.lineTo(10, 6);   // G√≥c d∆∞·ªõi th√¢n
                    ctx.fill();
                    ctx.stroke();

                    // 4. V·∫Ω c√°nh ƒëu√¥i (Fins)
                    ctx.fillStyle = '#616161';
                    ctx.beginPath();
                    ctx.moveTo(-10, -6);
                    ctx.lineTo(-18, -12); // C√°nh tr√™n
                    ctx.lineTo(-6, -6);
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-10, 6);
                    ctx.lineTo(-18, 12);  // C√°nh d∆∞·ªõi
                    ctx.lineTo(-6, 6);
                    ctx.fill();
                    ctx.stroke();

                }
                // --- TR∆Ø·ªúNG H·ª¢P 1B: V·∫º FIREBALL (Qu·∫£ c·∫ßu l·ª≠a) ---
                else if (this.typeKey === 'FIREBALL') {
                    ctx.translate(this.x, this.y);

                    const r = this.radius || 36;

                    // Glow m·∫°nh
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = this.config.color || '#FF5722';

                    // Radial gradient cho l√µi + vi·ªÅn
                    const g = ctx.createRadialGradient(0, 0, r * 0.15, 0, 0, r);
                    g.addColorStop(0, 'rgba(255,255,255,0.95)');
                    g.addColorStop(0.25, 'rgba(255,183,77,0.95)');
                    g.addColorStop(0.6, 'rgba(255,87,34,0.85)');
                    g.addColorStop(1, 'rgba(255,87,34,0.10)');

                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = g;
                    ctx.fill();

                    // Vi·ªÅn n√≥ng
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.95, 0, Math.PI * 2);
                    ctx.strokeStyle = '#FF3D00';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.9;
                    ctx.stroke();

                    ctx.globalAlpha = 1;
                } 
                // --- TR∆Ø·ªúNG H·ª¢P 2: V·∫º ƒê·∫†N TH∆Ø·ªúNG (Gi·ªØ nguy√™n code c≈©) ---
                else {
                    // Draw Trail (Code c≈© c·ªßa b·∫°n)
                    if(this.trail.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(this.trail[0].x, this.trail[0].y);
                        for(let i=1; i<this.trail.length; i++) {
                            ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        }
                        ctx.lineCap = 'round';
                        ctx.lineWidth = this.radius;
                        ctx.strokeStyle = this.config.color;
                        ctx.globalAlpha = 0.4;
                        ctx.stroke();
                    }

                    // Draw Head (Code c≈©)
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.config.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 1, 0, Math.PI * 2);
                    ctx.strokeStyle = this.config.color;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // --- CLONE CLASS ---
        class CloneTank extends GameObject {
            constructor(x, y) {
                super(x, y, 22);
                this.hp = SKILL_CONFIG.CLONE.hp; this.maxHp = SKILL_CONFIG.CLONE.hp;
                this.spawnTime = Date.now(); this.duration = SKILL_CONFIG.CLONE.duration;
                this.speed = 4; this.angle = 0; this.lastShot = 0; this.moveAngle = Math.random() * Math.PI * 2;
            }
            update(enemies, obstacles, bullets) {
                if (this.duration !== Infinity && Date.now() - this.spawnTime > this.duration) {
                    this.markedForDeletion = true; createComplexExplosion(this.x, this.y, COLORS.clone); return;
                }
                let nearest = null; let minDst = 1000;
                enemies.forEach(e => { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minDst) { minDst = d; nearest = e; } });
                
                let dodgeX = 0, dodgeY = 0;
                bullets.forEach(b => {
                    if (b.owner === 'ENEMY') {
                        const d = Math.hypot(b.x - this.x, b.y - this.y);
                        if (d < 100) { 
                            const angleToBullet = Math.atan2(b.y - this.y, b.x - this.x);
                            dodgeX -= Math.cos(angleToBullet) * 2; dodgeY -= Math.sin(angleToBullet) * 2;
                        }
                    }
                });

                let desiredAngle = this.angle; let shouldMove = false;
                if (nearest) {
                    const dx = nearest.x - this.x; const dy = nearest.y - this.y; const dist = Math.hypot(dx, dy); desiredAngle = Math.atan2(dy, dx);
                    if (dist > 300) { shouldMove = true; } else if (dist < 150) { desiredAngle += Math.PI; shouldMove = true; } else { desiredAngle += Math.PI / 2; shouldMove = true; }
                    const now = Date.now(); const aimAngle = Math.atan2(dy, dx); this.angle = aimAngle;
                    if (now - this.lastShot > 600) { this.shoot(aimAngle); this.lastShot = now; }
                } else {
                    shouldMove = true; desiredAngle = this.moveAngle; if(Math.random() < 0.05) this.moveAngle += (Math.random()-0.5); this.angle = desiredAngle;
                }
                if (dodgeX !== 0 || dodgeY !== 0) { desiredAngle = Math.atan2(dodgeY, dodgeX); shouldMove = true; }

                let bestAngle = desiredAngle; let foundPath = false;
                const checkAngles = [0, 20, -20, 45, -45, 70, -70, 90, -90, 110, -110, 135, -135, 160, -160, 180];
                for (let offset of checkAngles) {
                    const checkRad = (offset * Math.PI) / 180; const testAngle = desiredAngle + checkRad; if(isNaN(testAngle)) continue;
                    const lookAhead = Math.max(this.radius * 1.5, this.speed * 5); const nextX = this.x + Math.cos(testAngle) * lookAhead; const nextY = this.y + Math.sin(testAngle) * lookAhead;
                    let collided = false;
                    if (nextX < this.radius || nextX > WORLD_WIDTH - this.radius || nextY < this.radius || nextY > WORLD_HEIGHT - this.radius) { collided = true; }
                    if (!collided) { for (let obs of obstacles) { if (checkCircleRect({x: nextX, y: nextY, radius: this.radius + 2}, obs)) { collided = true; break; } } }
                    if (!collided) { bestAngle = testAngle; foundPath = true; break; }
                }
                if (shouldMove && foundPath && !isNaN(bestAngle)) { this.x += Math.cos(bestAngle) * this.speed; this.y += Math.sin(bestAngle) * this.speed; }
                for (let obs of obstacles) {
                    if (checkCircleRect({x: this.x, y: this.y, radius: this.radius}, obs)) {
                        const anglePush = Math.atan2(this.y - (obs.y + obs.height/2), this.x - (obs.x + obs.width/2));
                        if(!isNaN(anglePush)) { this.x += Math.cos(anglePush) * 2; this.y += Math.sin(anglePush) * 2; }
                    }
                }
                this.x = Math.max(0, Math.min(WORLD_WIDTH, this.x)); this.y = Math.max(0, Math.min(WORLD_HEIGHT, this.y)); this.validatePosition();
            }
            shoot(angle) {
                if(isNaN(angle)) return;
                const bullet = new Bullet(this.x, this.y, angle, 'NORMAL', BULLET_TYPES.NORMAL, 'PLAYER');
                bullet.skillSource = 'CLONE'; bullet.skillKey = 'clone';
                bullet.config = { ...BULLET_TYPES.NORMAL, color: '#81D4FA' }; 
                Game.projectiles.push(bullet);
                createMuzzleFlash(this.x, this.y, this.angle, '#81D4FA');
            }
            takeDamage(amount) {
                const alv = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv|0) : 0;
                const reduction = Math.min(0.60, alv * 0.05); // cap 60% ƒë·ªÉ kh√¥ng qu√° OP
                const finalAmount = Math.max(1, Math.round(amount * (1 - reduction)));

                this.hp -= finalAmount;
                // (Phase 10.2) Clone HP should not update player HUD
createDamageText(this.x, this.y - 20, `-${finalAmount}`, COLORS.clone);

                if (this.hp <= 0) { this.markedForDeletion = true; createComplexExplosion(this.x, this.y, COLORS.clone); }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); 
                // Scale visuals by radius (supports Siege Mode size)
                const __baseR = (this.baseRadius || 22);
                const __scale = (__baseR > 0) ? (this.radius / __baseR) : 1;
                if (!isNaN(__scale) && __scale !== 1) ctx.scale(__scale, __scale);

ctx.globalAlpha = 0.7; ctx.strokeStyle = COLORS.clone; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = '#222'; ctx.fillRect(-22, -22, 44, 44); ctx.fillStyle = COLORS.clone; ctx.fillRect(-22, -22, 44, 44);
                ctx.rotate(this.angle); ctx.fillStyle = COLORS.cloneTurret; ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.fill(); ctx.fillRect(0, -6, 40, 12); ctx.restore();
            }
        }


        class Turret extends GameObject {
            constructor(x, y, cfg = {}) {
                super(x, y, 18);
                const now = Date.now();
                this.spawnTime = now;
                this.endTime = now + (cfg.duration || 10000);
                this.range = cfg.range || 650;
                this.fireInterval = cfg.fireRate || 320;
                this.lastShot = 0;
                this.color = cfg.color || '#81C784';
                this.bulletColor = cfg.bulletColor || '#66BB6A';
                this.bulletDmgMult = (typeof cfg.bulletDmgMult === 'number') ? cfg.bulletDmgMult : 0.65;
                this.angle = 0;
            }

            update(obstacles) {
                const now = Date.now();
                if (now > this.endTime) {
                    this.markedForDeletion = true;
                    return;
                }

                // Aim nearest enemy in range (line-of-sight preferred)
                let target = null;
                let minDst = this.range;
                const obs = obstacles || Game.obstacles;

                for (const e of Game.enemies) {
                    if (!e || e.markedForDeletion || e.hp <= 0) continue;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDst) {
                        if (!isLineBlocked(this.x, this.y, e.x, e.y, obs)) {
                            minDst = d;
                            target = e;
                        }
                    }
                }

                if (target) {
                    const ang = Math.atan2(target.y - this.y, target.x - this.x);
                    if (!isNaN(ang)) this.angle = ang;

                    if (now - this.lastShot >= this.fireInterval) {
                        this.shoot(this.angle);
                        this.lastShot = now;
                    }
                }
            }

            shoot(angle) {
                if (isNaN(angle)) return;
                const base = (BULLET_TYPES && BULLET_TYPES.NORMAL) ? BULLET_TYPES.NORMAL : { damage: 10, speed: 12, radius: 5, color: '#fff' };
                const cfg = { ...base, color: this.bulletColor };
                cfg.damage = Math.max(1, Math.round((cfg.damage || 10) * this.bulletDmgMult));

                const bullet = new Bullet(this.x, this.y, angle, 'NORMAL', cfg, 'PLAYER');
                Game.projectiles.push(bullet);
                createMuzzleFlash(this.x, this.y, angle, this.bulletColor);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // lifetime ring
                const now = Date.now();
                const total = Math.max(1, (this.endTime - this.spawnTime));
                const remain = Math.max(0, this.endTime - now);
                const pct = Math.max(0, Math.min(1, remain / total));
                ctx.strokeStyle = 'rgba(102, 187, 106, 0.95)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 14, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * pct);
                ctx.stroke();

                // base
                ctx.fillStyle = 'rgba(0,0,0,0.65)';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 3, 0, Math.PI * 2);
                ctx.fill();

                // barrel
                ctx.rotate(this.angle);
                ctx.fillStyle = '#263238';
                ctx.fillRect(0, -6, 42, 12);
                ctx.fillStyle = this.bulletColor;
                ctx.fillRect(0, -4, 34, 8);

                ctx.restore();
            }
        }

        class Enemy extends GameObject {
            constructor(x, y, typeKey, hpMultiplier = 1, dmgMultiplier = 1, speedMultiplier = 1, fireRateMultiplier = 1) {
                const config = ENEMY_TYPES[typeKey]; let radius = config.radius; if(typeKey === 'BOSS') radius = 70;
                super(x, y, radius); this.id = Math.random().toString(36).substr(2, 9); this.typeKey = typeKey; this.config = config; this.dmgMult = dmgMultiplier; this.speedMult = speedMultiplier; this.fireRateMult = fireRateMultiplier; this.contactDamage = Math.min(25, Math.round(5 * this.dmgMult)); this.maxHp = config.maxHp * hpMultiplier; this.hp = this.maxHp; this.angle = 0; this.effects = { stun: { active: false, endTime: 0 }, burn: { active: false, endTime: 0, nextTick: 0, damage: 0 }, slow: { active: false, endTime: 0, factor: 1 } }; this.lastShot = 0; this.bossState = 0; this.bossTimer = 0;
            }
            applyEffect(effectConfig) {
                if (this.typeKey === 'BOSS' && effectConfig.type === 'STUN') return; 
                const now = Date.now();
                if (effectConfig.type === 'STUN') { this.effects.stun.active = true; this.effects.stun.endTime = now + effectConfig.duration; } 
                else if (effectConfig.type === 'SLOW') {
                        const dur = (typeof effectConfig.duration === 'number') ? effectConfig.duration : 700;
                        const factor = (typeof effectConfig.factor === 'number') ? effectConfig.factor : 0.5;
                        if (!this.effects.slow) this.effects.slow = { active: false, endTime: 0, factor: 1 };
                        this.effects.slow.active = true;
                        this.effects.slow.endTime = Math.max(this.effects.slow.endTime || 0, now + dur);
                        // L·∫•y slow m·∫°nh nh·∫•t (factor nh·ªè h∆°n)
                        this.effects.slow.factor = Math.min(this.effects.slow.factor || 1, Math.max(0.15, Math.min(1, factor)));
                    }
                    else if (effectConfig.type === 'BURN') { this.effects.burn.active = true; this.effects.burn.endTime = now + effectConfig.duration; this.effects.burn.nextTick = now + effectConfig.tickInterval; this.effects.burn.damage = effectConfig.tickDamage; }
            }
            update(player, clones, obstacles) {
                const now = Date.now();
                if (this.effects.stun.active && now <= this.effects.stun.endTime) return;
                if (this.effects.burn.active) {
                    if (now > this.effects.burn.endTime) this.effects.burn.active = false;
                    else if (now >= this.effects.burn.nextTick) { this.hp -= this.effects.burn.damage; this.effects.burn.nextTick = now + 500; createDamageText(this.x, this.y - 10, this.effects.burn.damage, '#FF5722'); }
                }

                let targets = [];
                const _playersArr = Array.isArray(player) ? player : (player ? [player] : []);
                for (let _i = 0; _i < _playersArr.length; _i++) {
                    const _p = _playersArr[_i];
                    if (!_p) continue;
                    // B·ªè qua ng∆∞·ªùi ƒë√£ ch·∫øt (hp <= 0) v√† ng∆∞·ªùi ƒëang t√†ng h√¨nh
                    if (typeof _p.hp === 'number' && _p.hp <= 0) continue;
                    if (_p.isStealth) continue;
                    targets.push(_p);
                }
                if (clones && clones.length) targets = targets.concat(clones);
                let target = null; if (targets.length > 0) { let minDst = Infinity; targets.forEach(t => { const d = Math.hypot(t.x - this.x, t.y - this.y); if(d < minDst) { minDst = d; target = t; } }); }
                if (!target) { this.x += Math.cos(now/1000) * 1; this.y += Math.sin(now/1000) * 1; this.validatePosition(); return; }

                const dx = target.x - this.x; const dy = target.y - this.y; const dist = Math.hypot(dx, dy); let desiredAngle = Math.atan2(dy, dx); let moveSpeed = this.config.speed * this.speedMult;

                    if (this.effects.slow && this.effects.slow.active) {
                        if (now <= this.effects.slow.endTime) moveSpeed *= (this.effects.slow.factor || 0.5);
                        else this.effects.slow.active = false;
                    }
                if (this.typeKey === 'BOSS') {
                    const hpBar = document.getElementById('bossHealthBar'); const hpContainer = document.getElementById('bossHealthContainer'); if (hpContainer.style.display !== 'block') hpContainer.style.display = 'block'; hpBar.style.width = `${(this.hp / this.maxHp) * 100}%`;
                    // --- BOSS SKILLS (H√∫c / B·∫Øn v√≤ng tr√≤n / M√¨n / G·ªçi l√≠nh) ---
                    if (!this.bossAI) {
                        this.bossAI = {
                            state: 'idle',
                            stateEnd: 0,
                            chargeDir: 0,
                            chargeVx: 0,
                            chargeVy: 0,
                            nextCharge: now + 2600,
                            nextRadial: now + 3400,
                            nextMines: now + 5200,
                            nextSummon: now + 7800
                        };
                        this._lastBossUpdate = now;
                    }
                    const ai = this.bossAI;

                    const dtBoss = Math.max(0.5, Math.min(2.0, (now - (this._lastBossUpdate || now)) / 16.666));
                    this._lastBossUpdate = now;

                    const hpPct = this.maxHp > 0 ? (this.hp / this.maxHp) : 1;

                    // Boss phase: d∆∞·ªõi 25% m√°u s·∫Ω CU·ªíNG N·ªò. M·ª©c cu·ªìng n·ªô tƒÉng theo m√†n (wave).
                    const waveNow = (typeof WaveManager !== 'undefined' && WaveManager.wave) ? (WaveManager.wave | 0) : 1;
                    const enrageLvl = Math.max(0, Math.min(1, (waveNow - 1) / 15)); // 0..1 (m√†n c√†ng cao c√†ng ƒëi√™n)
                    const shouldEnrage = (hpPct <= 0.25);
                    if (shouldEnrage && !ai.enraged) {
                        ai.enraged = true;
                        createComplexExplosion(this.x, this.y, "#FF1744");
                        createDamageText(this.x, this.y - 80, "CU·ªíNG N·ªò!", "#FF1744");
                    }
                    if (!shouldEnrage) ai.enraged = false;

                    const enrageCdMult = ai.enraged ? Math.max(0.55, 0.85 - 0.25 * enrageLvl) : 1;   // gi·∫£m h·ªìi chi√™u
                    const enrageShootMult = ai.enraged ? (1.15 + 0.45 * enrageLvl) : 1;                // b·∫Øn nhanh h∆°n
                    const enrageMoveMult = ai.enraged ? (1.10 + 0.20 * enrageLvl) : 1;                 // ch·∫°y nhanh h∆°n


                    // Tuning di chuy·ªÉn boss (ƒë·ªÉ kh√¥ng d√≠nh ng∆∞·ªùi ch∆°i qu√° g·∫Øt)
                    moveSpeed = (dist > 320 ? 1.35 : 0.55) * this.speedMult * enrageMoveMult;

                    // --- Resolve casting / state ---
                    if (ai.state === 'charge_windup') {
                        moveSpeed = 0;
                        this.angle = ai.chargeDir;
                        if (now >= ai.stateEnd) {
                            ai.state = 'charge';
                            ai.stateEnd = now + 900;
                            const spd = (10.5 + (hpPct < 0.5 ? 1.5 : 0) + (ai.enraged ? (1.8 + 2.2 * enrageLvl) : 0)) * this.speedMult;
                            ai.chargeVx = Math.cos(ai.chargeDir) * spd;
                            ai.chargeVy = Math.sin(ai.chargeDir) * spd;
                            this.contactDamage = Math.round(18 * this.dmgMult * (ai.enraged ? (1.15 + 0.35 * enrageLvl) : 1));
                        }
                    } else if (ai.state === 'charge') {
                        // Dash theo th·ªùi gian (·ªïn ƒë·ªãnh 60/120fps)
                        this.x += ai.chargeVx * dtBoss;
                        this.y += ai.chargeVy * dtBoss;
                        moveSpeed = 0;
                        this.angle = ai.chargeDir;
                        this.contactDamage = Math.round(18 * this.dmgMult * (ai.enraged ? (1.15 + 0.35 * enrageLvl) : 1));
                        if (now >= ai.stateEnd) {
                            ai.state = 'idle';
                            this.contactDamage = Math.round(10 * this.dmgMult * (ai.enraged ? (1.10 + 0.30 * enrageLvl) : 1));
                        }
                    } else if (ai.state === 'radial_windup') {
                        moveSpeed *= 0.35;
                        if (now >= ai.stateEnd) {
                            const count = (hpPct < 0.5 ? 26 : 20) + (ai.enraged ? (4 + Math.round(4 * enrageLvl)) : 0);
                            for (let i = 0; i < count; i++) {
                                const ang = (i / count) * Math.PI * 2;
                                this.shoot(ang, 'FAST');
                            }
                            createDamageText(this.x, this.y - 70, "B·∫ÆN V√íNG TR√íN!", "#FF1744");
                            ai.state = 'idle';
                        }
                    } else if (ai.state === 'summon_cast') {
                        moveSpeed *= 0.25;
                        if (now >= ai.stateEnd) {
                            const cnt = (hpPct < 0.5 ? 5 : 4) + (ai.enraged ? (2 + Math.round(1 * enrageLvl)) : 0);
                            const types = ['RED','RED','RED','BLACK','YELLOW','PURPLE'];
                            const sc = (typeof WaveManager !== 'undefined' && WaveManager.scaling) ? WaveManager.scaling
                                      : ((typeof WaveManager !== 'undefined' && typeof WaveManager.computeScaling === 'function') ? WaveManager.computeScaling() : null);

                            for (let i = 0; i < cnt; i++) {
                                const ang = Math.random() * Math.PI * 2;
                                const r = 120 + Math.random() * 80;
                                let sx = this.x + Math.cos(ang) * r;
                                let sy = this.y + Math.sin(ang) * r;
                                sx = Math.max(80, Math.min(WORLD_WIDTH - 80, sx));
                                sy = Math.max(80, Math.min(WORLD_HEIGHT - 80, sy));
                                const tk = types[Math.floor(Math.random() * types.length)];

                                const hpM = sc ? sc.hpMult : 1;
                                const dmgM = sc ? sc.dmgMult : 1;
                                const spdM = sc ? sc.speedMult : 1;
                                const frM  = sc ? sc.fireRateMult : 1;

                                Game.enemies.push(new Enemy(sx, sy, tk, hpM, dmgM, spdM, frM));
                            }
                            createComplexExplosion(this.x, this.y, "#FF1744");
                            createDamageText(this.x, this.y - 70, "G·ªåI L√çNH!", "#FF1744");
                            ai.state = 'idle';
                        }
                    }

                    // --- Trigger new abilities (idle only) ---
                    if (ai.state === 'idle') {
                        this.contactDamage = Math.round(10 * this.dmgMult);

                        const options = [];
                        if (now >= ai.nextCharge && dist < 520) options.push('charge');
                        if (now >= ai.nextRadial) options.push('radial');
                        if (now >= ai.nextMines) options.push('mines');
                        if (now >= ai.nextSummon) options.push('summon');

                        if (options.length > 0) {
                            const pick = options[Math.floor(Math.random() * options.length)];

                            if (pick === 'charge') {
                                ai.state = 'charge_windup';
                                ai.chargeDir = desiredAngle;
                                ai.stateEnd = now + 600;
                                ai.nextCharge = now + (hpPct < 0.5 ? 6500 : 7800) * enrageCdMult;
                                createDamageText(this.x, this.y - 70, "CHU·∫®N B·ªä H√öC!", "#FF1744");
                            } else if (pick === 'radial') {
                                ai.state = 'radial_windup';
                                ai.stateEnd = now + 550;
                                ai.nextRadial = now + (hpPct < 0.5 ? 6000 : 7200) * enrageCdMult;
                            } else if (pick === 'mines') {
                                const mineCount = (hpPct < 0.5 ? 10 : 8) + (ai.enraged ? (3 + Math.round(3 * enrageLvl)) : 0);
                                const mineRadius = 80;
                                const delay = ai.enraged ? Math.max(900, 1300 - Math.round(250 * enrageLvl)) : 1500;
                                const dmgBase = (18 + (hpPct < 0.5 ? 4 : 0));
                                const dmg = Math.round(dmgBase * this.dmgMult * (ai.enraged ? (1.2 + 0.3 * enrageLvl) : 1));

                                if (!Game.bossMines) Game.bossMines = [];
                                for (let i = 0; i < mineCount; i++) {
                                    const ang = (i / mineCount) * Math.PI * 2 + Math.random() * 0.25;
                                    const r = 110 + Math.random() * 90;
                                    let mx = this.x + Math.cos(ang) * r;
                                    let my = this.y + Math.sin(ang) * r;
                                    mx = Math.max(60, Math.min(WORLD_WIDTH - 60, mx));
                                    my = Math.max(60, Math.min(WORLD_HEIGHT - 60, my));
                                    Game.bossMines.push({ x: mx, y: my, radius: mineRadius, spawnAt: now, detonateAt: now + delay, delay: delay, damage: dmg });
                                }
                                createDamageText(this.x, this.y - 70, "TH·∫¢ M√åN!", "#FF9800");
                                ai.nextMines = now + (hpPct < 0.5 ? 8000 : 9800) * enrageCdMult;
                            } else if (pick === 'summon') {
                                ai.state = 'summon_cast';
                                ai.stateEnd = now + 650;
                                ai.nextSummon = now + (hpPct < 0.5 ? 11000 : 13500) * enrageCdMult;
                                createDamageText(this.x, this.y - 70, "G·ªåI L√çNH!", "#FF1744");
                            }
                        }
                    }

                    // --- Baseline shooting (disable while charging/windup casts) ---
                    const canShoot = (ai.state === 'idle');
                    if (canShoot && now - this.lastShot > (this.config.fireRate / (this.fireRateMult * enrageShootMult))) { 
                        this.shoot(desiredAngle, 'FAST');
                        this.lastShot = now;
                    }
                } else {
                    if (this.config.behavior === 'ORBIT' && dist < 250) desiredAngle += Math.PI / 2;
                    else if (this.config.behavior === 'SNIPER') { if (dist < 400) desiredAngle += Math.PI; else if (dist < 450) moveSpeed = 0; }
                    const fr = (this.config.fireRate / this.fireRateMult); if (this.config.fireRate && now - this.lastShot > fr) { if (dist < 800 && !isLineBlocked(this.x, this.y, target.x, target.y, obstacles)) { this.shoot(desiredAngle, 'NORMAL'); this.lastShot = now; } }
                }

                let bestAngle = desiredAngle; let foundPath = false;
                const checkAngles = [0, 20, -20, 45, -45, 65, -65, 90, -90, 110, -110, 135, -135, 160, -160, 180];
                for (let offset of checkAngles) {
                    const testAngle = desiredAngle + (offset * Math.PI) / 180; if(isNaN(testAngle)) continue;
                    const lookAhead = Math.max(this.radius * 1.5, (this.config.speed * this.speedMult) * 5); const nextX = this.x + Math.cos(testAngle) * lookAhead; const nextY = this.y + Math.sin(testAngle) * lookAhead;
                    let collided = false;
                    if (nextX < this.radius || nextX > WORLD_WIDTH - this.radius || nextY < this.radius || nextY > WORLD_HEIGHT - this.radius) collided = true;
                    if (!collided) { if (this.typeKey !== 'BOSS') { for (let obs of obstacles) { if (checkCircleRect({x: nextX, y: nextY, radius: this.radius + 5}, obs)) { collided = true; break; } } } }
                    if (!collided) { bestAngle = testAngle; foundPath = true; break; }
                }

                if (moveSpeed > 0 && (foundPath || this.typeKey === 'BOSS') && !isNaN(bestAngle)) { this.x += Math.cos(bestAngle) * moveSpeed; this.y += Math.sin(bestAngle) * moveSpeed; this.angle = bestAngle; } else { this.angle = Math.atan2(dy, dx); }

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let obs = obstacles[i];
                    if (checkCircleRect({x: this.x, y: this.y, radius: this.radius}, obs)) {
                        if (this.typeKey === 'BOSS') { obstacles.splice(i, 1); createComplexExplosion(obs.x + obs.width/2, obs.y + obs.height/2, '#546E7A'); createDamageText(this.x, this.y - 50, "CRUSH!", "#D50000"); } 
                        else { const anglePush = Math.atan2(this.y - (obs.y + obs.height/2), this.x - (obs.x + obs.width/2)); if(!isNaN(anglePush)) { this.x += Math.cos(anglePush) * 2; this.y += Math.sin(anglePush) * 2; } }
                    }
                }
                this.x = Math.max(0, Math.min(WORLD_WIDTH, this.x)); this.y = Math.max(0, Math.min(WORLD_HEIGHT, this.y)); this.validatePosition();
            }
            shoot(angle, mode) {
                if(isNaN(angle)) return;
                let speed = this.config.bulletSpeed; let dmg = this.config.bulletDmg; let color = this.typeKey === 'YELLOW' ? '#FFF59D' : '#E040FB';
                if (this.typeKey === 'BOSS') { color = '#FF1744'; if (mode === 'HEAVY') { dmg = 40; } if (mode === 'FAST') { speed = 12; } } dmg = Math.round(dmg * this.dmgMult);
                const bulletConfig = { damage: dmg, speed: speed, color: color, radius: 6 };
                const bullet = new Bullet(this.x, this.y, angle, 'NORMAL', bulletConfig, 'ENEMY');
                bullet.sourceEnemy = this;
                if (mode === 'HEAVY') bullet.radius = 10;
                Game.projectiles.push(bullet);
                createMuzzleFlash(this.x, this.y, angle, color);
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); if (this.effects.stun.active) { ctx.strokeStyle = '#00BCD4'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, Math.PI*2); ctx.stroke(); }
                ctx.rotate(this.angle);
                ctx.fillStyle = this.config.color; if (this.config.outline) { ctx.strokeStyle = this.config.outline; ctx.lineWidth = 3; ctx.strokeRect(-this.radius, -this.radius, this.radius*2, this.radius*2); }
                ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                if (this.typeKey === 'BOSS') { ctx.fillStyle = '#B71C1C'; ctx.fillRect(-20, -20, 40, 40); ctx.strokeStyle = '#FFEB3B'; ctx.strokeRect(-this.radius, -this.radius, this.radius*2, this.radius*2); }
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, -5, this.radius + 5, 10); ctx.restore();
                // Boss telegraphs (d·ªÖ n√© - d·ªÖ ƒë·ªçc)
                if (this.typeKey === 'BOSS' && this.bossAI) {
                    const now2 = Date.now();
                    const ai = this.bossAI;

                    if (ai.enraged) {
                        // Aura cu·ªìng n·ªô (nh√¨n ph√°t bi·∫øt ngay)
                        const pulse = 0.5 + 0.5 * Math.sin(now2 / 80);
                        ctx.save();
                        ctx.strokeStyle = 'rgba(255,23,68,0.65)';
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 10 + pulse * 6, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }


                    if (ai.state === 'charge_windup') {
                        ctx.save();
                        ctx.strokeStyle = 'rgba(255,23,68,0.9)';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x + Math.cos(ai.chargeDir) * 280, this.y + Math.sin(ai.chargeDir) * 280);
                        ctx.stroke();
                        ctx.restore();
                    }

                    if (ai.state === 'radial_windup') {
                        ctx.save();
                        const t = Math.max(0, Math.min(1, (ai.stateEnd - now2) / 550));
                        const r = 110 + (1 - t) * 50;
                        ctx.strokeStyle = 'rgba(255,23,68,0.75)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    if (ai.state === 'summon_cast') {
                        ctx.save();
                        const t = Math.max(0, Math.min(1, (ai.stateEnd - now2) / 650));
                        const r = 90 + (1 - t) * 70;
                        ctx.strokeStyle = 'rgba(255,235,59,0.75)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([8, 8]);
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                }
                if (this.typeKey !== 'BOSS') { const hpPercent = this.hp / this.maxHp; ctx.fillStyle = 'red'; ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30, 4); ctx.fillStyle = '#0f0'; ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30 * hpPercent, 4); }
            }
        }

        class Player extends GameObject {
            constructor(systemId = 'default') {
                super(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, 22);
                this.systemId = systemId || 'default';
                // System base stats (baseline for upgrades/save)
                const STATS = {
                    default:    { hp: 100, spd: 6.5, armor: 0,    cdMult: 1.0,  rad: 22 },
                    speed:      { hp: 85,  spd: 8.2, armor: 0,    cdMult: 0.85, rad: 22 },
                    engineer:   { hp: 120, spd: 6.0, armor: 0.05, cdMult: 1.0,  rad: 22 },
                    juggernaut: { hp: 160, spd: 5.0, armor: 0.15, cdMult: 1.10, rad: 24 },
                    mage:       { hp: 70,  spd: 6.2, armor: 0,    cdMult: 1.0,  rad: 19 }
                };
                const s = STATS[this.systemId] || STATS.default;
                this.__baseMaxHp = s.hp; // used by upgrade rebase
                this.baseMaxHp = s.hp;   // compatibility
                this.maxHp = s.hp; this.hp = this.maxHp;
                this.baseSpeed = s.spd; this.speed = this.baseSpeed;
                this.baseRadius = s.rad; this.radius = this.baseRadius;
                this.innateArmor = s.armor;
                this.innateCdMult = s.cdMult;
                this.angle = 0; this.inventory = [{ id: 'NORMAL', level: 1 }]; this.currentWeaponIndex = 0; this.ultiCharge = 0; 
                this.buffs = { shield: { active: false, endTime: 0 }, juggerShield: { active: false, endTime: 0 }, rapid: { active: false, endTime: 0 }, phase: { active: false, endTime: 0 }, adrenaline: { active: false, endTime: 0, speedMult: 1.25, fireMult: 0.85, damageMult: 1.3 } , siege: { active: false, endTime: 0, speedMult: 0.3, fireMult: 0.5, sizeMult: 1.35, armorBase: 0.35, armorMult: 3 }};
                this.skills = { clone: { lastUsed: 0, active: false }, stealth: { lastUsed: 0, active: false, endTime: 0 }, vampirism: { lastUsed: 0, active: false, endTime: 0 } };
                this.vampHeal = { windowStart: 0, healed: 0 };
                this.dash = { active: false, endTime: 0, vx: 0, vy: 0 };
                this.ram = { active: false, endTime: 0, vx: 0, vy: 0, hitSet: new Set() };
                this.isStealth = false; this.lastShot = 0;

                // Mage state
                this.mage = { blizzard: { active: false, x: 0, y: 0, endTime: 0, nextTick: 0, locked: false } };

                // System base stats are applied via STATS table above.
            }
            activateCheat() { this.inventory = [{ id: 'NORMAL', level: 5 }, { id: 'STUN', level: 5 }, { id: 'LIGHTNING', level: 5 }, { id: 'FIRE', level: 5 }, { id: 'PIERCING', level: 5 }, { id: 'HOMING', level: 5 }]; if (this.currentWeaponIndex >= this.inventory.length) { this.currentWeaponIndex = 0; } this.ultiCharge = 100; createDamageText(this.x, this.y - 60, "CHEAT ACTIVATED!", "#FFD700"); Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex); }
            addWeapon(weaponId) {
                const existingIndex = this.inventory.findIndex(w => w.id === weaponId);
                if (existingIndex !== -1) { if (this.inventory[existingIndex].level < 5) { this.inventory[existingIndex].level++; createDamageText(this.x, this.y - 40, `UPGRADE! LVL ${this.inventory[existingIndex].level}`, "#FFD700"); if (this.currentWeaponIndex === existingIndex) { Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex); } } else { createDamageText(this.x, this.y - 40, "MAX LEVEL!", "#fff"); } } 
                else { if (this.inventory.length >= 6) { createDamageText(this.x, this.y - 40, "FULL!", "#ff4444"); } else { this.inventory.push({ id: weaponId, level: 1 }); createDamageText(this.x, this.y - 40, "NEW WEAPON!", "#fff"); this.selectWeapon(this.inventory.length - 1); } }
                Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
            }
            selectWeapon(index) { if (index >= 0 && index < this.inventory.length) this.currentWeaponIndex = index; else this.currentWeaponIndex = 0; Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex); }
            loseCurrentWeapon() {
                // Hit penalty (easier + logical):
                // - NORMAL: gi·∫£m 1 c·∫•p (min = 1, kh√¥ng th·ªÉ 'm·∫•t' h·∫≥n)
                // - Special: n·∫øu Lv>1 => gi·∫£m 1 c·∫•p; n·∫øu Lv=1 => m·∫•t v≈© kh√≠ ƒë√≥ v√† CHUY·ªÇN QUA NORMAL (gi·ªØ level NORMAL hi·ªán t·∫°i)

                if (!this.inventory || this.inventory.length === 0) {
                    this.inventory = [{ id: 'NORMAL', level: 1 }];
                    this.currentWeaponIndex = 0;
                    Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
                    return;
                }

                // ƒë·∫£m b·∫£o NORMAL lu√¥n t·ªìn t·∫°i ·ªü slot 0
                if (!this.inventory[0] || this.inventory[0].id !== 'NORMAL') {
                    this.inventory.unshift({ id: 'NORMAL', level: 1 });
                    if (typeof this.currentWeaponIndex === 'number') this.currentWeaponIndex += 1;
                }

                if (this.currentWeaponIndex == null || this.currentWeaponIndex < 0 || this.currentWeaponIndex >= this.inventory.length) {
                    this.currentWeaponIndex = 0;
                }

                const currentWep = this.inventory[this.currentWeaponIndex];
                if (!currentWep) {
                    this.currentWeaponIndex = 0;
                    Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
                    return;
                }

                // NORMAL: v·∫´n b·ªã gi·∫£m c·∫•p khi tr√∫ng ƒë·∫°n, nh∆∞ng kh√¥ng xu·ªëng d∆∞·ªõi 1
                if (currentWep.id === 'NORMAL') {
                    const lv = (currentWep.level | 0) || 1;
                    if (lv > 1) {
                        currentWep.level = lv - 1;
                        createDamageText(this.x, this.y - 60, "GI·∫¢M 1 C·∫§P!", "#ff4444");
                    } else {
                        currentWep.level = 1;
                    }
                    Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
                    return;
                }

                // Special weapons
                const lv = (currentWep.level | 0) || 1;
                if (lv > 1) {
                    currentWep.level = lv - 1;
                    createDamageText(this.x, this.y - 60, "GI·∫¢M 1 C·∫§P!", "#ff4444");
                } else {
                    // Lv 1: m·∫•t v≈© kh√≠ ƒë·∫∑c bi·ªát v√† CHUY·ªÇN QUA NORMAL (slot 0 gi·ªØ nguy√™n level)
                    this.inventory.splice(this.currentWeaponIndex, 1);
                    this.currentWeaponIndex = 0;
                    createDamageText(this.x, this.y - 60, "M·∫§T V≈® KH√ç!", "#ff4444");
                }

                Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
            }
            getCurrentWeaponObj() { if (this.currentWeaponIndex === -1 || !this.inventory[this.currentWeaponIndex]) return { id: 'NORMAL', level: 1 }; return this.inventory[this.currentWeaponIndex]; }
            useSkill(skillName) {
                const now = Date.now();
                const config = getSystemSkillDef(this.systemId, skillName);
                const skillState = this.skills[skillName];
                if (!skillState || !config) return;

                // Cooldown gate
                if (now - skillState.lastUsed < (config.cooldown || 0)) return;

                // Speed system: 3 skills th·∫≠t
                if (this.systemId === 'speed') {
                    skillState.lastUsed = now;

                    if (skillName === 'clone') {
                        // DASH: l∆∞·ªõt nhanh theo h∆∞·ªõng ƒëang di chuy·ªÉn (ho·∫∑c h∆∞·ªõng n√≤ng s√∫ng n·∫øu ƒë·ª©ng y√™n)
                        let dx = 0, dy = 0;
                        if (Input.keys.w) dy -= 1; if (Input.keys.s) dy += 1; if (Input.keys.a) dx -= 1; if (Input.keys.d) dx += 1;
                        if (dx === 0 && dy === 0) { dx = Math.cos(this.angle); dy = Math.sin(this.angle); }
                        const len = Math.hypot(dx, dy) || 1;
                        dx /= len; dy /= len;

                        const dur = config.duration || 250;
                        const dashSpeed = (this.baseSpeed || this.speed || 6.5) * (config.dashSpeedMult || 3.2);

                        this.dash.active = true;
                        this.dash.endTime = now + dur;
                        this.dash.vx = dx * dashSpeed;
                        this.dash.vy = dy * dashSpeed;

                        createDamageText(this.x, this.y - 40, 'DASH!', config.color || '#4FC3F7');
                        return;
                    }

                    if (skillName === 'stealth') {
                        // PHASE: mi·ªÖn th∆∞∆°ng ng·∫Øn
                        const dur = config.duration || 800;
                        this.buffs.phase.active = true;
                        this.buffs.phase.endTime = now + dur;
                        Game.ui.removeBuff('Phase');
                        Game.ui.addBuff('Phase', config.color || '#81D4FA');
                        createDamageText(this.x, this.y - 40, 'PHASE!', config.color || '#81D4FA');
                        return;
                    }

                    if (skillName === 'vampirism') {
                        // ADRENALINE: tƒÉng t·ªëc ch·∫°y + tƒÉng t·ªëc b·∫Øn t·∫°m th·ªùi
                        const dur = config.duration || 4000;
                        this.buffs.adrenaline.active = true;
                        this.buffs.adrenaline.endTime = now + dur;
                        this.buffs.adrenaline.speedMult = config.speedMult || 1.25;
                        this.buffs.adrenaline.fireMult = (config.fireMult != null) ? config.fireMult : 0.5;
                        this.buffs.adrenaline.damageMult = config.damageMult || 1.3;
                        Game.ui.removeBuff('Adren');
                        Game.ui.addBuff('Adren', config.color || '#29B6F6');
                        createDamageText(this.x, this.y - 40, 'ADREN!', config.color || '#29B6F6');
                        return;
                    }
                }

                // Engineer system: 3 skills th·∫≠t
                if (this.systemId === 'engineer') {
                    skillState.lastUsed = now;

                    if (skillName === 'clone') {
                        // TURRET: ƒë·∫∑t th√°p t·ª± b·∫Øn
                        if (!Game.turrets) Game.turrets = [];
                        const maxT = config.maxTurrets || 1;

                        // N·∫øu ƒë√£ ƒë·ªß s·ªë l∆∞·ª£ng -> thay th·∫ø turret c≈© nh·∫•t
                        if (Game.turrets.length >= maxT) {
                            const old = Game.turrets.shift();
                            if (old) { old.markedForDeletion = true; createComplexExplosion(old.x, old.y, config.color || '#81C784'); }
                            createDamageText(this.x, this.y - 60, 'THAY TH·∫æ!', '#ccc');
                        }

                        // T√¨m v·ªã tr√≠ ƒë·∫∑t kh√¥ng k·∫πt v·∫≠t c·∫£n
                        const off = 55;
                        const candidates = [
                            { x: this.x + Math.cos(this.angle) * off, y: this.y + Math.sin(this.angle) * off },
                            { x: this.x - Math.cos(this.angle) * off, y: this.y - Math.sin(this.angle) * off },
                            { x: this.x + off, y: this.y },
                            { x: this.x - off, y: this.y },
                            { x: this.x, y: this.y + off },
                            { x: this.x, y: this.y - off }
                        ];
                        let pos = candidates[0];
                        outer: for (const c of candidates) {
                            for (const obs of Game.obstacles) {
                                if (checkCircleRect({ x: c.x, y: c.y, radius: 22 }, obs)) continue outer;
                            }
                            pos = c;
                            break;
                        }

                        const turret = new Turret(pos.x, pos.y, {
                            duration: config.duration || 10000,
                            range: config.range || 650,
                            fireRate: config.fireRate || 320,
                            color: config.color || '#81C784',
                            bulletColor: config.bulletColor || '#66BB6A',
                            bulletDmgMult: (typeof config.bulletDmgMult === 'number') ? config.bulletDmgMult : 0.65
                        });
                        Game.turrets.push(turret);
                        createDamageText(this.x, this.y - 40, 'TURRET!', config.color || '#81C784');
                        return;
                    }

                    if (skillName === 'stealth') {
                        // REPAIR: h·ªìi m√°u
                        const healAmt = config.heal || 30;
                        if (typeof this.heal === 'function') this.heal(healAmt);
                        else {
                            this.hp = Math.min(this.maxHp, this.hp + healAmt);
                            const __pidPrevH = Game.__uiPid;
                            try { Game.__uiPid = (this.pid || 1); Game.ui.updateHealth(this.hp, this.maxHp); }
                            finally { Game.__uiPid = __pidPrevH; }
                        }
                        createDamageText(this.x, this.y - 40, 'REPAIR!', config.color || '#A5D6A7');
                        createComplexExplosion(this.x, this.y, '#4CAF50', 10);
                        return;
                    }

                                        if (skillName === 'vampirism') {
                        // EMP: cho√°ng di·ªán r·ªông + l√†m tan ƒë·∫°n ƒë·ªãch + ƒë√≥ng bƒÉng Boss (k√®m s√°t th∆∞∆°ng nh·∫π)
                        const radius = config.radius || 340;
                        const dur = config.stunDuration || 1200;
                        const now2 = Date.now();
                        let hit = 0;
                        let bulletsCleared = 0;
                        let bossFrozen = 0;

                        // 1) L√†m tan ƒë·∫°n ƒë·ªãch ƒëang bay t·ªõi trong ph·∫°m vi xung
                        if (Game.projectiles && Game.projectiles.length) {
                            for (const b of Game.projectiles) {
                                if (!b || b.markedForDeletion) continue;
                                if (b.owner !== 'ENEMY') continue;
                                const dB = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dB <= radius) { b.markedForDeletion = true; bulletsCleared++; }
                            }
                        }

                        // 2) Cho√°ng l√≠nh th∆∞·ªùng, ri√™ng Boss b·ªã 'ƒë√≥ng bƒÉng' + nh·∫≠n s√°t th∆∞∆°ng nh·∫π
                        for (const e of Game.enemies) {
                            if (!e || e.markedForDeletion || e.hp <= 0) continue;
                            const d = Math.hypot(e.x - this.x, e.y - this.y);
                            if (d > radius) continue;
                            if (e.typeKey === 'BOSS') {
                                // Bypass mi·ªÖn nhi·ªÖm STUN: ƒë√≥ng bƒÉng b·∫±ng c√°ch kh√≥a update t·∫°m th·ªùi
                                if (e.effects && e.effects.stun) { e.effects.stun.active = true; e.effects.stun.endTime = now2 + Math.min(dur, 1800); }
                                const base = (typeof e.maxHp === 'number' && e.maxHp > 0) ? e.maxHp : e.hp;
                                const dmgMultSkill = (1 + 0.1 * ((Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0));
                                const baseBossDmg = Math.max(30, Math.round(base * 0.015)); // ~1.5% HP (nh·∫π)
                                const bossDmg = Math.max(1, Math.round(baseBossDmg * dmgMultSkill));
                                e.hp -= bossDmg;
                                createDamageText(e.x, e.y - 10, '-' + bossDmg, '#B3E5FC');
                                createDamageText(e.x, e.y - 32, 'ƒê√ìNG BƒÇNG!', '#00E5FF');
                                createComplexExplosion(e.x, e.y, '#00E5FF', 10);
                                bossFrozen++;
                            } else {
                                e.applyEffect({ type: 'STUN', duration: dur });
                                hit++;
                            }
                        }

                        // shockwave visual
                        Game.particles.push(new Particle(this.x, this.y, { type: 'shockwave', color: '#00E5FF', size: 12, maxRadius: radius, decay: 0.03 }));
                        createDamageText(this.x, this.y - 40, 'EMP! (' + hit + ')', '#00E5FF');
                        if (bulletsCleared > 0) createDamageText(this.x, this.y - 62, 'TAN ƒê·∫†N: ' + bulletsCleared, '#B3E5FC');
                        if (bossFrozen > 0) createDamageText(this.x, this.y - 84, 'BOSS ƒê√ìNG BƒÇNG!', '#00E5FF');
                        Game.shake = Math.max(Game.shake, 14);
                        return;
                    }
                }


                // Juggernaut system: J2 - C√∫ H√∫c (Battering Ram)
                if (this.systemId === 'juggernaut') {
                    skillState.lastUsed = now;

                    // Juggernaut system: J1 - Q Gi√°p Ph·∫£n (Reflective Shield)
                    if (skillName === 'clone') {
                        const dur = (config && config.duration) ? config.duration : 5000;
                        this.buffs.juggerShield.active = true;
                        this.buffs.juggerShield.endTime = now + dur;
                        Game.ui.removeBuff('Gi√°p Ph·∫£n');
                        Game.ui.addBuff('Gi√°p Ph·∫£n', (config && config.color) ? config.color : '#FFD54F');
                        createDamageText(this.x, this.y - 40, 'GI√ÅP PH·∫¢N!', (config && config.color) ? config.color : '#FFD54F');
                        Game.shake = Math.max(Game.shake, 6);
                        return;
                    }

                    if (skillName === 'stealth') {
                        // E ‚Äî C√∫ H√∫c: tƒÉng t·ªëc 1s, ƒë√¢m tr√∫ng g√¢y s√°t th∆∞∆°ng + ƒë·∫©y l√πi
                        let dx = Math.cos(this.angle), dy = Math.sin(this.angle);
                        const len = Math.hypot(dx, dy) || 1;
                        dx /= len; dy /= len;

                        const dur = config.duration || 1000;
                        const mult = config.ramSpeedMult || 3.0; // +200% speed => x3
                        const ramSpeed = (this.baseSpeed || this.speed || 6.5) * mult;

                        if (!this.ram) this.ram = { active: false, endTime: 0, vx: 0, vy: 0, hitSet: new Set() };
                        this.ram.active = true;
                        this.ram.endTime = now + dur;
                        this.ram.vx = dx * ramSpeed;
                        this.ram.vy = dy * ramSpeed;
                        this.ram.hitSet = new Set();

                        createDamageText(this.x, this.y - 40, 'C√ö H√öC!', config.color || '#FFCA28');
                        Game.shake = Math.max(Game.shake, 12);
                        return;
                    }

                    

                    // J3 - R: Ch·∫ø ƒê·ªô Ph√°o ƒê√†i (Siege Mode) => √©p b·∫Øn ROCKET, gi√°p to, b·∫Øn nhanh, ch·∫≠m di chuy·ªÉn
                    if (skillName === 'vampirism') {
                        const dur = (config && config.duration) ? config.duration : 6000;
                        if (!this.buffs.siege) this.buffs.siege = { active: false, endTime: 0, speedMult: 0.3, fireMult: 0.5, sizeMult: 1.35, armorBase: 0.35, armorMult: 3 };
                        this.buffs.siege.active = true;
                        this.buffs.siege.endTime = now + dur;

                        Game.ui.removeBuff('Ph√°o ƒê√†i');
                        Game.ui.addBuff('Ph√°o ƒê√†i', (config && config.color) ? config.color : '#FFEB3B');
                        createDamageText(this.x, this.y - 40, 'PH√ÅO ƒê√ÄI!', (config && config.color) ? config.color : '#FFEB3B');
                        Game.shake = Math.max(Game.shake, 8);
                        return;
                    }
// Q/R (J0 placeholder) gi·ªØ nguy√™n: hi·ªán text th√¥i
                    createDamageText(this.x, this.y - 40, config.castText || 'COMING SOON', config.color || '#FFD700');
                    return;
                }

                
                // Mage system (Ph√°p S∆∞) - realtime, skill-based
                if (this.systemId === 'mage') {
                    const cfg = getSystemSkillDef('mage', skillName) || {};

                    if (skillName === 'clone') { // Q - H·ªèa C·∫ßu
                        const cur = this.inventory[this.currentWeaponIndex] || { id: 'NORMAL', level: 1 };
                        const lv = (cur && cur.level) ? cur.level : 1;

                        const fireballCfg = {
                            speed: (cfg.fireballSpeed != null) ? cfg.fireballSpeed : 4, // ch·∫≠m h∆°n 3 l·∫ßn
                            damage: (((cfg.fireballBase || 60) + lv) * (cfg.fireballDmgMult || 3.2)), // m·∫°nh h∆°n 3 l·∫ßn
                            radius: (cfg.fireballRadius != null) ? cfg.fireballRadius : 36, // to g·∫•p 3
                            color: cfg.color || '#FF5722',
                            special: 'EXPLODE',
                            explosionRadius: (cfg.explosionRadius != null) ? cfg.explosionRadius : 320,
                            splashFactor: (cfg.splashFactor != null) ? cfg.splashFactor : 1.0, // d√πng cho AOE
                            noTrail: true,
                            noDirectHit: true,      // damage t√≠nh theo AOE falloff (k·ªÉ c·∫£ m·ª•c ti√™u tr√∫ng)
                            shockwave: true,
                            shockColor: '#FF6D00'
                        };

                        const tipX = this.x + Math.cos(this.angle) * (this.radius + 14);
                        const tipY = this.y + Math.sin(this.angle) * (this.radius + 14);
                        Game.projectiles.push(new Bullet(tipX, tipY, this.angle, 'FIREBALL', fireballCfg, 'PLAYER'));
                        createMuzzleFlash(tipX, tipY, this.angle, fireballCfg.color);
                        Game.shake = Math.max(Game.shake, 2);

                        createDamageText(this.x, this.y - 40, cfg.castText || 'Q: H·ªéA C·∫¶U', cfg.color || '#FF5722');
                        this.skills[skillName].lastUsed = now;
                        return;
                    }

                    if (skillName === 'stealth') { // E - D·ªãch Chuy·ªÉn (Blink): Hard=chu·ªôt, Easy/2P=theo h∆∞·ªõng di chuy·ªÉn
                        const __m = (Input && Input.getMode) ? Input.getMode() : (Game.startMode || {difficulty:'hard', players:1});
                        const __mouseMode = !!(__m && __m.players === 1 && __m.difficulty === 'hard');
                        let __tx, __ty;

                        if (__mouseMode) {
                            __tx = Input.mouse.x + Camera.x;
                            __ty = Input.mouse.y + Camera.y;
                        } else {
                            // No-mouse modes (Easy / 2P): blink forward by movement direction
                            let __dx = 0, __dy = 0;
                            const __pid = this.pid || 1;

                            if (Input && Input.keys) {
                                if (__pid === 2) {
                                    if (Input.keys['arrowup']) __dy -= 1;
                                    if (Input.keys['arrowdown']) __dy += 1;
                                    if (Input.keys['arrowleft']) __dx -= 1;
                                    if (Input.keys['arrowright']) __dx += 1;
                                } else {
                                    if (Input.keys['w']) __dy -= 1;
                                    if (Input.keys['s']) __dy += 1;
                                    if (Input.keys['a']) __dx -= 1;
                                    if (Input.keys['d']) __dx += 1;
                                }
                            }

                            const __len = Math.hypot(__dx, __dy);
                            if (__len > 0.001) { __dx /= __len; __dy /= __len; }
                            else {
                                const __ang = (typeof this.angle === 'number') ? this.angle : 0;
                                __dx = Math.cos(__ang); __dy = Math.sin(__ang);
                            }

                            const __dist = 300;
                            __tx = this.x + __dx * __dist;
                            __ty = this.y + __dy * __dist;
                        }

createComplexExplosion(this.x, this.y, cfg.color || '#E040FB', 14);

                        this.x = __tx;
                        this.y = __ty;

                        // Clamp v√†o map
                        this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                        this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y));

                        // Anti-stuck: ƒë·∫©y ra kh·ªèi v·∫≠t c·∫£n nh·∫π
                        if (Game.obstacles && Game.obstacles.length) {
                            for (let t = 0; t < 10; t++) {
                                let stuck = false;
                                for (let obs of Game.obstacles) {
                                    if (checkCircleRect({ x: this.x, y: this.y, radius: this.radius }, obs)) {
                                        const obsCX = obs.x + obs.width / 2;
                                        const obsCY = obs.y + obs.height / 2;
                                        const ang = Math.atan2(this.y - obsCY, this.x - obsCX);
                                        this.x += Math.cos(ang) * 8;
                                        this.y += Math.sin(ang) * 8;
                                        stuck = true;
                                    }
                                }
                                if (!stuck) break;
                            }
                        }

                        createComplexExplosion(this.x, this.y, cfg.color || '#E040FB', 14);
                        createDamageText(this.x, this.y - 40, cfg.castText || 'E: D·ªäCH CHUY·ªÇN', cfg.color || '#E040FB');

                        this.skills[skillName].lastUsed = now;
                        return;
                    }

                    if (skillName === 'vampirism') { // R - B√£o Tuy·∫øt di chuy·ªÉn theo n√≤ng s√∫ng (realtime)
                        if (!this.mage) this.mage = { blizzard: { active: false, x: 0, y: 0, endTime: 0, nextTick: 0, locked: false } };
                        const bz = this.mage.blizzard;

                        bz.active = true;
                        bz.x = this.x;
                        bz.y = this.y;
                        bz.locked = false;
                        bz.endTime = now + (cfg.duration || 5500);
                        bz.nextTick = now;

                        Game.ui.removeBuff('B√£o Tuy·∫øt');
                        Game.ui.addBuff('B√£o Tuy·∫øt', cfg.color || '#00E5FF');
                        createDamageText(this.x, this.y - 40, cfg.castText || 'R: B√ÉO TUY·∫æT', cfg.color || '#00E5FF');

                        this.skills[skillName].lastUsed = now;
                        return;
                    }
                }

// Non-default systems: placeholder (fallback)
                if (this.systemId !== 'default') {
                    skillState.lastUsed = now;
                    createDamageText(this.x, this.y - 40, config.castText || 'COMING SOON', config.color || '#FFD700');
                    return;
                }


                // Default system: keep existing skills
                skillState.lastUsed = now;
                if (skillName === 'clone') {
                    if (Game.clones.length > 0) {
                        Game.clones.forEach(c => { c.markedForDeletion = true; createComplexExplosion(c.x, c.y, COLORS.clone); });
                        Game.clones = [];
                        createDamageText(this.x, this.y - 60, 'THAY TH·∫æ!', '#ccc');
                    }
                    createDamageText(this.x, this.y - 40, 'PH√ÇN TH√ÇN CHI·∫æN ƒê·∫§U!', COLORS.clone);
                    Game.clones.push(new CloneTank(this.x + 50, this.y));
                }
                else if (skillName === 'stealth') {
                    createDamageText(this.x, this.y - 40, 'T√ÄNG H√åNH!', '#AB47BC');
                    this.isStealth = true;
                    skillState.active = true;
                    skillState.endTime = now + (config.duration || 0);
                }
                else if (skillName === 'vampirism') {
                    createDamageText(this.x, this.y - 40, 'H√öT M√ÅU!', '#FF5252');
                    skillState.active = true;
                    skillState.endTime = now + (config.duration || 0);
                }
            }
            addBuff(type, duration) { const now = Date.now(); if (type === 'shield') { this.buffs.shield.active = true; this.buffs.shield.endTime = now + duration; if (Game.ui && Game.ui.setShieldOverlay) Game.ui.setShieldOverlay(true); else { try{document.getElementById('shieldOverlay').style.display='block';}catch(e){} } Game.ui.addBuff('Shield', '#2196F3'); } else if (type === 'rapid') { this.buffs.rapid.active = true; this.buffs.rapid.endTime = now + duration; Game.ui.addBuff('Rapid', '#FF9800'); } }
            useUltimate() {
                if (this.ultiCharge < 100) return;
                this.ultiCharge = 0;
                Game.ui.updateUltiBar(0);
                createDamageText(this.x, this.y - 80, "FIRESTORM!!!", "#FFD700");
                Game.shake = 30;
                const dmgMultSkill = (1 + 0.1 * ((Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0));
                if (typeof MAX !== 'undefined') MAX.Audio.ulti();
                createComplexExplosion(this.x, this.y, '#FF5722', 50);
                Game.enemies.forEach(e => {
                    if (!e || e.markedForDeletion || e.hp <= 0) return;
                    if (e.typeKey === 'BOSS') {
                        const bossDmg = Math.max(1, Math.round(250 * dmgMultSkill));
                        e.hp -= bossDmg;
                        createDamageText(e.x, e.y, `-${bossDmg}`, "#FFD700");
                        createComplexExplosion(e.x, e.y, '#FF5722', 20);
                    } else {
                        const dmg = Math.max(1, Math.round(150 * dmgMultSkill));
                        e.hp -= dmg;
                        createDamageText(e.x, e.y, `-${dmg}`, "#FF5722");
                        createComplexExplosion(e.x, e.y, '#FF5722', 10);
                    }
                });
            }
            gainUltiCharge(amount) { this.ultiCharge = Math.min(100, this.ultiCharge + amount); Game.ui.updateUltiBar(this.ultiCharge); }
            update(obstacles) {
                // Phase 2: mode-aware keybinds (Hard/Easy/2P) + edge-trigger actions
                const __m = (Input && Input.getMode) ? Input.getMode() : (Game.startMode || {difficulty:'hard', players:1});
                const __is2p = !!(__m && __m.players === 2);
                const __isEasy = !!(__m && __m.difficulty === 'easy');

                // Phase 8: co-op downed state (hp<=0): no movement/shoot/skills, and no collisions
                const __dead = (this.hp <= 0);
                if (__dead) { this.hp = 0; if (this.dash) this.dash.active = false; if (this.ram) this.ram.active = false; this.isStealth = false; }
                this.__noCollide = __dead;

                // Weapon select: digits only in 1P. In 2P digits are reserved for P2 skills.
                if (!__is2p) {
                    if (Input.keys['1']) this.selectWeapon(0); if (Input.keys['2']) this.selectWeapon(1); if (Input.keys['3']) this.selectWeapon(2);
                    if (Input.keys['4']) this.selectWeapon(3); if (Input.keys['5']) this.selectWeapon(4); if (Input.keys['6']) this.selectWeapon(5);
                }

                // Weapon/Target cycle (edge-trigger) for no-mouse modes (Easy/2P)
                if ((__isEasy || __is2p) && Input.consumeAction) {
                    if (Input.consumeAction('p1_weapon_cycle')) {
                        const n = (this.inventory && this.inventory.length) ? this.inventory.length : 0;
                        if (n > 0) this.selectWeapon((this.currentWeaponIndex + 1) % n);
                    }
                    if (Input.consumeAction('p1_target_cycle')) {
                        // (Phase 3/5 will use this counter to cycle lock-target)
                        this.__targetCycleReq = (this.__targetCycleReq || 0) + 1;
                    }
                }

                if (!__dead) { if (Input.keys['q']) this.useSkill('clone'); if (Input.keys['e']) this.useSkill('stealth'); if (Input.keys['r']) this.useSkill('vampirism'); if (Input.keys[' ']) this.useUltimate(); }

                const now = Date.now();

                // Default system skill expirations
                if (this.systemId === 'default') {
                    if (this.isStealth && now > this.skills.stealth.endTime) {
                        this.isStealth = false;
                        this.skills.stealth.active = false;
                        createDamageText(this.x, this.y - 40, "H·∫æT T√ÄNG H√åNH", "#fff");
                    }
                    if (this.skills.vampirism.active && now > this.skills.vampirism.endTime) {
                        this.skills.vampirism.active = false;
                        createDamageText(this.x, this.y - 40, "H·∫æT H√öT M√ÅU", "#fff");
                    }
                }

                // Speed system expirations
                if (this.systemId === 'speed') {
                    if (this.dash && this.dash.active && now > this.dash.endTime) {
                        this.dash.active = false;
                    }
                    if (this.buffs.phase && this.buffs.phase.active && now > this.buffs.phase.endTime) {
                        this.buffs.phase.active = false;
                        Game.ui.removeBuff('Phase');
                        createDamageText(this.x, this.y - 40, "H·∫æT PHASE", "#fff");
                    }
                    if (this.buffs.adrenaline && this.buffs.adrenaline.active && now > this.buffs.adrenaline.endTime) {
                        this.buffs.adrenaline.active = false;
                        Game.ui.removeBuff('Adren');
                        createDamageText(this.x, this.y - 40, "H·∫æT ADREN", "#fff");
                    }
                }


                // Juggernaut expirations
                if (this.systemId === 'juggernaut') {
                    if (this.ram && this.ram.active && now > this.ram.endTime) {
                        this.ram.active = false;
                    }
                    if (this.buffs.juggerShield && this.buffs.juggerShield.active && now > this.buffs.juggerShield.endTime) {
                        this.buffs.juggerShield.active = false;
                        Game.ui.removeBuff('Gi√°p Ph·∫£n');
                        createDamageText(this.x, this.y - 40, 'H·∫æT GI√ÅP PH·∫¢N', '#fff');
                    }
                
                    if (this.buffs.siege && this.buffs.siege.active && now > this.buffs.siege.endTime) {
                        this.buffs.siege.active = false;
                        Game.ui.removeBuff('Ph√°o ƒê√†i');
                        createDamageText(this.x, this.y - 40, 'H·∫æT PH√ÅO ƒê√ÄI', '#fff');
                    }
}

                // Effective speed (Adrenaline)
                let effSpeed = (this.baseSpeed || this.speed || 6.5);
                // Shop upgrade: ƒê·ªông C∆° (Lv 0 = ch∆∞a mua, m·ªói c·∫•p +5%)
                const spdLv = (Game.upgrades && typeof Game.upgrades.speedLv === 'number') ? (Game.upgrades.speedLv|0) : 0;
                if (spdLv > 0) {
                    effSpeed *= (1 + spdLv * 0.05);
                }

                if (this.systemId === 'speed' && this.buffs.adrenaline && this.buffs.adrenaline.active) {
                    effSpeed *= (this.buffs.adrenaline.speedMult || 1.25);
                }
                if (this.systemId === 'juggernaut' && this.buffs.siege && this.buffs.siege.active) {
                    effSpeed *= (this.buffs.siege.speedMult || 0.3);
                }
                this.speed = effSpeed;

                // Radius / size scaling (Siege Mode)
                if (this.baseRadius) {
                    const sm = (this.systemId === 'juggernaut' && this.buffs.siege && this.buffs.siege.active) ? (this.buffs.siege.sizeMult || 1.35) : 1;
                    this.radius = this.baseRadius * sm;
                }

                // Movement (Dash overrides)
                let dx = 0, dy = 0;
                if (__dead) { dx = 0; dy = 0; } else if (this.dash && this.dash.active && now <= this.dash.endTime) {
                    dx = this.dash.vx;
                    dy = this.dash.vy;
                } else if (this.ram && this.ram.active && now <= this.ram.endTime) {
                    dx = this.ram.vx;
                    dy = this.ram.vy;
                } else {
                    if (this.dash) this.dash.active = false;
                    if (this.ram) this.ram.active = false;
                    if (Input.keys.w) dy -= 1; if (Input.keys.s) dy += 1; if (Input.keys.a) dx -= 1; if (Input.keys.d) dx += 1;
                    if (dx !== 0 || dy !== 0) {
                        const length = Math.hypot(dx, dy) || 1;
                        dx = (dx / length) * effSpeed;
                        dy = (dy / length) * effSpeed;
                    }
                }

                if(isNaN(dx)) dx = 0; if(isNaN(dy)) dy = 0;
                let nextX = this.x + dx; let nextY = this.y + dy;

                let collided = false;
                for (let obs of obstacles) {
                    if (checkCircleRect({x: nextX, y: nextY, radius: this.radius}, obs)) {
                        collided = true;
                        if (!checkCircleRect({x: nextX, y: this.y, radius: this.radius}, obs)) this.x = nextX;
                        else if (!checkCircleRect({x: this.x, y: nextY, radius: this.radius}, obs)) this.y = nextY;
                        break;
                    }
                }
                if (!collided) { this.x = nextX; this.y = nextY; }

                for (let obs of obstacles) {
                    if (checkCircleRect({x: this.x, y: this.y, radius: this.radius}, obs)) {
                        const obsCX = obs.x + obs.width/2;
                        const obsCY = obs.y + obs.height/2;
                        const anglePush = Math.atan2(this.y - obsCY, this.x - obsCX);
                        this.x += Math.cos(anglePush) * 4;
                        this.y += Math.sin(anglePush) * 4;
                    }
                }

                this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y));

                // Juggernaut J2: va ch·∫°m khi ƒëang C√∫ H√∫c (ƒë·∫©y l√πi + g√¢y s√°t th∆∞∆°ng)
                if (this.systemId === 'juggernaut' && this.ram && this.ram.active && now <= this.ram.endTime) {
                    const ramCfg = getSystemSkillDef(this.systemId, 'stealth') || {};
                    const waveNow = (typeof WaveManager !== 'undefined' && WaveManager.wave) ? (WaveManager.wave | 0) : 1;
                    const impactBase = (typeof ramCfg.impactBase === 'number') ? ramCfg.impactBase : 60;
                    const impactPerWave = (typeof ramCfg.impactPerWave === 'number') ? ramCfg.impactPerWave : 3;
                    const knock = (typeof ramCfg.knockback === 'number') ? ramCfg.knockback : 95;
                    const dmgBase = Math.round(impactBase + impactPerWave * Math.max(0, waveNow - 1));
                    const dmgMultSkill = (1 + 0.1 * ((Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0));
                    const dmg = Math.max(1, Math.round(dmgBase * dmgMultSkill));

                    for (const e of Game.enemies) {
                        if (!e || e.markedForDeletion || e.hp <= 0) continue;
                        if (e.typeKey === 'BOSS') continue; // an to√†n: J2 ch∆∞a ƒë·∫©y Boss
                        const er = (e.radius || (e.config && e.config.radius) || 18);
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d > this.radius + er + 2) continue;

                        if (this.ram.hitSet && this.ram.hitSet.has(e)) continue;
                        if (this.ram.hitSet) this.ram.hitSet.add(e);

                        e.hp -= dmg;
                        createDamageText(e.x, e.y - 10, '-' + dmg, '#FFCA28');

                        // Knockback
                        let nx = (e.x - this.x);
                        let ny = (e.y - this.y);
                        const l = Math.hypot(nx, ny) || 1;
                        nx /= l; ny /= l;
                        e.x += nx * knock;
                        e.y += ny * knock;
                        e.x = Math.max(er, Math.min(WORLD_WIDTH - er, e.x));
                        e.y = Math.max(er, Math.min(WORLD_HEIGHT - er, e.y));
                    }
                }

// Phase 5: No-mouse (Easy 1P + 2P): auto-aim per player. Hard 1P stays mouse-aim.
const __noMouseAim = (__is2p || __isEasy);
if (__noMouseAim) {
    const AA = this.__autoAim || (this.__autoAim = { nextScan: 0, candidates: [], idx: 0, target: null });
    const nowMs = now;

    // Rescan candidates periodically (throttle) or when target invalid
    const needRescan = (nowMs >= AA.nextScan) || !AA.candidates || AA.candidates.length === 0 || !AA.target || (AA.target.hp <= 0);
    if (needRescan) {
        const ex = this.x, ey = this.y;
        const cand = [];
        const arr = Game.enemies || [];

        // 1) Collect alive enemies + distance^2
        for (let i = 0; i < arr.length; i++) {
            const e = arr[i];
            if (!e || e.hp <= 0) continue;
            const dx = e.x - ex, dy = e.y - ey;
            cand.push({ e, d2: dx * dx + dy * dy });
        }

        // 2) Sort nearest -> farthest
        cand.sort((a, b) => a.d2 - b.d2);

        // 3) Pick nearest with clear line-of-sight (skip enemies behind obstacles)
        const obsList = (Game.obstacles && Game.obstacles.length) ? Game.obstacles : (obstacles || []);
        AA.target = null;
        AA.idx = 0;

        for (let i = 0; i < cand.length; i++) {
            const potential = cand[i].e;
            const blocked = (typeof isLineBlocked === 'function') ? isLineBlocked(ex, ey, potential.x, potential.y, obsList) : false;
            if (!blocked) {
                AA.target = potential;
                AA.idx = i;
                break;
            }
        }

        // Keep full candidate list for manual cycle (even if some are blocked)
        AA.candidates = cand.map(o => o.e);

        // If everything is blocked, AA.target stays null (won't waste shots into walls)
        AA.nextScan = nowMs + 150; // 150ms throttle (more responsive)
    }

    // Consume target-cycle requests (edge-triggered by Input)
    const req = (this.__targetCycleReq || 0);
    if (req > 0 && AA.candidates && AA.candidates.length) {
        this.__targetCycleReq = 0;
        AA.idx = (AA.idx + req) % AA.candidates.length;
        AA.target = AA.candidates[AA.idx] || null;
    }

    // Validate target (may die between scans)
    if (AA.target && AA.target.hp <= 0) AA.target = null;
    if (!AA.target && AA.candidates && AA.candidates.length) {
        AA.target = AA.candidates[0] || null;
        AA.idx = 0;
    }

    this.__easyTarget = AA.target || null;
    if (this.__easyTarget) {
        this.angle = Math.atan2(this.__easyTarget.y - this.y, this.__easyTarget.x - this.x);
    }
    // No target: keep current angle (do not fall back to mouse in Easy)
} else {
    const worldMouseX = Input.mouse.x + Camera.x;
    const worldMouseY = Input.mouse.y + Camera.y;
    this.angle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x);
}

                // Mage system: B√£o Tuy·∫øt (R) di chuy·ªÉn theo n√≤ng s√∫ng (realtime), d·ª´ng khi c√≥ qu√°i trong v√≤ng tr√≤n nh·ªè
                if (this.systemId === 'mage' && this.mage && this.mage.blizzard && this.mage.blizzard.active) {
                    const bz = this.mage.blizzard;
                    const cfg = getSystemSkillDef('mage', 'vampirism') || {};
                    const outerR = (cfg.radius != null) ? cfg.radius : 220;
                    const innerR = (cfg.innerRadius != null) ? cfg.innerRadius : 70;

                    if (now > bz.endTime) {
                        bz.active = false;
                        bz.locked = false;
                        Game.ui.removeBuff('B√£o Tuy·∫øt');
                    } else {
                        // Check lock (enemy inside inner circle)
                        let locked = false;
                        for (const e of Game.enemies) {
                            if (!e || e.markedForDeletion || e.hp <= 0) continue;
                            const d = Math.hypot(e.x - bz.x, e.y - bz.y);
                            if (d <= innerR) { locked = true; break; }
                        }
                        bz.locked = locked;

                        // Move if not locked (scaled by FPS cap)
                        if (!bz.locked) {
                            const cap = Math.max(30, Math.min(120, (typeof MAX !== 'undefined' && MAX.State && MAX.State.save && MAX.State.save.settings) ? (MAX.State.save.settings.fpsCap || 60) : 60));
                            const pxPerSec = (cfg.moveSpeed != null) ? cfg.moveSpeed : 220;
                            const step = pxPerSec / cap;

                            bz.x += Math.cos(this.angle) * step;
                            bz.y += Math.sin(this.angle) * step;

                            // Clamp ƒë·ªÉ v√≤ng tr√≤n l·ªõn kh√¥ng b·ªã tr∆∞·ª£t ra ngo√†i map
                            bz.x = Math.max(outerR, Math.min(WORLD_WIDTH - outerR, bz.x));
                            bz.y = Math.max(outerR, Math.min(WORLD_HEIGHT - outerR, bz.y));
                        }

                        // Tick damage + slow
                        const tickI = (cfg.tickInterval != null) ? cfg.tickInterval : 400;
                        if (now >= bz.nextTick) {
                            bz.nextTick = now + tickI;
                            const dmg = (cfg.tickDamage != null) ? cfg.tickDamage : 28;
                            const dmgMultSkill = (1 + 0.1 * ((Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0));
                            const dmgFinal = Math.max(1, Math.round(dmg * dmgMultSkill));
                            const slowFactor = (cfg.slowFactor != null) ? cfg.slowFactor : 0.5;
                            const slowDur = (cfg.slowDuration != null) ? cfg.slowDuration : 900;

                            for (const e of Game.enemies) {
                                if (!e || e.markedForDeletion || e.hp <= 0) continue;
                                const d = Math.hypot(e.x - bz.x, e.y - bz.y);
                                if (d <= outerR) {
                                    e.hp -= dmgFinal;
                                    createDamageText(e.x, e.y, dmgFinal, cfg.color || "#00E5FF");
                                    if (typeof e.applyEffect === 'function') e.applyEffect({ type: 'SLOW', duration: slowDur, factor: slowFactor });
                                }
                            }
                        }
                    }
                }

                // Expire item buffs
                if (this.buffs.shield.active && now > this.buffs.shield.endTime) {
                    this.buffs.shield.active = false;
                    if (Game.ui && Game.ui.setShieldOverlay) Game.ui.setShieldOverlay(false); else { try{document.getElementById('shieldOverlay').style.display='none';}catch(e){} }
                    Game.ui.removeBuff('Shield');
                }
                if (this.buffs.rapid.active && now > this.buffs.rapid.endTime) {
                    this.buffs.rapid.active = false;
                    Game.ui.removeBuff('Rapid');
                }

// Phase 5: No-mouse (Easy 1P + 2P) auto-shoot. Hard 1P remains click-to-shoot.
if ((__is2p || __isEasy)) {
    if (!__dead && this.__easyTarget) this.shoot(obstacles);
} else {
    if (!__dead && Input.mouse.down) this.shoot(obstacles);
}

                Game.ui.updateSkillCooldown('clone', this.skills.clone.lastUsed, getSystemSkillDef(this.systemId, 'clone').cooldown);
                Game.ui.updateSkillCooldown('stealth', this.skills.stealth.lastUsed, getSystemSkillDef(this.systemId, 'stealth').cooldown);
                Game.ui.updateSkillCooldown('vampirism', this.skills.vampirism.lastUsed, getSystemSkillDef(this.systemId, 'vampirism').cooldown);
                this.validatePosition();
            }
            shoot(obstacles) {
                const now = Date.now();
                // Speed system: cannot shoot while dashing (feels cleaner + less buggy)
                if (this.systemId === 'speed' && this.dash && this.dash.active && now <= this.dash.endTime) return; let weaponObj = this.getCurrentWeaponObj();
                let baseConfig = BULLET_TYPES[weaponObj.id];

                // Juggernaut Siege Mode: always shoot ROCKET regardless of current weapon
                if (this.systemId === 'juggernaut' && this.buffs.siege && this.buffs.siege.active) {
                    let currentLv = weaponObj.level || 1;
                    weaponObj = { id: 'ROCKET', level: currentLv };
                    baseConfig = BULLET_TYPES.ROCKET;
                }
                // [BALANCING V4] - C·∫≠p nh·∫≠t ch·ªâ s·ªë c√¢n b·∫±ng
                let level = weaponObj.level || 1; 
                let damage = baseConfig.damage; 
                let cooldown = baseConfig.cooldown; 
                let speed = baseConfig.speed;

                if (weaponObj.id === 'NORMAL') { 
                    // Shotgun: Lv3 b·∫Øn 2, Lv5 b·∫Øn 3. Dmg to, t·∫ßm g·∫ßn.
                    cooldown = Math.max(100, baseConfig.cooldown - (level - 1) * 30); 
                    damage += (level - 1) * 3; 
                }
                else if (weaponObj.id === 'FIRE') { 
                    // S√∫ng m√°y: B·∫Øn c·ª±c nhanh, damage b√© nh∆∞ng ƒë·ªët ƒëau.
                    cooldown = Math.max(80, baseConfig.cooldown - (level - 1) * 30); 
                    damage += (level - 1) * 2; 
                }
                else if (weaponObj.id === 'LIGHTNING') { 
                    // S·∫•m s√©t: Gi·∫≠t lan. Buff: Gi·∫£m h·ªìi chi√™u theo c·∫•p ƒë·ªÉ d·ªçn qu√°i nhanh h∆°n.
                    damage += (level - 1) * 6; 
                    cooldown = Math.max(250, baseConfig.cooldown - (level - 1) * 40); // Buff: Gi·∫£m CD
                } 
                else if (weaponObj.id === 'PIERCING') { 
                    // Xuy√™n th·∫•u: Sniper. Buff: TƒÉng damage g·ªëc v√† gi·∫£m m·∫°nh h·ªìi chi√™u.
                    damage = 35 + (level - 1) * 12; // Base c≈© l√† ? -> Set c·ª©ng base m·ªõi cho m·∫°nh
                    cooldown = Math.max(300, baseConfig.cooldown - (level - 1) * 60); // Buff: Gi·∫£m CD m·∫°nh
                }
                else if (weaponObj.id === 'HOMING') { 
                    // ƒê·∫°n ƒëu·ªïi: Ti·ªán l·ª£i. Lv5 b·∫Øn 3 tia.
                    damage += (level - 1) * 4; 
                    if(level >= 5) damage += 15; 
                } 
                else if (weaponObj.id === 'STUN') { 
                    // Cho√°ng: Support. FIX L·ªñI: Th√™m c·ªông damage.
                    cooldown = Math.max(200, baseConfig.cooldown - (level - 1) * 50); 
                    damage += (level - 1) * 5; // Fix: C·ªông damage ƒë·ªÉ kh√¥ng b·ªã ph·∫ø v·ªÅ late
                }
                else if (weaponObj.id === 'ROCKET') {
                    // Rocket: AOE. Buff: Gi·∫£m h·ªìi chi√™u nhanh h∆°n ch√∫t.
                    damage += (level - 1) * 15;
                    cooldown = Math.max(250, baseConfig.cooldown - (level - 1) * 40); // Buff: B·∫Øn nhanh h∆°n ch√∫t
                }
                // Innate cooldown multiplier (system baseline)
                if (this.innateCdMult) cooldown *= this.innateCdMult;
                if (this.buffs.rapid.active) cooldown *= ITEM_TYPES.RAPID_FIRE.value;

                

                

                // Juggernaut Siege Mode: double fire rate
                if (this.systemId === 'juggernaut' && this.buffs.siege && this.buffs.siege.active) {
                    cooldown *= (this.buffs.siege.fireMult || 0.5);
                }// Speed system: Adrenaline increases damage
                if (this.systemId === 'speed' && this.buffs.adrenaline && this.buffs.adrenaline.active) {
                    damage *= (this.buffs.adrenaline.damageMult || 1.3);
                    // Adrenaline: gi·∫£m h·ªìi chi√™u b·∫Øn (fire cooldown)
                    cooldown *= (this.buffs.adrenaline.fireMult || 0.5);

                }
                // Shop upgrade: Fire Rate (-5% cooldown per level)
                if (Game.upgrades && Game.upgrades.fireRateLv) {
                    const flv = Game.upgrades.fireRateLv | 0;
                    const frMax = getFireRateMaxLv();
                    const flvC = Math.min(flv, frMax);
                    const mult = Math.pow(0.95, flvC);
                    cooldown *= mult;
                    cooldown = Math.max(80, cooldown); // clamp: t·ªëi thi·ªÉu 80ms ƒë·ªÉ kh√¥ng "v·ª°" game
                }
if (now - this.lastShot > cooldown) {
                    let finalConfig = { ...baseConfig, damage: damage, speed: speed };
                    if (weaponObj.id === 'LIGHTNING') { finalConfig.chainCount = baseConfig.chainCount + (level - 1); finalConfig.chainRange = baseConfig.chainRange + (level - 1) * 50; }
                    else if (weaponObj.id === 'PIERCING') { finalConfig.pierceCount = baseConfig.pierceCount + (level - 1); if (level >= 5) finalConfig.radius = 10; }
                    else if (weaponObj.id === 'FIRE') { finalConfig.effect = { ...baseConfig.effect, tickDamage: (baseConfig.effect.tickDamage + (level - 1) * 2) * ((this.systemId === 'speed' && this.buffs.adrenaline && this.buffs.adrenaline.active) ? (this.buffs.adrenaline.damageMult || 1.3) : 1) }; }
                    else if (weaponObj.id === 'HOMING') { finalConfig.turnSpeed = Math.min(0.5, baseConfig.turnSpeed + (level - 1) * 0.05); }
                    else if (weaponObj.id === 'STUN') { finalConfig.effect = { ...baseConfig.effect, duration: baseConfig.effect.duration + (level - 1) * 200 }; }

                    const __baseR2 = (this.baseRadius || 22);
                    const __scale2 = (__baseR2 > 0) ? (this.radius / __baseR2) : 1;
                    const muzzleDist = 35 * (__scale2 || 1);
                    const tipX = this.x + Math.cos(this.angle) * muzzleDist;
                    const tipY = this.y + Math.sin(this.angle) * muzzleDist;
                    const spawnBullet = (ang) => { 
                        Game.projectiles.push(new Bullet(tipX, tipY, ang, weaponObj.id, finalConfig, 'PLAYER'));
                        createMuzzleFlash(tipX, tipY, ang, finalConfig.color);
                    };

                    if (weaponObj.id === 'NORMAL' && level >= 5) { spawnBullet(this.angle); spawnBullet(this.angle - 0.2); spawnBullet(this.angle + 0.2); }
                    else if (weaponObj.id === 'NORMAL' && level >= 3) { spawnBullet(this.angle - 0.1); spawnBullet(this.angle + 0.1); }
                    else if (weaponObj.id === 'HOMING' && level >= 5) { spawnBullet(this.angle); spawnBullet(this.angle - 0.3); spawnBullet(this.angle + 0.3); }
                    else { spawnBullet(this.angle); }

                    const recoilX = Math.cos(this.angle) * 2; const recoilY = Math.sin(this.angle) * 2; const nextX = this.x - recoilX; const nextY = this.y - recoilY;
                    let canRecoil = true; if (obstacles) { for (let obs of obstacles) { if (checkCircleRect({x: nextX, y: nextY, radius: this.radius}, obs)) { canRecoil = false; break; } } }
                    if (canRecoil) { this.x = nextX; this.y = nextY; }
                    this.lastShot = now;
                }
            }
            takeDamage(amount, source) {
                const now = Date.now();
                const rawAmount = amount;
                const juggerActive = (this.systemId === 'juggernaut' && this.buffs.juggerShield && this.buffs.juggerShield.active && now <= this.buffs.juggerShield.endTime);

                // Speed system: Phase = mi·ªÖn th∆∞∆°ng
                if (this.buffs.phase && this.buffs.phase.active && now <= this.buffs.phase.endTime) {
                    // Phase (Speed): mi·ªÖn th∆∞∆°ng, v√† chuy·ªÉn 50% s√°t th∆∞∆°ng nh·∫≠n v√†o th√†nh m√°u
                    let a = amount;
                    // t√≠nh gi·∫£m s√°t th∆∞∆°ng nh∆∞ b√¨nh th∆∞·ªùng (Shield + Armor) ƒë·ªÉ gi·ªØ c√¢n b·∫±ng
                    if (this.buffs.shield.active) a *= 0.3;
                    if (juggerActive) a *= 0.5;

                    const alvP = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv | 0) : 0;
                    const reductionP = Math.min(0.75, (alvP * 0.05) + (this.innateArmor || 0));
                    const finalAmountP = (a > 0) ? Math.max(1, Math.round(a * (1 - reductionP))) : a;

                    const healAmt = (finalAmountP > 0) ? (finalAmountP * 0.5) : 0;
                    if (healAmt > 0) {
                        this.heal(healAmt);
                        createDamageText(this.x, this.y - 60, `+${Math.round(healAmt)}`, '#00ff88');
                    }
                    return;
                }

                // Juggernaut J1: Reflective Shield (kh√¥ng ph·∫£n boss)
                if (juggerActive && rawAmount > 0) {
                    const attacker = source ? (source.enemy || source.attacker || null) : null;
                    if (attacker && attacker.typeKey !== 'BOSS' && typeof attacker.hp === 'number') {
                        const dmgMultSkill = (1 + 0.1 * ((Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0));
                        const reflectDmg = Math.max(1, Math.round(rawAmount * 0.5 * dmgMultSkill));
                        attacker.hp -= reflectDmg;
                        createDamageText(attacker.x, attacker.y - 20, `-${reflectDmg}`, '#FFD54F');
                    }
                }

                // Damage reductions
                let modAmount = amount;
                if (this.buffs.shield.active) modAmount *= 0.3;
                if (juggerActive) modAmount *= 0.5;


                // N·∫øu ƒëang b·∫≠t Ph√°o ƒê√†i (Siege), gi·∫£m 60% s√°t th∆∞∆°ng nh·∫≠n v√†o (ch·ªâ nh·∫≠n 40%)
                if (this.buffs.siege && this.buffs.siege.active) modAmount *= 0.4;
                const hasShield = (this.buffs.shield.active || juggerActive || (this.buffs.siege && this.buffs.siege.active));
                if (!hasShield && modAmount > 0) {
                    const __pidPrevW = Game.__uiPid;
                    try { Game.__uiPid = (this.pid || 1); this.loseCurrentWeapon(); }
                    finally { Game.__uiPid = __pidPrevW; }
                }

                // Armor upgrade: -5% damage taken per level (cap 60%)
                const alv = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv | 0) : 0;
                const reduction = Math.min(0.75, (alv * 0.05) + (this.innateArmor || 0));
                const finalAmount = (modAmount > 0) ? Math.max(1, Math.round(modAmount * (1 - reduction))) : modAmount;

                this.hp -= finalAmount;
                if (this.hp < 0) this.hp = 0;
                const __pidPrev = Game.__uiPid;

                try { Game.__uiPid = (this.pid || 1); Game.ui.updateHealth(this.hp, this.maxHp); }

                finally { Game.__uiPid = __pidPrev; }
                Game.shake = 10;
            }

            heal(amount) {
                this.hp = Math.min(this.hp + amount, this.maxHp);
                const __pidPrev = Game.__uiPid;

                try { Game.__uiPid = (this.pid || 1); Game.ui.updateHealth(this.hp, this.maxHp); }

                finally { Game.__uiPid = __pidPrev; }
createDamageText(this.x, this.y - 20, `+${Math.floor(amount)}`, '#4CAF50');
            }
            draw() {
                // Mage system: v·∫Ω B√£o Tuy·∫øt (world space)
                if (this.systemId === 'mage' && this.mage && this.mage.blizzard && this.mage.blizzard.active) {
                    const bz = this.mage.blizzard;
                    const cfg = getSystemSkillDef('mage', 'vampirism') || {};
                    const outerR = (cfg.radius != null) ? cfg.radius : 220;
                    const innerR = (cfg.innerRadius != null) ? cfg.innerRadius : 70;

                    ctx.save();
                    ctx.translate(bz.x, bz.y);

                    // V√≤ng tr√≤n l·ªõn
                    ctx.beginPath();
                    ctx.arc(0, 0, outerR, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 229, 255, 0.10)';
                    ctx.fill();
                    ctx.strokeStyle = cfg.color || '#00E5FF';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // V√≤ng tr√≤n nh·ªè (v√πng "kh√≥a")
                    ctx.beginPath();
                    ctx.arc(0, 0, innerR, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // H·∫°t tuy·∫øt xoay v√≤ng
                    const t = Date.now() / 220;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    const n = 12;
                    for (let i = 0; i < n; i++) {
                        const ang = t + i * (Math.PI * 2 / n);
                        const dist = (outerR * 0.35) + Math.sin(t * 1.7 + i) * (outerR * 0.14);
                        ctx.beginPath();
                        ctx.arc(Math.cos(ang) * dist, Math.sin(ang) * dist, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    if (bz.locked) {
                        ctx.beginPath();
                        ctx.arc(0, 0, innerR + 10 + Math.sin(t * 2) * 3, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                ctx.save();
                ctx.translate(this.x, this.y);

                // Alpha for Stealth / Phase
                let alpha = 1;
                if (this.isStealth) alpha = 0.4;
                if (this.buffs.phase && this.buffs.phase.active) alpha = 0.35;
                ctx.globalAlpha = alpha;

                // Default system: Vamp aura
                if (this.skills.vampirism.active) {
                    ctx.strokeStyle = '#FF5252';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 82, 82, 0.1)';
                    ctx.fill();
                }

                // Speed system visuals
                if (this.buffs.phase && this.buffs.phase.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 16, 0, Math.PI * 2);
                    ctx.strokeStyle = '#81D4FA';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(129, 212, 250, 0.08)';
                    ctx.fill();
                }
                if (this.buffs.adrenaline && this.buffs.adrenaline.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 12, 0, Math.PI * 2);
                    ctx.strokeStyle = '#29B6F6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(41, 182, 246, 0.06)';
                    ctx.fill();
                }
                if (this.dash && this.dash.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 18, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(79, 195, 247, 0.55)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Item buff: Shield
                if (this.buffs.shield.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
                    ctx.strokeStyle = COLORS.shield;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 191, 255, 0.1)';
                    ctx.fill();
                }

                
                // Juggernaut buff: Gi√°p Ph·∫£n
                if (this.buffs.juggerShield && this.buffs.juggerShield.active && Date.now() <= this.buffs.juggerShield.endTime) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 14, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 213, 79, 0.85)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 213, 79, 0.08)';
                    ctx.fill();
                }
// Body
                ctx.fillStyle = '#333';
                ctx.fillRect(-22, -22, 44, 44);
                ctx.fillStyle = '#111';
                ctx.fillRect(-26, -24, 8, 48);
                ctx.fillRect(18, -24, 8, 48);

                // Turret
                ctx.rotate(this.angle);
                const wObj = this.getCurrentWeaponObj();
                const wConfig = BULLET_TYPES[wObj.id];
                ctx.fillStyle = wConfig.color;
                ctx.beginPath();
                ctx.arc(0, 0, 18, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = COLORS.playerTurret;
                ctx.fillRect(0, -6, 40, 12);
                ctx.restore();
            }
        }

        // --- 4. GAME MANAGERS ---
        
        // --- ADMIN CODE INPUT (hidden) ---
        const Admin = {
            modal: null, panel: null, input: null, msg: null,
            prevPaused: false,
            init() {
                this.modal = document.getElementById('adminCodeModal');
                this.panel = document.getElementById('adminCodePanel');
                this.input = document.getElementById('adminCodeInput');
                this.msg = document.getElementById('adminCodeMsg');
                if (!this.modal || !this.input) return;

                // Click outside to close
                this.modal.addEventListener('mousedown', (e) => {
                    if (e.target === this.modal) this.close();
                });

                // Enter to submit
                this.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        // Prevent Enter from bubbling to window (Shop hotkeys etc.)
                        e.stopPropagation();
                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                        this.run(this.input.value);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        e.stopPropagation();
                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                        this.close();
                    }
                });
            },
            isOpen() {
                return this.modal && !this.modal.classList.contains('hidden');
            },
            open() {
                if (!this.modal) return;
                this.prevPaused = !!Game.paused;
                Game.paused = true;
                this.msg.textContent = '';
                this.input.value = '';
                this.modal.classList.remove('hidden');
                setTimeout(() => this.input.focus(), 0);
            },
            close() {
                if (!this.modal) return;
                this.modal.classList.add('hidden');
                Game.paused = this.prevPaused;
            },
            run(codeRaw) {
                const code = String(codeRaw || '').trim().toLowerCase();
                if (!code) { this.msg.textContent = 'Nh·∫≠p code...'; return; }

                try {
                    if (code === 'cuongdan') {
                        // Full ammo upgrade to Lv.5 (all players)
                        const players = (Game.players && Game.players.length > 0) ? Game.players : [Game.player];
                        let count = 0;

                        // Preserve UI pid (so we don't break HUD routing)
                        const prevPid = Game.__uiPid;

                        players.forEach(p => {
                            if (p && typeof p.activateCheat === 'function') {
                                // Tell UI which player we're updating (1 or 2)
                                Game.__uiPid = p.pid || 1;
                                p.activateCheat();
                                count++;
                            }
                        });

                        // Restore previous pid
                        Game.__uiPid = prevPid;

                        if (count > 0) {
                            this.msg.textContent = 'OK (All Players)';
                        } else {
                            this.msg.textContent = 'Ch∆∞a v√†o game.';
                            return;
                        }
                        this.close();
                        return;
                    }

                    if (code === 'cuongvang') {
                        // +1.000.000.000 gold (cheat)
                        Game.gold = (Game.gold || 0) + 1000000000;
                        try { if (Game.ui && typeof Game.ui.updateGold === 'function') Game.ui.updateGold(Game.gold); } catch(e) {}
                        if (Game.player) createDamageText(Game.player.x, Game.player.y - 45, "+1000000000G", "#FFD700");
                        this.msg.textContent = 'OK';
                        this.close();
                        return;
                    }


                    // Open shop instantly with full items
                    if (code === 'shop') {
                        if (!Game || !Game.player) { this.msg.textContent = 'Ch∆∞a v√†o game.'; return; }
                        try {
                            // Ensure shop is initialized (in case init order changed)
                            try {
                                if (typeof Shop !== 'undefined' && Shop && typeof Shop.init === 'function' && (!Shop.els || !Shop.els.modal)) {
                                    Shop.init();
                                }
                            } catch(e) {}

                            const nextWaveNum = (typeof WaveManager !== 'undefined' && WaveManager && WaveManager.wave) ? (WaveManager.wave + 1) : 1;
                            const gold = (typeof Game !== 'undefined' && Game) ? (Game.gold || 0) : 0;

                            if (typeof Shop !== 'undefined' && Shop && typeof Shop.show === 'function') {
                                // Open shop without "continue next wave" callback
                                Shop.show(nextWaveNum, gold, null);

                                // Force show ALL upgrade cards (ignore random 3 picks)
                                if (Shop.cards && Shop.cards.length) {
                                    for (const c of Shop.cards) c.style.display = "block";
                                }

                                if (typeof Shop.refresh === 'function') Shop.refresh();

                                // Keep paused while shop is open (Admin.close restores pause state)
                                this.prevPaused = true;

                                this.msg.textContent = 'OK (Shop)';
                                this.close();
                                return;
                            }

                            this.msg.textContent = 'Shop ch∆∞a s·∫µn s√†ng.';
                            return;
                        } catch (e) {
                            this.msg.textContent = 'L·ªói.';
                            return;
                        }
                    }

                    // Jump to wave: wave20 / wave15 / wave 20
                    const mWave = code.match(/^wave\s*(\d{1,3})$/);
                    if (mWave) {
                        const target = Math.max(1, Math.min(200, parseInt(mWave[1], 10) || 1));
                        if (!Game || !Game.player) { this.msg.textContent = 'Ch∆∞a v√†o game.'; return; }

                        const wasActive = !!Game.active;
                        try {
                            // Clear current entities for a clean wave start
                            if (Game.enemies) Game.enemies.length = 0;
                            if (Game.enemyBullets) Game.enemyBullets.length = 0;
                            if (Game.bullets) Game.bullets.length = 0;
                            if (Game.projectiles) Game.projectiles.length = 0;
                            if (Game.pickups) Game.pickups.length = 0;
                            if (Game.particles) Game.particles.length = 0;
                            if (Game.turrets) Game.turrets.length = 0;
                            if (Game.clones) Game.clones.length = 0;

                            try { const bh = document.getElementById('bossHealthContainer'); if (bh) bh.style.display = 'none'; } catch(e){}
                            try { const go = document.getElementById('gameOverScreen'); if (go) go.classList.add('hidden'); } catch(e){}
                            try { const vc = document.getElementById('victoryScreen'); if (vc) vc.classList.add('hidden'); } catch(e){}

                            // Reset wave state and start
                            try { WaveManager.active = false; WaveManager.spawnTimer = 0; WaveManager.enemiesRemainingToSpawn = 0; } catch(e){}
                            WaveManager.wave = target;
                            WaveManager.startWave();

                            // Ensure game is running (if coming from victory/gameover)
                            Game.active = true;
                            Game.paused = false;
                            try { if (typeof MAX !== 'undefined' && MAX.State) MAX.State.paused = false; } catch(e){}

                            // Only restart loop if it was previously stopped
                            if (!wasActive && typeof loop === 'function') requestAnimationFrame(loop);

                            this.msg.textContent = 'OK (Wave ' + target + ')';
                            this.close();
                            return;
                        } catch (e) {
                            this.msg.textContent = 'L·ªói.';
                            return;
                        }
                    }

                    this.msg.textContent = 'Sai code.';
                } catch (err) {
                    this.msg.textContent = 'L·ªói.';
                }
            },
            // Capture keys so typing doesn't control the tank
            captureKey(e) {
                // Open combo (hidden): Ctrl + Shift + X
                if (!this.isOpen() && e.ctrlKey && e.shiftKey && (e.code === 'KeyX' || e.key === 'X' || e.key === 'x')) {
                    e.preventDefault();
                    this.open();
                    return true;
                }
                // If modal is open: block game controls BUT allow typing into input.
                if (this.isOpen()) {
                    // Safety: allow Esc to close even if focus isn't on input
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.close();
                        return true;
                    }
                    // Do NOT preventDefault here, otherwise the input cannot receive characters.
                    return true;
                }
                return false;
            }
        };

        const Input = {
            keys: {},
            codes: {},
            actions: {}, // edge-trigger queue: {actionName: count}
            mouse: { x: 0, y: 0, down: false },

            getMode() {
                // Source of truth: Game.startMode set from Start Screen (Phase 1)
                try {
                    if (window.Game && Game.startMode && typeof Game.startMode === 'object') {
                        const sm = Game.startMode;
                        const players = Math.max(1, Math.min(2, parseInt(sm.players, 10) || 1));
                        const difficulty = (sm.difficulty === 'easy') ? 'easy' : 'hard';
                        return Object.assign({}, sm, { players, difficulty });
                    }
                } catch(e) {}
                // Fallback: localStorage (when restarting without reloading)
                try {
                    const raw = localStorage.getItem('tankStartMode_v1');
                    if (raw) {
                        const cfg = JSON.parse(raw);
                        if (cfg && typeof cfg === 'object') {
                            const players = Math.max(1, Math.min(2, parseInt(cfg.players, 10) || 1));
                            const difficulty = (cfg.difficulty === 'easy') ? 'easy' : 'hard';
                            return Object.assign({}, cfg, { players, difficulty });
                        }
                    }
                } catch(e) {}
                return { difficulty: 'hard', players: 1 };
            },

            queueAction(name) {
                if (!name) return;
                this.actions[name] = (this.actions[name] || 0) + 1;
            },
            consumeAction(name) {
                const n = this.actions[name] || 0;
                if (n > 0) { this.actions[name] = n - 1; return true; }
                return false;
            },

            _isTypingTarget(el) {
                if (!el) return false;
                const tag = (el.tagName || '').toUpperCase();
                if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
                // contenteditable
                try { if (el.isContentEditable) return true; } catch(e){}
                return false;
            },

            init() {
                const isGameplayKey = (k) => ['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(k);

                window.addEventListener('keydown', (e) => {
                    // If admin modal wants this key, let it capture first (Ctrl+Shift+X, Enter in modal, etc.)
                    try { if (typeof Admin !== 'undefined' && Admin.captureKey && Admin.captureKey(e)) return; } catch(err){}

                    // Don't steal keys while user is typing in any input (shop/admin/etc.)
                    if (this._isTypingTarget(document.activeElement) || this._isTypingTarget(e.target)) return;

                    const code = e.code || '';
                    const kRaw = (e.key || '');
                    const k = kRaw.toLowerCase();

                    if (isGameplayKey(k)) e.preventDefault();

                    // Edge detection (ignore repeats)
                    const wasDown = (code && this.codes[code]) || this.keys[k] === true;
                    this.keys[k] = true;
                    if (code) this.codes[code] = true;

                    // Keep legacy numeric access (1-6) for existing code paths
                    if (['1','2','3','4','5','6'].includes(kRaw)) this.keys[kRaw] = true;
                    if (kRaw === ' ') this.keys[' '] = true;

                    // Phase 2: translate keybinds by mode (Hard/Easy/2P)
                    const m = this.getMode();
                    const isHard1p = (m.players === 1 && m.difficulty === 'hard');
                    const isNoMouseMode = (!isHard1p) || (m.players === 2);

                    // P1 skills: Easy/2P => J/K/L (but we keep Q/E/R as fallback)
                    if (isNoMouseMode) {
                        if (code === 'KeyJ' || k === 'j') this.keys['q'] = true;
                        if (code === 'KeyK' || k === 'k') this.keys['e'] = true;
                        if (code === 'KeyL' || k === 'l') this.keys['r'] = true;
                    }

                    // Edge-trigger actions (only on first keydown)
                    if (!wasDown && isNoMouseMode) {
                        // Weapon cycle: P1=V, P2=Enter
                        if (code === 'KeyV' || k === 'v') { e.preventDefault(); this.queueAction('p1_weapon_cycle'); }
                        if (code === 'Enter' || code === 'NumpadEnter' || k === 'enter') { e.preventDefault(); this.queueAction('p2_weapon_cycle'); }

                        // Target cycle: P1=T, P2=0 (numpad or digit)
                        if (code === 'KeyT' || k === 't') { e.preventDefault(); this.queueAction('p1_target_cycle'); }
                        if (code === 'Digit0' || code === 'Numpad0' || kRaw === '0') { e.preventDefault(); this.queueAction('p2_target_cycle'); }
                    }
                });

                window.addEventListener('keyup', (e) => {
                    const code = e.code || '';
                    const kRaw = (e.key || '');
                    const k = kRaw.toLowerCase();

                    this.keys[k] = false;
                    if (code) this.codes[code] = false;

                    if (['1','2','3','4','5','6'].includes(kRaw)) this.keys[kRaw] = false;
                    if (kRaw === ' ') this.keys[' '] = false;

                    // Release translated keys (J/K/L => Q/E/R)
                    const m = this.getMode();
                    const isHard1p = (m.players === 1 && m.difficulty === 'hard');
                    const isNoMouseMode = (!isHard1p) || (m.players === 2);
                    if (isNoMouseMode) {
                        // Release translated keys (only if the original physical key isn't still held)
                        if (code === 'KeyJ' || k === 'j') { if (!this.codes['KeyQ']) this.keys['q'] = false; }
                        if (code === 'KeyK' || k === 'k') { if (!this.codes['KeyE']) this.keys['e'] = false; }
                        if (code === 'KeyL' || k === 'l') { if (!this.codes['KeyR']) this.keys['r'] = false; }
                    }
                });

                window.addEventListener('mousemove', (e) => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
                window.addEventListener('mousedown', () => this.mouse.down = true);
                window.addEventListener('mouseup',   () => this.mouse.down = false);

                window.addEventListener('blur', () => {
                    this.keys = {};
                    this.codes = {};
                    this.actions = {};
                    this.mouse.down = false;
                });
                window.addEventListener('focus', () => {
                    this.keys = {};
                    this.codes = {};
                    this.actions = {};
                });
            }
        };

        const WaveManager = {
            wave: 1, finalWave: 20, enemiesRemainingToSpawn: 0, spawnTimer: 0, active: false, isBossWave: false, bossSpawned: false,
            scaling: null,
            computeScaling() {
                const w = this.wave | 0;
                const t = Math.max(0, w - 1);
                // NOTE: Linear scaling + caps ƒë·ªÉ game kh√¥ng v·ª°
                let hpMult = Math.min(4.0, 1 + 0.12 * t);
                let dmgMult = Math.min(3.0, 1 + 0.08 * t);
                const speedMult = Math.min(1.8, 1 + 0.02 * t);
                const fireRateMult = Math.min(1.8, 1 + 0.015 * t); // >1 nghƒ©a l√† b·∫Øn nhanh h∆°n

                const spawnInterval = Math.max(22, 60 - w * 2);
                const _baseSpawnCount = Math.min(60, 3 + Math.floor(w * 2) + Math.floor(w * w * 0.08));
                const _pCount = (typeof Game !== 'undefined' && Game.players && Game.players.length >= 2) ? 2 : 1;
                // 2P: tƒÉng s·ªë qu√°i theo wave (x2 nh∆∞ng c√≥ cap ƒë·ªÉ tr√°nh lag)
                const spawnCount = (_pCount >= 2) ? Math.min(90, _baseSpawnCount * 2) : _baseSpawnCount;

                // Boss scale nh·∫π h∆°n ƒë·ªÉ kh√¥ng one-shot
                let bossHpMult = 1 + (w / 8);
                const bossDmgMult = 1 + (w / 12);



                // 2P balancing (anti-overpowered late game): monsters & boss tankier, monsters hit a bit harder
                const is2P = (_pCount >= 2);
                if (is2P) {
                    hpMult *= 1.35;
                    bossHpMult *= 1.8;
                    dmgMult *= 1.2;
                }

                return { hpMult, dmgMult, speedMult, fireRateMult, spawnInterval, spawnCount, bossHpMult, bossDmgMult };
            },
            startWave() {
                this.active = true; this.bossSpawned = false; this.isBossWave = (this.wave % 5 === 0); this.scaling = this.computeScaling(); Game.generateObstacles();
                // Phase 8: Co-op revive at wave start (revive downed players, keep inventory & shop buffs)
                const __players = (Game.players && Game.players.length) ? Game.players : (Game.player ? [Game.player] : []);
                const __alive = (__players && __players.length) ? (__players.find(p => p && p.hp > 0) || null) : null;
                const __anchor = __alive || ((__players && __players.length) ? __players[0] : null);
                if (__players && __players.length >= 2 && __alive) {
                    const __hpPct = Math.max(0, Math.min(1, (__alive.hp || 0) / Math.max(1, (__alive.maxHp || 1))));
                    let __rev = 0;
                    for (let __i = 0; __i < __players.length; __i++) {
                        const __pl = __players[__i];
                        if (!__pl) continue;
                        if (__pl.hp <= 0) {
                            __pl.hp = Math.max(1, Math.round((__pl.maxHp || 100) * __hpPct)); __pl.__noCollide = false;
                            __pl.isStealth = false;
                            if (__pl.dash) __pl.dash.active = false;
                            if (__pl.ram) __pl.ram.active = false;
                            // reset auto-aim cache so target is reacquired cleanly
                            if (__pl.__autoAim) { __pl.__autoAim.target = null; __pl.__autoAim.candidates = []; __pl.__autoAim.idx = 0; __pl.__autoAim.nextScan = 0; }
                            __pl.__easyTarget = null;

                            // spawn near the first alive player (anchor)
                            const __off = (__i === 0 ? -1 : 1) * 55;
                            const __r = (__pl.radius || 22);
                            __pl.x = Math.max(__r, Math.min(WORLD_WIDTH - __r, (__anchor.x + __off)));
                            __pl.y = Math.max(__r, Math.min(WORLD_HEIGHT - __r, (__anchor.y + 55)));
                            __rev++;
                        }
                    }
                    if (__rev > 0) createDamageText(__anchor.x, __anchor.y - 110, "REVIVE!", "#00ff88");
                }

                if (this.isBossWave) { this.enemiesRemainingToSpawn = 1; createDamageText((__anchor||Game.player).x, (__anchor||Game.player).y - 100, "BOSS BATTLE!", "#D50000"); document.getElementById('bossHealthContainer').style.display = 'block'; } 
                else { const count = (this.scaling ? this.scaling.spawnCount : (3 + Math.floor(this.wave * 1.5))); this.enemiesRemainingToSpawn = count; document.getElementById('bossHealthContainer').style.display = 'none'; }
                Game.ui.updateWave(this.wave);
            },
            update() {
                if (!this.active) return;
                if (this.enemiesRemainingToSpawn > 0) {
                    this.spawnTimer++;
                    if (this.spawnTimer > (this.scaling ? this.scaling.spawnInterval : 60)) {
                        this.spawnEnemy();
                        this.spawnTimer = 0;
                        this.enemiesRemainingToSpawn--;
                    }
                } else if (Game.enemies.length === 0) {
                    this.active = false;

                    // Victory: th·∫Øng Boss ·ªü finalWave (m·∫∑c ƒë·ªãnh 20). Mu·ªën endless th√¨ tƒÉng finalWave.
                    if (!Game.endlessMode && this.isBossWave && (this.wave >= (this.finalWave || 20))) {
                        try { if (Game.player) createDamageText(Game.player.x, Game.player.y - 50, "CHI·∫æN TH·∫ÆNG!", "#4CAF50"); } catch(e){}
                        if (Game && typeof Game.victory === 'function') Game.victory();
                        return;
                    }

                    this.wave++;
                    try {
                        const __ps = (Game.players && Game.players.length) ? Game.players : (Game.player ? [Game.player] : []);
                        let __a = null;
                        for (const __p of __ps) { if (__p && __p.hp > 0) { __a = __p; break; } }
                        __a = __a || __ps[0] || Game.player;
                        if (__a) createDamageText(__a.x, __a.y - 50, "WAVE COMPLETE!", "#FFD700");
                    } catch(e){}
                    Shop.show(this.wave, Game.gold, () => {
                        this.startWave();
                        const __ps2 = (Game.players && Game.players.length) ? Game.players : (Game.player ? [Game.player] : []);
                        for (const __p of __ps2) {
                            if (__p && __p.hp > 0 && typeof __p.heal === 'function') __p.heal(__p.maxHp * 0.3);
                        }
                    });
}
            },
            spawnEnemy() {
                let typeKey; if (this.isBossWave) { typeKey = 'BOSS'; } else { const pool = ['RED']; if (this.wave >= 2) pool.push('YELLOW'); if (this.wave >= 3) pool.push('YELLOW', 'BLACK'); if (this.wave >= 4) pool.push('BLACK', 'BLACK', 'PURPLE'); if (this.wave >= 5) pool.push('PURPLE', 'PURPLE'); typeKey = pool[Math.floor(Math.random() * pool.length)]; }
                let x, y, valid = false; let attempts = 0;
                while (!valid && attempts < 50) {
                    const edge = Math.floor(Math.random() * 4); const buffer = 100;
                    switch(edge) { case 0: x = Camera.x + Math.random() * canvas.width; y = Camera.y - buffer; break; case 1: x = Camera.x + canvas.width + buffer; y = Camera.y + Math.random() * canvas.height; break; case 2: x = Camera.x + Math.random() * canvas.width; y = Camera.y + canvas.height + buffer; break; case 3: x = Camera.x - buffer; y = Camera.y + Math.random() * canvas.height; break; }
                    x = Math.max(100, Math.min(WORLD_WIDTH - 100, x)); y = Math.max(100, Math.min(WORLD_HEIGHT - 100, y));
                    let hitObs = false; for(let obs of Game.obstacles) { if (checkCircleRect({x, y, radius: 80}, obs)) { hitObs = true; break; } }
                    if (!hitObs) valid = true; attempts++;
                }
                if (valid) { const sc = this.scaling || this.computeScaling(); const hpMult = this.isBossWave ? sc.bossHpMult : sc.hpMult; const dmgMult = this.isBossWave ? sc.bossDmgMult : sc.dmgMult; const speedMult = sc.speedMult; const fireRateMult = sc.fireRateMult; Game.enemies.push(new Enemy(x, y, typeKey, hpMult, dmgMult, speedMult, fireRateMult)); }
            }
        };

        // --- SHOP MANAGER (Wave Complete -> Shop) ---
        const Shop = {
            open: false,
            onContinue: null,
            els: {
                modal: null,
                gold: null,
                nextWave: null,
                btnContinue: null,

                btnBuyMaxHp: null,
                maxHpCost: null,
                maxHpLevel: null,

                btnBuyDmg: null,
                dmgCost: null,
                dmgLevel: null,

                btnBuyFireRate: null,
                fireRateCost: null,
                fireRateLevel: null,

                btnBuySpeed: null,
                speedCost: null,
                speedLevel: null,

                btnBuyMagnet: null,
                magnetCost: null,
                magnetLevel: null,

                btnBuyArmor: null,
                armorCost: null,
                armorLevel: null,

                btnBuyHeal30: null,
                heal30Cost: null,
            },
            init() {
                this.els.modal = document.getElementById('shopModal');
                this.els.gold = document.getElementById('shopGold');
                this.els.nextWave = document.getElementById('shopNextWave');
                this.els.btnContinue = document.getElementById('btnShopContinue');

                
                
                // --- Step 3A: Random 3 upgrades m·ªói l·∫ßn m·ªü shop ---
                this.cards = [];
                const grid = document.getElementById('shopCards');
                if (grid) {
                    const cards = Array.from(grid.querySelectorAll('.shopCard'));
                    for (const card of cards) {
                        const btn = card.querySelector('button[id^="btnBuy"]');
                        if (!btn) continue; // ch·ªâ random c√°c n√¢ng c·∫•p mua ƒë∆∞·ª£c
                        card.dataset.upKey = btn.id;
                        if (card.dataset && card.dataset.fixed === "1") {
                            // fixed card (always visible): do not randomize
                        } else {
                            this.cards.push(card);
                        }
                    }
                }

                this._shuffle = (arr) => {
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = (Math.random() * (i + 1)) | 0;
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                };

this.els.btnBuyMaxHp = document.getElementById('btnBuyMaxHp');
                this.els.maxHpCost = document.getElementById('upMaxHpCost');
                this.els.maxHpLevel = document.getElementById('upMaxHpLevel');

                
                this.els.btnBuyDmg = document.getElementById('btnBuyDmg');
                this.els.dmgCost = document.getElementById('upDmgCost');
                this.els.dmgLevel = document.getElementById('upDmgLevel');

                
                this.els.btnBuyFireRate = document.getElementById('btnBuyFireRate');
                this.els.fireRateCost = document.getElementById('upFireRateCost');
                this.els.fireRateLevel = document.getElementById('upFireRateLevel');

                this.els.btnBuySpeed = document.getElementById('btnBuySpeed');
                this.els.speedCost = document.getElementById('upSpeedCost');
                this.els.speedLevel = document.getElementById('upSpeedLevel');

                

                this.els.btnBuyMagnet = document.getElementById('btnBuyMagnet');
                this.els.magnetCost = document.getElementById('upMagnetCost');
                this.els.magnetLevel = document.getElementById('upMagnetLevel');
                if (this.els.btnBuyMagnet) {
                    this.els.btnBuyMagnet.addEventListener('click', () => this.buyMagnet());
                }

                this.els.btnBuyArmor = document.getElementById('btnBuyArmor');
                this.els.armorCost = document.getElementById('upArmorCost');
                this.els.armorLevel = document.getElementById('upArmorLevel');
                if (this.els.btnBuyArmor) {
                    this.els.btnBuyArmor.addEventListener('click', () => this.buyArmor());
                }

this.els.btnBuyHeal30 = document.getElementById('btnBuyHeal30');
this.els.heal30Cost = document.getElementById('upHeal30Cost');
if (this.els.heal30Cost) this.els.heal30Cost.textContent = "200";
if (this.els.btnBuyHeal30) {
    this.els.btnBuyHeal30.addEventListener('click', () => this.buyHeal());
}

if (this.els.btnBuyFireRate) {
                    this.els.btnBuyFireRate.addEventListener('click', () => this.buyFireRate());
                }

if (this.els.btnBuySpeed) {
                    this.els.btnBuySpeed.addEventListener('click', () => this.buySpeed());
                }

if (this.els.btnBuyDmg) {
                    this.els.btnBuyDmg.addEventListener('click', () => this.buyDmg());
                }

if (this.els.btnBuyMaxHp) {
                    this.els.btnBuyMaxHp.addEventListener('click', () => this.buyMaxHp());
                }

if (this.els.btnContinue) {
                    this.els.btnContinue.addEventListener('click', () => this.continue());
                }

                window.addEventListener('keydown', (e) => {
                    if (!this.open) return;
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.continue();
                    }
                });
            },
            show(nextWaveNum, gold, cb) {
                this.open = true;
                this.onContinue = cb || null;
                if (this.els.gold) this.els.gold.textContent = String(gold || 0);
                if (this.els.nextWave) this.els.nextWave.textContent = String(nextWaveNum || 1);
                if (this.els.modal) this.els.modal.classList.remove('hidden');
                Game.paused = true;
            
                this.randomizeChoices();
                this.refresh();
            },
            _apply2PCost(cost) {
                const is2P = (typeof Game !== 'undefined' && Game.players && Game.players.length >= 2);
                if (!is2P) return cost;

                // 2P economy balancing: shop affects BOTH players, so increase cost to offset x2 gold drops
                // Multiply then round to nearest 10 for cleaner prices (e.g., 83 -> 80, 87 -> 90)
                let newCost = cost * 1.7;
                return Math.round(newCost / 10) * 10;
            },
            maxHpCostForLevel(lv) {
                lv = Math.max(0, lv|0);
                // Standard combat scaling: 50 -> 90 -> 140 -> 200 ...
                const cost = 50 + (40 * lv) + (5 * lv * (lv - 1));
                return this._apply2PCost(cost);
            },
            dmgCostForLevel(lv) {
                lv = Math.max(0, lv|0);
                // Standard combat scaling
                const cost = 50 + (40 * lv) + (5 * lv * (lv - 1));
                return this._apply2PCost(cost);
            },
            fireRateCostForLevel(lv) {
                lv = Math.max(0, lv|0);
                // Premium: fire rate is very strong, scale harder
                const cost = 90 + (70 * lv) + (10 * lv * lv);
                return this._apply2PCost(cost);
            },
            
            speedCostForLevel(lv) {
                lv = Math.max(0, lv|0);
                // Cheap support: encourage early movement upgrades
                const cost = 30 + (25 * lv) + (5 * lv * lv);
                return this._apply2PCost(cost);
            },

            magnetCostForLevel(lv) {
                lv = Math.max(0, lv|0);
                // Cheap support: encourage early quality-of-life upgrades
                const cost = 30 + (25 * lv) + (5 * lv * lv);
                return this._apply2PCost(cost);
            },
            armorCostForLevel(lv) {
                lv = Math.max(0, lv|0);
                // Premium: survivability scaling, keep it expensive
                const cost = 80 + (60 * lv) + (10 * lv * lv);
                return this._apply2PCost(cost);
            },
            isFireRateCapped(lvOverride = null) {
                const frMax = getFireRateMaxLv();
                const lv = (lvOverride !== null) ? (lvOverride|0) : ((Game.upgrades && Game.upgrades.fireRateLv) ? (Game.upgrades.fireRateLv|0) : 0);
                return lv >= frMax;
            },

            isUpgradeMaxed(upKey) {
                // Ch·ªâ cap nh·ªØng upgrade c√≥ gi·ªõi h·∫°n r√µ r√†ng ƒë·ªÉ tr√°nh mua "ph√≠ v√†ng"
                if (upKey === 'btnBuyArmor') {
                    const lv = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv|0) : 0;
                    return lv >= 12; // 12 * 5% = 60% (ƒë√∫ng cap ·ªü takeDamage)
                }
                if (upKey === 'btnBuySpeed') {
                    const lv = (Game.upgrades && typeof Game.upgrades.speedLv === 'number') ? (Game.upgrades.speedLv|0) : 0;
                    return lv >= 12;
                }
                if (upKey === 'btnBuyFireRate') { return this.isFireRateCapped(); }
                return false;
            },


            randomizeChoices() {
                if (!this.cards || this.cards.length === 0) return;

                let pool = this.cards.filter(c => !this.isUpgradeMaxed(c.dataset.upKey));
                if (pool.length === 0) pool = this.cards.slice();
                this._shuffle(pool);

                const pickN = Math.min(3, pool.length);
                const chosen = new Set();
                for (let i = 0; i < pickN; i++) chosen.add(pool[i].dataset.upKey);

                for (const c of this.cards) {
                    const show = chosen.has(c.dataset.upKey);
                    c.style.display = show ? "block" : "none";
                }
            },

            refresh() {
                // Update gold in header
                if (this.els.gold) this.els.gold.textContent = String(Game.gold || 0);

                // Max HP
                const hpLv = (Game.upgrades && Game.upgrades.maxHpLv) ? Game.upgrades.maxHpLv : 0;
                const hpCost = this.maxHpCostForLevel(hpLv);
                if (this.els.maxHpLevel) this.els.maxHpLevel.textContent = String(hpLv);
                if (this.els.maxHpCost) this.els.maxHpCost.textContent = String(hpCost);
                if (this.els.btnBuyMaxHp) {
                    const can = (Game.gold >= hpCost) && this._anyAlive();
                    this.els.btnBuyMaxHp.disabled = !can;
                    this.els.btnBuyMaxHp.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyMaxHp.style.cursor = can ? "pointer" : "not-allowed";
                }

                // Damage %
                const dmgLv = (Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0;
                const dmgCost = this.dmgCostForLevel(dmgLv);
                if (this.els.dmgLevel) this.els.dmgLevel.textContent = String(dmgLv);
                if (this.els.dmgCost) this.els.dmgCost.textContent = String(dmgCost);
                if (this.els.btnBuyDmg) {
                    const can = (Game.gold >= dmgCost) && this._anyAlive();
                    this.els.btnBuyDmg.disabled = !can;
                    this.els.btnBuyDmg.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyDmg.style.cursor = can ? "pointer" : "not-allowed";
                }

                // Fire Rate (-5% cooldown)
                const frMax = getFireRateMaxLv();
                let frLv = (Game.upgrades && Game.upgrades.fireRateLv) ? Game.upgrades.fireRateLv : 0;
                if (Game.upgrades && Game.upgrades.fireRateLv > frMax) { Game.upgrades.fireRateLv = frMax; frLv = frMax; }
                const frCost = this.fireRateCostForLevel(frLv);
                const frCapped = (frLv >= frMax);
                if (this.els.fireRateLevel) this.els.fireRateLevel.textContent = String(frLv);
                if (this.els.fireRateCost) this.els.fireRateCost.textContent = String(frCost);
                if (this.els.btnBuyFireRate) {
                    const can = (!frCapped) && (Game.gold >= frCost) && this._anyAlive();
                    this.els.btnBuyFireRate.disabled = !can || frCapped;
                    this.els.btnBuyFireRate.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyFireRate.style.cursor = can ? "pointer" : "not-allowed";
                }

                
                // ƒê·ªông C∆° (+5% t·ªëc ch·∫°y m·ªói c·∫•p, Lv 0 = ch∆∞a mua)
                const sLv = (Game.upgrades && typeof Game.upgrades.speedLv === 'number') ? (Game.upgrades.speedLv|0) : 0;
                const sCapped = sLv >= 12;
                const sCost = this.speedCostForLevel(sLv);
                if (this.els.speedLevel) this.els.speedLevel.textContent = sCapped ? "MAX" : String(sLv);
                if (this.els.speedCost) this.els.speedCost.textContent = sCapped ? "-" : String(sCost);
                if (this.els.btnBuySpeed) {
                    const can = (!sCapped) && (Game.gold >= sCost) && this._anyAlive();
                    this.els.btnBuySpeed.disabled = !can || sCapped;
                    this.els.btnBuySpeed.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuySpeed.style.cursor = can ? "pointer" : "not-allowed";
                }

// Pickup Range (+30px magnet range)
                const mLv = (Game.upgrades && Game.upgrades.magnetLv) ? Game.upgrades.magnetLv : 0;
                const mCost = this.magnetCostForLevel(mLv);
                if (this.els.magnetLevel) this.els.magnetLevel.textContent = String(mLv);
                if (this.els.magnetCost) this.els.magnetCost.textContent = String(mCost);
                if (this.els.btnBuyMagnet) {
                    const can = (Game.gold >= mCost) && this._anyAlive();
                    this.els.btnBuyMagnet.disabled = !can;
                    this.els.btnBuyMagnet.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyMagnet.style.cursor = can ? "pointer" : "not-allowed";
                }

                // Armor (-5% damage taken)
                const aLv = (Game.upgrades && Game.upgrades.armorLv) ? Game.upgrades.armorLv : 0;
                const aCost = this.armorCostForLevel(aLv);
                const armorCapped = (aLv >= 12);
                if (this.els.armorLevel) this.els.armorLevel.textContent = String(aLv);
                if (this.els.armorCost) this.els.armorCost.textContent = String(aCost);
                if (this.els.btnBuyArmor) {
                    const can = (!armorCapped) && (Game.gold >= aCost) && this._anyAlive();
                    this.els.btnBuyArmor.disabled = !can || armorCapped;
                    this.els.btnBuyArmor.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyArmor.style.cursor = can ? "pointer" : "not-allowed";
                }
            

// Heal 30% (consumable)
const healCost = 200;
if (this.els.heal30Cost) this.els.heal30Cost.textContent = String(healCost);
if (this.els.btnBuyHeal30) {
    const can = (Game.gold >= healCost) && this._anyAlive() && this._anyNeedHeal();
    this.els.btnBuyHeal30.disabled = !can;
    this.els.btnBuyHeal30.style.opacity = can ? "1" : "0.55";
    this.els.btnBuyHeal30.style.cursor = can ? "pointer" : "not-allowed";
}

},
            
            // ===== PHASE 9: Co-op shop helpers (shared gold/buffs) =====
            _playersList() {
                try {
                    if (typeof Game !== 'undefined' && Game && Array.isArray(Game.players) && Game.players.length) return Game.players;
                } catch (e) {}
                return (typeof Game !== 'undefined' && Game && Game.player) ? [Game.player] : [];
            },
            _anyAlive() {
                const ps = this._playersList();
                for (const p of ps) { if (p && typeof p.hp === 'number' && p.hp > 0) return true; }
                return false;
            },

_anyNeedHeal() {
    const ps = this._playersList();
    for (const p of ps) {
        if (!p || typeof p.hp !== 'number' || typeof p.maxHp !== 'number') continue;
        if (p.hp > 0 && p.hp < (p.maxHp - 0.5)) return true;
    }
    return false;
},


            _anchorPlayer() {
                const ps = this._playersList();
                for (const p of ps) { if (p && typeof p.hp === 'number' && p.hp > 0) return p; }
                return ps[0] || (typeof Game !== 'undefined' && Game ? Game.player : null) || null;
            },
            _forEachPlayer(fn) {
                const ps = this._playersList();
                for (const p of ps) { if (p) { try { fn(p); } catch (e) {} } }
            },
buyMaxHp() {
                if (!this.open) return;
                const anchor = this._anchorPlayer();
                if (!anchor) return;

                const lv = (Game.upgrades && Game.upgrades.maxHpLv) ? Game.upgrades.maxHpLv : 0;
                const cost = this.maxHpCostForLevel(lv);

                if (Game.gold < cost) {
                    createDamageText(anchor.x, anchor.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                Game.upgrades.maxHpLv = lv + 1;

                // --- BALANCE: Linear scaling +25% of BASE per level ---
                const pctPerLevel = 0.25; // +25% of base HP each level

                this._forEachPlayer((p) => {
                    // If no baseMaxHp (older save), fallback to current maxHp as base
                    if (!p.__baseMaxHp) p.__baseMaxHp = p.maxHp;

                    const base = p.__baseMaxHp;
                    const oldMax = p.maxHp;

                    // Formula: base * (1 + level * 0.25)
                    p.maxHp = Math.floor(base * (1 + (Game.upgrades.maxHpLv|0) * pctPerLevel));

                    // Keep current HP ratio (do not revive if dead)
                    if (p.hp > 0) {
                        const ratio = p.hp / oldMax;
                        p.hp = Math.floor(p.maxHp * ratio);
                    }
                });

                // Update HUD (2P aware)
                try {
                    const __pidPrevHUD = Game.__uiPid;
                    if (Game.player && Game.ui && Game.ui.updateHealth) { Game.__uiPid = 1; Game.ui.updateHealth(Game.player.hp, Game.player.maxHp); }
                    if (Game.player2 && Game.ui && Game.ui.updateHealth) { Game.__uiPid = 2; Game.ui.updateHealth(Game.player2.hp, Game.player2.maxHp); }
                    Game.__uiPid = __pidPrevHUD;
                } catch(e){}

                createDamageText(anchor.x, anchor.y - 45, "MAX HP UP!", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){};
                this.refresh();
            },
            buyDmg() {
                if (!this.open) return;
                const anchor = this._anchorPlayer();
                if (!anchor) return;

                const lv = (Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0;
                const cost = this.dmgCostForLevel(lv);

                if (Game.gold < cost) {
                    createDamageText(anchor.x, anchor.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                // Pay
                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                // Apply
                Game.upgrades.dmgLv = lv + 1;

                createDamageText(anchor.x, anchor.y - 45, "DMG +10%", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}

                this.refresh();
            },
            buyFireRate() {
                if (!this.open) return;
                const anchor = this._anchorPlayer();
                if (!anchor) return;

                const lv = (Game.upgrades && Game.upgrades.fireRateLv) ? Game.upgrades.fireRateLv : 0;
                                const frMax = getFireRateMaxLv();
                if (lv >= frMax) { createDamageText(anchor.x, anchor.y - 45, 'CD MAX', '#FFD700'); return; }
const cost = this.fireRateCostForLevel(lv);

                if (Game.gold < cost) {
                    createDamageText(anchor.x, anchor.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                // Pay
                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                // Apply
                Game.upgrades.fireRateLv = lv + 1;

                createDamageText(anchor.x, anchor.y - 45, "CD -5%", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}

                this.refresh();
            },
            buySpeed() {
                if (!this.open) return;
                const anchor = this._anchorPlayer();
                if (!anchor) return;

                const lv = (Game.upgrades && typeof Game.upgrades.speedLv === 'number') ? (Game.upgrades.speedLv|0) : 0;
                if (lv >= 12) {
                    createDamageText(anchor.x, anchor.y - 45, "MAX", "#FFD700");
                    return;
                }
                const cost = this.speedCostForLevel(lv);

                if (Game.gold < cost) {
                    createDamageText(anchor.x, anchor.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                Game.upgrades.speedLv = lv + 1;

                createDamageText(anchor.x, anchor.y - 45, "SPEED +5%", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}
                this.refresh();
            },


            buyMagnet() {
                if (!this.open) return;
                const anchor = this._anchorPlayer();
                if (!anchor) return;

                const lv = (Game.upgrades && Game.upgrades.magnetLv) ? Game.upgrades.magnetLv : 0;
                const cost = this.magnetCostForLevel(lv);
                if (Game.gold < cost) {
                    createDamageText(anchor.x, anchor.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                Game.upgrades.magnetLv = lv + 1;

                createDamageText(anchor.x, anchor.y - 45, "MAGNET +30px", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}
                this.refresh();
            },

            buyArmor() {
                if (!this.open) return;
                const anchor = this._anchorPlayer();
                if (!anchor) return;

                const lv = (Game.upgrades && Game.upgrades.armorLv) ? Game.upgrades.armorLv : 0;
                                if (lv >= 12) { createDamageText(anchor.x, anchor.y - 45, 'ARMOR MAX', '#FFD700'); return; }
const cost = this.armorCostForLevel(lv);
                if (Game.gold < cost) {
                    createDamageText(anchor.x, anchor.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                Game.upgrades.armorLv = lv + 1;

                createDamageText(anchor.x, anchor.y - 45, "ARMOR -5%", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}
                this.refresh();
            },

buyHeal() {
    if (!this.open) return;
    const anchor = this._anchorPlayer();
    if (!anchor) return;

    const cost = 200;
    if (!this._anyAlive()) return;

    // Prevent wasting gold if everyone alive is already full HP
    if (!this._anyNeedHeal()) {
        createDamageText(anchor.x, anchor.y - 45, "HP FULL", "#FFD700");
        this.refresh();
        return;
    }

    if (Game.gold < cost) {
        createDamageText(anchor.x, anchor.y - 45, "NOT ENOUGH GOLD", "#FFD700");
        return;
    }

    Game.gold -= cost;
    try { if (Game.ui && Game.ui.updateGold) Game.ui.updateGold(Game.gold); } catch(e){}

    // Heal 30% maxHP for each alive player (no revive)
    this._forEachPlayer((p) => {
        if (!p || typeof p.hp !== 'number' || typeof p.maxHp !== 'number') return;
        if (p.hp <= 0) return;
        const amt = p.maxHp * 0.3;
        if (typeof p.heal === 'function') p.heal(amt);
        else p.hp = Math.min(p.maxHp, p.hp + amt);
    });

    createDamageText(anchor.x, anchor.y - 55, "HEAL +30%", "#4CAF50");
    try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}
    this.refresh();
},



            hide() {
                this.open = false;
                this.onContinue = null;
                if (this.els.modal) this.els.modal.classList.add('hidden');
            },
            continue() {
                if (!this.open) return;
                const cb = this.onContinue;
                this.hide();
                Game.paused = false;
                // reset fps cap timer to avoid stutter after pause
                Game._fpsCapLast = performance.now();
                if (typeof cb === 'function') cb();
            }
        };
        // ================================
        // SAVE MANAGER (LocalStorage) ‚Äî STEP S1
        // Minimal: storage helpers only (no gameplay/UI changes)
        // Usage (dev console):
        //   SaveManager.save({ hello: "world" })
        //   SaveManager.load()
        //   SaveManager.hasSave()
        //   SaveManager.clear()
        // ================================
        function _saveSlotFromMode(mode){
            try{
                const players = (mode && typeof mode.players !== "undefined") ? (parseInt(mode.players,10)||1) : 1;
                const diff = (mode && mode.difficulty === "easy") ? "easy" : "hard";
                // Separate progress per-mode:
                // - hard 1P
                // - easy 1P
                // - 2P (shared regardless of difficulty toggle)
                if (players === 2) return "2p";
                return (diff === "easy" ? "easy1p" : "hard1p");
            }catch(e){
                return "hard1p";
            }
        }

        function _safeModeForSlot(){
            // Prefer live start-screen mode cfg (global), fallback to any internal cfg if available
            try { if (typeof window !== "undefined" && window.__readStartModeCfg) return window.__readStartModeCfg(); } catch(e) {}
            try { if (typeof safeReadModeCfg === "function") return safeReadModeCfg(); } catch(e) {}
            try { return (typeof Game !== "undefined" && Game && Game.startMode) ? Game.startMode : null; } catch(e){}
            return null;
        }

        function _slotFromSnap(snap){
            try{
                const m = (snap && snap.mode && typeof snap.mode === "object") ? snap.mode : _safeModeForSlot();
                return _saveSlotFromMode(m);
            }catch(e){
                return "hard1p";
            }
        }

        const SaveManager = {
            BASE_KEY: "tank_save_v1",
            VERSION: 1,
            _normSlot(slot){
                slot = (slot == null) ? "" : String(slot);
                slot = slot.trim().toLowerCase();
                // keep it simple/safe
                slot = slot.replace(/[^a-z0-9_-]/g, "");
                return slot;
            },
            _key(slot){
                slot = this._normSlot(slot);
                return slot ? (this.BASE_KEY + "::" + slot) : this.BASE_KEY;
            },
            save(data, slot) {
                try {
                    const payload = { version: this.VERSION, ts: Date.now(), data };
                    localStorage.setItem(this._key(slot), JSON.stringify(payload));
                    return true;
                } catch (e) {
                    console.warn("[Save] save failed:", e);
                    return false;
                }
            },
            _parse(raw){
                if (!raw) return null;
                const obj = JSON.parse(raw);
                if (!obj || typeof obj !== "object") return null;
                if (obj.version !== this.VERSION) {
                    console.warn("[Save] version mismatch:", obj.version, "expected", this.VERSION);
                    return null;
                }
                return obj;
            },
            _legacyRaw(){
                try{
                    // legacy key (single slot) was the base key itself (no ::slot)
                    return localStorage.getItem(this.BASE_KEY);
                }catch(e){ return null; }
            },
            _migrateLegacyIfMatches(requestedSlot){
                try{
                    const raw = this._legacyRaw();
                    if (!raw) return null;
                    const obj = this._parse(raw);
                    if (!obj) return null;
                    // Determine slot from legacy snapshot.mode if possible
                    let snap = null;
                    try{
                        const d = obj.data;
                        snap = (d && d.snap) ? d.snap : d;
                    }catch(e){}
                    const legacySlot = _slotFromSnap(snap);
                    const legacyKey = this._key(legacySlot);
                    // Move legacy save into its own computed slot once
                    if (!localStorage.getItem(legacyKey)) {
                        localStorage.setItem(legacyKey, raw);
                    }
                    // Remove legacy base key to avoid showing in all modes
                    localStorage.removeItem(this.BASE_KEY);
                    if (requestedSlot && this._normSlot(requestedSlot) === this._normSlot(legacySlot)) {
                        return obj;
                    }
                }catch(e){}
                return null;
            },
            load(slot) {
                try {
                    const raw = localStorage.getItem(this._key(slot));
                    const obj = this._parse(raw);
                    if (obj) return obj;
                    // If not found, try migrating legacy once (only when a slot is requested)
                    if (slot) {
                        const migrated = this._migrateLegacyIfMatches(slot);
                        if (migrated) return migrated;
                    }
                    return null;
                } catch (e) {
                    console.warn("[Save] load failed:", e);
                    return null;
                }
            },
            clear(slot) {
                try {
                    localStorage.removeItem(this._key(slot));
                    // If legacy save exists and belongs to this slot, remove it too
                    if (slot) {
                        const raw = this._legacyRaw();
                        if (raw) {
                            const obj = this._parse(raw);
                            if (obj) {
                                let snap = null;
                                try{
                                    const d = obj.data;
                                    snap = (d && d.snap) ? d.snap : d;
                                }catch(e){}
                                const legacySlot = _slotFromSnap(snap);
                                if (this._normSlot(legacySlot) === this._normSlot(slot)) {
                                    localStorage.removeItem(this.BASE_KEY);
                                }
                            }
                        }
                    }
                    return true;
                } catch (e) {
                    console.warn("[Save] clear failed:", e);
                    return false;
                }
            },
            hasSave(slot) {
                try {
                    if (localStorage.getItem(this._key(slot))) return true;
                    // Check legacy key only if it belongs to this slot
                    const raw = this._legacyRaw();
                    if (!raw || !slot) return false;
                    const obj = this._parse(raw);
                    if (!obj) return false;
                    let snap = null;
                    try{
                        const d = obj.data;
                        snap = (d && d.snap) ? d.snap : d;
                    }catch(e){}
                    const legacySlot = _slotFromSnap(snap);
                    return (this._normSlot(legacySlot) === this._normSlot(slot));
                } catch (e) {
                    return false;
                }
            }
        };
// ================================
// SAVE ‚Äî STEP S2 (DEV HOTKEYS)
// Minimal snapshot: wave + gold + start mode (difficulty/players/p2System)
// Hotkeys:
//   Ctrl+Shift+S  => Save minimal snapshot to localStorage
//   Ctrl+Shift+L  => Load + log snapshot (no apply yet)
// ================================
(function initSaveS2Hotkeys(){
    if (window.__saveS2HotkeysInited) return;
    window.__saveS2HotkeysInited = true;

    function isTypingTarget(){
        const ae = document.activeElement;
        if (!ae) return false;
        const tag = (ae.tagName || "").toUpperCase();
        return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || ae.isContentEditable;
    }

    function safeReadModeCfg(){
        // Prefer live reader from Start Screen
        try {
            if (typeof window.__readStartModeCfg === "function") return window.__readStartModeCfg();
        } catch(e){}
        // Fallback to persisted mode cfg
        try {
            const raw = localStorage.getItem("tankStartMode_v1");
            if (raw) return JSON.parse(raw);
        } catch(e){}
        return null;
    }

    function captureMinimal(){
        const wave = (typeof WaveManager !== "undefined" && WaveManager && typeof WaveManager.wave !== "undefined") ? (WaveManager.wave|0) : 1;
        const gold = (typeof Game !== "undefined" && Game && typeof Game.gold !== "undefined") ? Math.floor(Game.gold||0) : 0;
        const mode = safeReadModeCfg();
        // Step 5: include shop upgrade levels so reload continues correctly
        let upgrades = null;
        try{
            if (typeof Game !== "undefined" && Game && Game.upgrades && typeof Game.upgrades === "object"){
                upgrades = {
                    maxHpLv: Game.upgrades.maxHpLv|0,
                    dmgLv: Game.upgrades.dmgLv|0,
                    fireRateLv: Game.upgrades.fireRateLv|0,
                    speedLv: Game.upgrades.speedLv|0,
                    magnetLv: Game.upgrades.magnetLv|0,
                    armorLv: Game.upgrades.armorLv|0,
                };
            }
        }catch(e){}
        // Step 6: capture weapon inventories per-player (P1/P2)
let weapons = null;
try{
    if (typeof Game !== "undefined" && Game){
        const p1 = Game.player || (Game.players && Game.players[0]);
        const p2 = Game.player2 || (Game.players && Game.players[1]);
        function capP(p){
            if (!p) return null;
            const inv = Array.isArray(p.inventory) ? p.inventory.map(w => ({
                id: String((w && w.id) ? w.id : ""),
                level: (w && typeof w.level !== "undefined") ? (w.level|0) : 1
            })) : null;
            const idx = (p && typeof p.currentWeaponIndex !== "undefined") ? (p.currentWeaponIndex|0) : 0;
            return { inv, idx };
        }
        const w1 = capP(p1);
        const w2 = capP(p2);
        if (w1 || w2) weapons = { p1: w1, p2: w2 };
    }
}catch(e){}
        // Step 5.5: capture HP percent per-player (to restore HP proportionally after restoring MaxHP)
        let hpPct = null;
        try{
            if (typeof Game !== "undefined" && Game){
                const p1 = Game.player || (Game.players && Game.players[0]);
                const p2 = Game.player2 || (Game.players && Game.players[1]);
                function pctOf(p){
                    if (!p || typeof p.hp !== "number" || typeof p.maxHp !== "number" || !(p.maxHp > 0)) return null;
                    let v = p.hp / p.maxHp;
                    if (!isFinite(v)) return null;
                    v = Math.max(0, Math.min(1, v));
                    // reduce noise + save size
                    return Math.round(v * 10000) / 10000;
                }
                const a = pctOf(p1);
                const b = pctOf(p2);
                if (a !== null || b !== null) hpPct = { p1: a, p2: b };
            }
        }catch(e){}
return { wave, gold, mode, upgrades, weapons, hpPct };
    }

    // Step 5 helpers: normalize & apply upgrades (idempotent; only MaxHP needs direct stat re-apply)
    function _clampInt(v, lo, hi){
        v = (parseInt(v, 10) || 0);
        if (v < lo) v = lo;
        if (v > hi) v = hi;
        return v|0;
    }
    function normalizeUpgrades(u){
        u = (u && typeof u === "object") ? u : {};
        return {
            maxHpLv: _clampInt(u.maxHpLv, 0, 999),
            dmgLv: _clampInt(u.dmgLv, 0, 999),
            fireRateLv: _clampInt(u.fireRateLv, 0, 999),
            speedLv: _clampInt(u.speedLv, 0, 999),
            magnetLv: _clampInt(u.magnetLv, 0, 999),
            armorLv: _clampInt(u.armorLv, 0, 999),
        };
    }
    function getPlayersList(){
        try{
            if (typeof Game !== "undefined" && Game){
                if (Game.players && Array.isArray(Game.players) && Game.players.length) return Game.players.slice();
                const arr = [];
                if (Game.player) arr.push(Game.player);
                if (Game.player2) arr.push(Game.player2);
                return arr;
            }
        }catch(e){}
        return [];
    }
    function applyUpgradesFromSnapshot(snap){
        try{
            if (!snap || typeof snap !== "object" || !snap.upgrades) return;
            if (typeof Game === "undefined" || !Game) return;

            const prev = normalizeUpgrades(Game.upgrades || {});
            const next = normalizeUpgrades(snap.upgrades || {});

            if (!Game.upgrades || typeof Game.upgrades !== "object"){
                Game.upgrades = { maxHpLv:0, dmgLv:0, fireRateLv:0, speedLv:0, magnetLv:0, armorLv:0 };
            }
            // mutate to keep any potential references safe
            Game.upgrades.maxHpLv = next.maxHpLv;
            Game.upgrades.dmgLv = next.dmgLv;
            Game.upgrades.fireRateLv = next.fireRateLv;
            Game.upgrades.speedLv = next.speedLv;
            Game.upgrades.magnetLv = next.magnetLv;
            Game.upgrades.armorLv = next.armorLv;

                        // --- MaxHP (Linear): +25% of BASE per level ---
            const pctPerLevel = 0.25; // must match Shop.buyMaxHp()

            // Force update to keep save stable across builds
            if ((prev.maxHpLv|0) !== (next.maxHpLv|0) || true){
                const pls = getPlayersList();
                const SYS_BASE = { default:100, speed:85, engineer:120, juggernaut:160, mage:70 };

                for (let i=0;i<pls.length;i++){
                    const p = pls[i];
                    if (!p) continue;

                    // Resolve base HP per system (prefer __baseMaxHp from Player constructor)
                    let base = (typeof p.__baseMaxHp === "number" && p.__baseMaxHp > 0) ? p.__baseMaxHp : null;
                    if (!(base > 0)){
                        const sid = (p.systemId || p.system || p.type || 'default').toString().toLowerCase();
                        base = SYS_BASE[sid] || SYS_BASE.default;

                        // If saved from very old build and lv was 0, treat current maxHp as base
                        if ((prev.maxHpLv|0) === 0){
                            const cur = (typeof p.maxHp === "number" && p.maxHp > 0) ? p.maxHp : base;
                            base = cur;
                        }
                    }

                    base = Math.max(1, base|0);
                    p.__baseMaxHp = base;

                    // Formula: base * (1 + level * 0.25)
                    p.maxHp = Math.floor(base * (1 + (next.maxHpLv|0) * pctPerLevel));

                    if (typeof p.hp === "number") p.hp = Math.min(p.hp, p.maxHp);
                }

                // update HUD for both players
                try{
                    const __pidPrevHUD = Game.__uiPid;
                    if (Game.player && Game.ui && Game.ui.updateHealth) { Game.__uiPid = 1; Game.ui.updateHealth(Game.player.hp, Game.player.maxHp); }
                    if (Game.player2 && Game.ui && Game.ui.updateHealth) { Game.__uiPid = 2; Game.ui.updateHealth(Game.player2.hp, Game.player2.maxHp); }
                    Game.__uiPid = __pidPrevHUD;
                }catch(e){}
            }
}catch(e){
            console.warn("[Save] applyUpgradesFromSnapshot failed:", e);
        }
    }


    

// STEP 5.5: apply saved HP percent AFTER MaxHP has been restored
function applyHpPctFromSnapshot(snap){
    try{
        if (!snap || typeof snap !== "object") return;
        const hp = snap.hpPct || snap.hpPercent || null;
        if (!hp) return;
        if (typeof Game === "undefined" || !Game) return;

        const p1 = Game.player || (Game.players && Game.players[0]);
        const p2 = Game.player2 || (Game.players && Game.players[1]);

        function readPct(obj, key){
            if (!obj || typeof obj !== "object") return null;
            const v = obj[key];
            return (typeof v === "number" && isFinite(v)) ? v : null;
        }

        const pct1 = (typeof hp === "number" && isFinite(hp)) ? hp : readPct(hp, "p1");
        const pct2 = readPct(hp, "p2");

        function applyOne(p, pct){
            if (!p || pct === null || pct === undefined) return;
            if (typeof p.maxHp !== "number" || !(p.maxHp > 0)) return;
            let v = pct;
            if (!isFinite(v)) return;
            v = Math.max(0, Math.min(1, v));
            const newHp = Math.max(0, Math.min(p.maxHp, Math.round(p.maxHp * v)));
            p.hp = newHp;
        }

        applyOne(p1, pct1);
        applyOne(p2, pct2);

        // update HUD for both players (uses Game.__uiPid routing)
        try{
            const __pidPrevHUD = Game.__uiPid;
            if (Game.ui && typeof Game.ui.updateHealth === "function"){
                if (p1) { Game.__uiPid = 1; Game.ui.updateHealth(p1.hp, p1.maxHp); }
                if (p2) { Game.__uiPid = 2; Game.ui.updateHealth(p2.hp, p2.maxHp); }
            }
            Game.__uiPid = __pidPrevHUD;
        }catch(e){}
    }catch(e){
        console.warn("[Save] applyHpPctFromSnapshot failed:", e);
    }
}

// STEP 6: normalize & apply weapon inventories (per-player)
function _clampLv(v, lo, hi){
    v = (parseInt(v, 10) || 0);
    if (v < lo) v = lo;
    if (v > hi) v = hi;
    return v|0;
}
function normalizeInventory(inv){
    const out = [];
    const seen = new Set();
    if (Array.isArray(inv)){
        for (let i=0;i<inv.length;i++){
            const w = inv[i] || {};
            const id = String(w.id || "").trim();
            if (!id) continue;
            if (seen.has(id)) continue;
            let lv = _clampLv(w.level, 1, 5);
            // NORMAL must be >= 1
            if (id === "NORMAL" && lv < 1) lv = 1;
            out.push({ id, level: lv });
            seen.add(id);
        }
    }
    if (!seen.has("NORMAL")){
        out.unshift({ id: "NORMAL", level: 1 });
    }
    // If somehow empty, enforce NORMAL
    if (!out.length){
        out.push({ id: "NORMAL", level: 1 });
    }
    return out;
}
function normalizeWeaponPack(pack){
    if (!pack || typeof pack !== "object") return null;
    const inv = normalizeInventory(pack.inv);
    let idx = (parseInt(pack.idx, 10) || 0);
    if (idx < 0 || idx >= inv.length) idx = 0;
    return { inv, idx };
}
function applyWeaponsFromSnapshot(snap){
    try{
        if (!snap || typeof snap !== "object" || !snap.weapons) return;
        if (typeof Game === "undefined" || !Game) return;

        const p1 = Game.player || (Game.players && Game.players[0]);
        const p2 = Game.player2 || (Game.players && Game.players[1]);
        const w = snap.weapons || {};

        const prevPid = Game.__uiPid;
        function applyOne(pid, p, pack){
            if (!p || !pack) return;
            const np = normalizeWeaponPack(pack);
            if (!np) return;

            // Restore inventory + current weapon index
            p.inventory = np.inv.map(o => ({ id: o.id, level: o.level }));
            p.currentWeaponIndex = np.idx|0;

            // Refresh HUD for that player
            try{
                Game.__uiPid = pid;
                if (Game.ui && typeof Game.ui.updateWeaponInventory === "function"){
                    Game.ui.updateWeaponInventory(p.inventory, p.currentWeaponIndex);
                }
            }catch(e){}
        }

        applyOne(1, p1, w.p1);
        applyOne(2, p2, w.p2);

        Game.__uiPid = prevPid;
    }catch(e){
        console.warn("[Save] applyWeaponsFromSnapshot failed:", e);
    }
}
    // STEP 3: Apply minimal snapshot (wave + gold + mode) safely
    function applyMinimalSnapshot(snap){
        try{
            if (!snap || typeof snap !== "object"){
                console.warn("[Save] Invalid snapshot:", snap);
                return false;
            }

            const wave = Math.max(1, (parseInt(snap.wave, 10) || 1));
            const gold = Math.max(0, Math.floor(Number(snap.gold || 0)));

            // Persist mode for next init (and also feed Game.startMode if available)
            try{
                if (snap.mode && typeof snap.mode === "object"){
                    localStorage.setItem("tankStartMode_v1", JSON.stringify(snap.mode));
                    try { if (typeof Game !== "undefined" && Game) Game.startMode = Object.assign({}, snap.mode); } catch(e) {}
                }
            } catch(e){}

            // If we're still on start screen, start game first (no UI changes, just reuse existing startGame)
            const startEl = document.getElementById("startScreen");
            const onMenu = !!(startEl && !startEl.classList.contains("hidden"));
            if (onMenu){
                try{
                    // Prefer direct start to avoid Vietkey modal blocking dev load
                    if (typeof startGame === "function") startGame();
                    else {
                        const btn = document.getElementById("startBtn");
                        btn && btn.click();
                    }
                } catch(e){
                    console.warn("[Save] Could not start game for apply:", e);
                }
            }

            // Must have initialized player(s) to apply safely
            if (typeof Game === "undefined" || !Game || (!Game.player && !(Game.players && Game.players.length))){
                console.warn("[Save] Game not ready yet. Try load again after starting the game.");
                return false;
            }

            // Apply state to running game (minimal: wave + gold + endless flag). Keep everything else untouched for now.
            const wasActive = !!Game.active;
            try { Game.active = true; } catch(e){}
            try { Game.paused = false; } catch(e){}
            try { if (window.MAX && MAX.State) MAX.State.paused = false; } catch(e){}

            // Update gold
            try{
                Game.gold = gold;
                if (Game.ui && typeof Game.ui.updateGold === "function") Game.ui.updateGold(Game.gold);
            } catch(e){}

            // Step 5: restore shop upgrade levels (dmg/fireRate/speed/magnet/armor + re-apply MaxHP)
try{ applyUpgradesFromSnapshot(snap); }catch(e){}

// Step 5.5: restore HP percent per-player (keeps "dead" state if saved at 0%)
try{ applyHpPctFromSnapshot(snap); }catch(e){}

// Step 6: restore weapon inventories + current weapon per-player
try{ applyWeaponsFromSnapshot(snap); }catch(e){}
            // Clear volatile runtime lists to avoid mixing wave states
            try{
                const lists = ["enemies","bullets","pickups","particles","texts","coins"];
                for (let i = 0; i < lists.length; i++){
                    const k = lists[i];
                    if (Game[k] && Array.isArray(Game[k])) Game[k].length = 0;
                }
            } catch(e){}

            // Hide end screens if any
            try { const go = document.getElementById("gameOverScreen"); go && go.classList.add("hidden"); } catch(e){}
            try { const vc = document.getElementById("victoryScreen"); vc && vc.classList.add("hidden"); } catch(e){}

            // Apply wave + restart wave
            try{
                if (typeof WaveManager !== "undefined" && WaveManager){
                    WaveManager.wave = wave;
                    // Infer endless if wave v∆∞·ª£t finalWave
                    const fw = (WaveManager.finalWave|0) || 20;
                    try { Game.endlessMode = (wave > fw); } catch(e){}
                    if (typeof WaveManager.startWave === "function") WaveManager.startWave();
                    if (Game.ui && typeof Game.ui.updateWave === "function") Game.ui.updateWave(WaveManager.wave);
                }
            } catch(e){}

            // Restart loop only if it was previously stopped
            try{
                if (!wasActive && typeof loop === "function") requestAnimationFrame(loop);
            } catch(e){}

            console.log("[Save] Applied minimal snapshot -> wave:", wave, "gold:", gold, "mode:", snap.mode || null);
            return true;
        } catch(e){
            console.warn("[Save] applyMinimalSnapshot failed:", e);
            return false;
        }
    }
function logHelpOnce(){
        if (window.__saveS2HelpShown) return;
        window.__saveS2HelpShown = true;
        console.log("%c[SAVE] Dev hotkeys ready: Ctrl+Shift+S (save), Ctrl+Shift+L (load/apply)", "color:#8ff; font-weight:700");
    }
    // Delay help log a bit to avoid spamming early boot logs
    setTimeout(logHelpOnce, 500);

    window.addEventListener("keydown", function(e){
        if (isTypingTarget()) return;
        if (!e.ctrlKey || !e.shiftKey) return;

        const code = e.code || e.key;
        if (code === "KeyS"){
            e.preventDefault();
            e.stopPropagation();
            const snap = captureMinimal();
            const ok = SaveManager.save({ kind: "S2_MINIMAL", snap }, _slotFromSnap(snap));
            console.log(ok ? "[Save] Saved S2 minimal snapshot:" : "[Save] FAILED to save snapshot:", snap);
            try{ window.__updateStartSaveUI && window.__updateStartSaveUI(); }catch(e){}
        } else if (code === "KeyL"){
            e.preventDefault();
            e.stopPropagation();
            const __slot = _saveSlotFromMode(_safeModeForSlot());
            const obj = SaveManager.load(__slot);
            if (!obj){
                console.log("[Save] No save found.");
                return;
            }
            console.log("[Save] Loaded save object:", obj);

            // Step 3: Apply immediately (minimal: wave + gold + mode)
            const d = obj.data;
            const snap = (d && d.snap) ? d.snap : d;
            const ok = applyMinimalSnapshot(snap);
            if (!ok) console.log("[Save] Apply failed. (Tip: start game first, then Ctrl+Shift+L again)");
        }
    }, { capture: true });

// ================================
// SAVE ‚Äî STEP S7 (AUTOSAVE + SAVE & QUIT)
// - Autosave periodically during active gameplay (safe + throttled)
// - Autosave right before opening Shop (wave complete / cheat shop)
// - "SAVE & QUIT" button in top bar: saves snapshot then returns to menu
// ================================
    let __saveS7_lastTs = 0;

    function _isEndScreenVisible(){
        try{
            const go = document.getElementById("gameOverScreen");
            if (go && !go.classList.contains("hidden")) return true;
            const vc = document.getElementById("victoryScreen");
            if (vc && !vc.classList.contains("hidden")) return true;
        }catch(e){}
        return false;
    }

    function _isOnMenu(){
        try{
            const startEl = document.getElementById("startScreen");
            return !!(startEl && !startEl.classList.contains("hidden"));
        }catch(e){}
        return false;
    }

    function writeSave(reason){
        try{
            const snap = captureMinimal();
            const ok = SaveManager.save({ kind: "S2_MINIMAL", snap, meta: { reason: String(reason || "") } }, _slotFromSnap(snap));
            if (ok) __saveS7_lastTs = Date.now();
            try{ window.__updateStartSaveUI && window.__updateStartSaveUI(); }catch(e){}
            return ok;
        }catch(e){
            console.warn("[Save] writeSave failed:", e);
            return false;
        }
    }

    // Hook Shop.show to autosave at the safest checkpoint (between waves)
    (function wrapShopShowAutosave(){
        try{
            if (typeof Shop === "undefined" || !Shop || typeof Shop.show !== "function") return;
            if (Shop.__saveS7Wrapped) return;
            const _orig = Shop.show;
            Shop.show = function(){
                try{
                    // Do not autosave if we're still on menu / end screens (avoid overwriting good saves)
                    if (!_isOnMenu() && !_isEndScreenVisible()) writeSave("shop");
                }catch(e){}
                return _orig.apply(this, arguments);
            };
            Shop.__saveS7Wrapped = true;
        }catch(e){}
    })();

    // Periodic autosave (throttled). Checks every 5s, saves at most every 60s.
    (function initPeriodicAutosave(){
        if (window.__saveS7AutoInited) return;
        window.__saveS7AutoInited = true;

        const CHECK_MS = 5000;
        const SAVE_EVERY_MS = 60000;

        setInterval(function(){
            try{
                if (_isOnMenu()) return;
                if (_isEndScreenVisible()) return;

                if (typeof Game === "undefined" || !Game) return;
                if (!Game.active || Game.paused) return;

                // Avoid saving while Shop modal is open; we already save right before Shop.show()
                try{ if (typeof Shop !== "undefined" && Shop && Shop.open) return; }catch(e){}

                const now = Date.now();
                if (now - (__saveS7_lastTs || 0) < SAVE_EVERY_MS) return;

                writeSave("autosave");
            }catch(e){}
        }, CHECK_MS);
    })();

    // Save & Quit button
    (function bindSaveQuit(){
        function bind(){
            const btn = document.getElementById("btnSaveQuit");
            if (!btn || btn.__saveBound) return;
            btn.__saveBound = true;

            btn.addEventListener("click", function(e){
                try{ e.preventDefault(); e.stopPropagation(); }catch(err){}
                // Always do a manual save here (even if autosave just happened)
                writeSave("save_quit");
                // Return to menu using existing handler
                try{
                    if (typeof returnToMenu === "function") returnToMenu();
                    else {
                        // fallback: show start screen
                        try { document.getElementById('gameUI').classList.add('hidden'); } catch(e){}
                        try { document.getElementById('startScreen').classList.remove('hidden'); } catch(e){}
                        try{ window.BGM && window.BGM.setContext && window.BGM.setContext('menu'); }catch(e){}
                        try { Game.active = false; Game.paused = false; } catch(e){}
                        try { WaveManager.active = false; } catch(e){}
                    }
                }catch(err){
                    console.warn("[Save] Save & Quit returnToMenu failed:", err);
                }
            }, { capture: true });
        }

        if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", bind, { once:true });
        else setTimeout(bind, 0);
    })();



// ================================
// SAVE ‚Äî STEP S4 (START SCREEN CONTINUE UI)
// - Shows Continue + Clear Save on menu if local save exists
// - Continue applies minimal snapshot via applyMinimalSnapshot()
// ================================
(function initSaveS4MenuUI(){
    if (window.__saveS4MenuUIInited) return;
    window.__saveS4MenuUIInited = true;

    function getSnapFromObj(obj){
        try{
            if (!obj) return null;
            const d = obj.data;
            if (!d) return null;
            return (d && d.snap) ? d.snap : d;
        }catch(e){ return null; }
    }

    function updateStartSaveUI(){
        try{
            const cont = document.getElementById("continueBtn");
            const clr  = document.getElementById("clearSaveBtn");
            const startBtn = document.getElementById("startBtn");
            if (!cont || !clr || !startBtn || !SaveManager) return;

            if (!startBtn.dataset.origText) startBtn.dataset.origText = (startBtn.textContent || "").trim() || "TRI·ªÇN KHAI";
            const cfgSlot = _saveSlotFromMode(_safeModeForSlot());

            const has = SaveManager.hasSave(cfgSlot);

            if (has){
                const obj = SaveManager.load(cfgSlot);
                const snap = getSnapFromObj(obj);
                const w = snap && snap.wave ? (parseInt(snap.wave, 10) || 1) : null;
                cont.textContent = w ? ("TI·∫æP T·ª§C (WAVE " + w + ")") : "TI·∫æP T·ª§C";
                cont.classList.remove("hidden");
                clr.classList.remove("hidden");
                startBtn.textContent = "CH∆†I M·ªöI";
            } else {
                cont.classList.add("hidden");
                clr.classList.add("hidden");
                startBtn.textContent = startBtn.dataset.origText || "TRI·ªÇN KHAI";
            }
        }catch(e){}
    }
    window.__updateStartSaveUI = updateStartSaveUI;

    function onContinue(){
        const cfgSlot = _saveSlotFromMode(_safeModeForSlot());
        const obj = SaveManager.load(cfgSlot);
        if (!obj){
            updateStartSaveUI();
            console.log("[Save] No save found.");
            return;
        }
        const snap = getSnapFromObj(obj);
        const ok = (typeof applyMinimalSnapshot === "function") ? applyMinimalSnapshot(snap) : false;
        if (!ok) console.log("[Save] Continue failed. (Tip: try again after game starts)");
    }

    function onClear(){
        try{
            const cfgSlot = _saveSlotFromMode(_safeModeForSlot());
            if (!SaveManager.hasSave(cfgSlot)) { updateStartSaveUI(); return; }
            const label = (cfgSlot === "2p") ? "2P" : (cfgSlot === "easy1p" ? "Easy" : "Hard");
            if (!confirm("X√≥a save c·ªßa ch·∫ø ƒë·ªô " + label + "?")) return;
            SaveManager.clear(cfgSlot);
            updateStartSaveUI();
            console.log("[Save] Save cleared:", cfgSlot);
        }catch(e){}
    }
function bind(){
        const cont = document.getElementById("continueBtn");
        const clr  = document.getElementById("clearSaveBtn");
        if (cont && !cont.__saveBound){
            cont.__saveBound = true;
            cont.addEventListener("click", function(e){ e.preventDefault(); e.stopPropagation(); onContinue(); });
        }
        if (clr && !clr.__saveBound){
            clr.__saveBound = true;
            clr.addEventListener("click", function(e){ e.preventDefault(); e.stopPropagation(); onClear(); });
        }
        updateStartSaveUI();
    }

    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", bind, { once:true });
    else setTimeout(bind, 0);

    // If save changes in another tab, update UI
    window.addEventListener("storage", function(e){
        try{
            if (e && typeof e.key === 'string' && e.key.indexOf(SaveManager.BASE_KEY) === 0) updateStartSaveUI();
        }catch(err){}
    });
})();
})();





        const Game = {
            selectedSystemId: 'default',
            player: null, coins: [], gold: 0, upgrades: { maxHpLv: 0, dmgLv: 0, fireRateLv: 0, speedLv: 0, magnetLv: 0, armorLv: 0 }, enemies: [], clones: [], turrets: [], projectiles: [], particles: [], pickups: [], bossMines: [], texts: [], obstacles: [], score: 0, shake: 0, active: false,
            endlessMode: false,
            ui: {
                scoreVal: document.getElementById('scoreVal'), goldVal: document.getElementById('goldVal'), waveVal: document.getElementById('waveVal'), enemyCount: document.getElementById('enemyCount'), hpText: document.getElementById('hpText'), hpText2: document.getElementById('hpText2'), buffs: document.getElementById('buffsContainer'), healthBar: document.getElementById('healthBar'), healthBar2: document.getElementById('healthBar2'), weaponBar: document.getElementById('weaponBar'), weaponBar2: document.getElementById('weaponBar2'), ultiBar: document.getElementById('ultiBar'),
                updateScore(val) { this.scoreVal.innerText = val; }, updateGold(val) { if(this.goldVal) this.goldVal.innerText = val; }, updateWave(val) { this.waveVal.innerText = val; }, updateEnemies(val) { this.enemyCount.innerText = val; },
                updateHealth(curr, max) {
                    if (isNaN(curr)) curr = 0;
                    const pct = (max > 0) ? (curr / max) * 100 : 0;
                    const pid = (typeof Game !== 'undefined' && Game.__uiPid === 2) ? 2 : 1;
                    const hb = (pid === 2 && this.healthBar2) ? this.healthBar2 : this.healthBar;
                    const ht = (pid === 2 && this.hpText2) ? this.hpText2 : this.hpText;
                    if (!hb || !ht) return;
                    hb.style.width = `${Math.max(0, pct)}%`;
                    ht.innerText = `${Math.ceil(curr)}/${max}`;
                    if (pct < 30) hb.style.background = 'linear-gradient(90deg, #d32f2f, #f44336)';
                    else hb.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
                },
                updateUltiBar(val) { this.ultiBar.style.width = `${val}%`; },
                setShieldOverlay(on) { const pid = (typeof Game !== 'undefined' && Game.__uiPid === 2) ? 2 : 1; const el = document.getElementById(pid === 2 ? 'shieldOverlay2' : 'shieldOverlay'); if (el) el.style.display = on ? 'block' : 'none'; },
                addBuff(name, color) { const div = document.createElement('div'); div.className = 'buff-icon'; div.id = `buff-${name}`; div.style.borderColor = color; div.style.color = color; div.innerText = name; this.buffs.appendChild(div); },
                removeBuff(name) { const el = document.getElementById(`buff-${name}`); if (el) el.remove(); },
                updateWeaponInventory(inventory, currentIndex) {
                    const pid = (typeof Game !== 'undefined' && Game.__uiPid === 2) ? 2 : 1;
                    const bar = (pid === 2 && this.weaponBar2) ? this.weaponBar2 : this.weaponBar;
                    if (!bar) return;
                    bar.innerHTML = '';
                    for (let i = 0; i < inventory.length; i++) {
                        const weapon = inventory[i];
                        const slot = document.createElement('div');
                        slot.className = 'slot';
                        if (i === currentIndex) slot.classList.add('selected');
                        slot.innerHTML = `<div class="icon">${weapon.icon}</div><div style="font-size:0.6rem">${weapon.level}</div>`;
                        slot.style.borderColor = weapon.color;
                        slot.style.color = weapon.color;
                        bar.appendChild(slot);
                    }
                },
                updateTankSystemUI(systemId) {
                    const sys = getTankSystem(systemId);
                    const pid = (typeof Game !== 'undefined' && Game.__uiPid === 2) ? 2 : 1;
                    const base = (pid === 2) ? 'skill2-' : 'skill-';
                    const map = [
                        { key: 'clone',     slotId: base + 'clone' },
                        { key: 'stealth',   slotId: base + 'stealth' },
                        { key: 'vampirism', slotId: base + 'vampirism' }
                    ];
                    for (const it of map) {
                        const def = getSystemSkillDef(sys.id, it.key);
                        const slot = document.getElementById(it.slotId);
                        if (!slot || !def) continue;
                        slot.style.borderColor = def.color || '#fff';
                        slot.style.color = def.color || '#fff';
                        const icon = slot.querySelector('.icon');
                        if (icon) icon.innerHTML = def.labelHTML || it.key;
                        const keyNum = slot.querySelector('.key-number');
                        if (keyNum) {
                            // Phase 2: show correct keys by mode (Hard: Q/E/R, Easy & 2P: J/K/L) + P2 skill 1/2/3
                            const __m = (Input && Input.getMode) ? Input.getMode() : (Game.startMode || {difficulty:'hard', players:1});
                            const __hard1p = (__m && __m.players === 1 && __m.difficulty === 'hard');
                            if (pid === 2) {
                                const km2 = { clone:'1', stealth:'2', vampirism:'3' };
                                keyNum.textContent = km2[it.key] || keyNum.textContent;
                            } else {
                                const km = __hard1p ? { clone:'Q', stealth:'E', vampirism:'R' } : { clone:'J', stealth:'K', vampirism:'L' };
                                keyNum.textContent = km[it.key] || (def.key || keyNum.textContent);
                            }
                        }
                    }
                    // Optional: show system name in world-info
                    try {
                        const wi = document.getElementById('world-info');
                        if (wi && pid !== 2) wi.textContent = `Map Size: 3x | System: ${sys.name} | Bug Fixed | Cleaned`;
                    } catch(e) {}
                },
                updateSkillCooldown(skillName, lastUsed, cooldown) {
                    const pid = (typeof Game !== 'undefined' && Game.__uiPid === 2) ? 2 : 1;
                    const overlay = document.getElementById(pid === 2 ? `cd2-${skillName}` : `cd-${skillName}`);
                    const txt = document.getElementById(pid === 2 ? `cdt2-${skillName}` : `cdt-${skillName}`);
                    const remaining = Math.max(0, (lastUsed + cooldown) - Date.now());
                    const percent = (cooldown > 0) ? (remaining / cooldown) * 100 : 0;

                    if (overlay) overlay.style.height = `${percent}%`;

                    const slotEl = document.getElementById(pid === 2 ? `skill2-${skillName}` : `skill-${skillName}`);
                    if (slotEl) {
                        if (remaining <= 0) { slotEl.classList.add('ready'); slotEl.classList.remove('cooling'); }
                        else { slotEl.classList.remove('ready'); slotEl.classList.add('cooling'); }
                    }

                    if (txt) {
                        if (remaining <= 0) {
                            txt.textContent = '';
                            txt.style.opacity = 0;
                        } else {
                            txt.textContent = (remaining < 1000)
                                ? `${Math.ceil(remaining)}ms`
                                : `${(remaining / 1000).toFixed(1)}s`;
                            txt.style.opacity = 1;
                        }
                    }
                }
            },
            init() {
                WORLD_WIDTH = canvas.width * 3; WORLD_HEIGHT = canvas.height * 3;

                // Phase 4: multi-player foundation (2P local). Keep P1 as Game.player for compatibility.
                let sm = null;
                try { sm = (this.startMode && typeof this.startMode === 'object') ? this.startMode : null; } catch(e){}
                const playersCount = Math.max(1, Math.min(2, parseInt((sm && sm.players), 10) || 1));
                const p1Sys = (sm && sm.p1System) ? sm.p1System : (this.selectedSystemId || 'default');
                const p2Sys = (sm && sm.p2System) ? sm.p2System : 'default';

                this.player = new Player(p1Sys);
                this.player.pid = 1;
                this.player2 = null;
                this.players = [this.player];

                if (playersCount === 2) {
                    this.player2 = new Player(p2Sys);
                    this.player2.pid = 2;
                    // spawn slightly offset so they don't overlap
                    try {
                        this.player2.x = this.player.x + 120;
                        this.player2.y = this.player.y;
                        const r = this.player2.radius || 22;
                        this.player2.x = Math.max(r, Math.min(WORLD_WIDTH - r, this.player2.x));
                        this.player2.y = Math.max(r, Math.min(WORLD_HEIGHT - r, this.player2.y));
                    } catch(e){}
                    this.players.push(this.player2);
                }

                this.enemies = []; this.clones = []; this.turrets = []; this.projectiles = []; this.particles = []; this.pickups = []; this.texts = []; this.obstacles = []; this.score = 0; this.coins = []; this.gold = 0; this.upgrades = { maxHpLv: 0, dmgLv: 0, fireRateLv: 0, speedLv: 0, magnetLv: 0, armorLv: 0 }; this.active = true; this.paused = false;
                this.endlessMode = false;
                this.generateObstacles(); WaveManager.wave = 1; WaveManager.startWave();

                // Phase 10.2: init HUD for each player (HP/skills/weapons) with clear pid
                this.ui.updateScore(0); this.ui.updateGold(0); this.ui.updateUltiBar(0);
                const __pidPrev0 = Game.__uiPid;
                try {
                    Game.__uiPid = 1;
                    this.ui.updateHealth(this.player.hp, this.player.maxHp);
                    this.ui.updateWeaponInventory(this.player.inventory, this.player.currentWeaponIndex);
                    this.ui.updateTankSystemUI(this.player.systemId || p1Sys);

                    if (this.player2) {
                        Game.__uiPid = 2;
                        this.ui.updateHealth(this.player2.hp, this.player2.maxHp);
                        this.ui.updateWeaponInventory(this.player2.inventory, this.player2.currentWeaponIndex);
                        this.ui.updateTankSystemUI(this.player2.systemId || p2Sys);
                    }
                } finally { Game.__uiPid = __pidPrev0; }
this.ui.buffs.innerHTML = '';

                Admin.init();
                Input.init(); requestAnimationFrame(loop);
            },
            generateObstacles() {
                this.obstacles = [];
                for (let i = 0; i < 30; i++) {
                    const w = 100 + Math.random() * 150; const h = 100 + Math.random() * 150; const x = Math.random() * (WORLD_WIDTH - w); const y = Math.random() * (WORLD_HEIGHT - h); const distToCenter = Math.hypot(x - WORLD_WIDTH/2, y - WORLD_HEIGHT/2);
                    if (distToCenter < 400) continue;
                    if(Game.player && checkCircleRect({x: Game.player.x, y: Game.player.y, radius: 150}, {x, y, width: w, height: h})) continue;
                    this.obstacles.push(new Obstacle(x, y, w, h));
                }
            },
            gameOver() {
                this.active = false;
                this.paused = true;

                // Hide shop / boss UI (an to√†n)
                try { const shop = document.getElementById('shopModal'); if (shop) shop.classList.add('hidden'); } catch(e){}
                try { const bh = document.getElementById('bossHealthContainer'); if (bh) bh.style.display = 'none'; } catch(e){}

                // Update end screen values
                try { document.getElementById('finalScore').innerText = this.score; } catch(e){}
                try { document.getElementById('finalWave').innerText = WaveManager.wave; } catch(e){}

                // Update best + sync UI
                try { if (typeof MAX !== 'undefined') MAX.State.updateBest(this.score, WaveManager.wave); } catch(e){}

                // Show screen
                try { document.getElementById('gameOverScreen').classList.remove('hidden'); } catch(e){}
            },
            victory() {
                this.active = false;
                this.paused = true;

                try { const shop = document.getElementById('shopModal'); if (shop) shop.classList.add('hidden'); } catch(e){}
                try { const bh = document.getElementById('bossHealthContainer'); if (bh) bh.style.display = 'none'; } catch(e){}

                const wave = WaveManager.wave;
                try { document.getElementById('victoryWave').innerText = wave; } catch(e){}
                try { document.getElementById('victoryScore').innerText = this.score; } catch(e){}

                // Update best + show best on victory screen
                try { if (typeof MAX !== 'undefined') MAX.State.updateBest(this.score, wave); } catch(e){}
                try {
                    const bs = (typeof MAX !== 'undefined' && MAX.State && MAX.State.save) ? MAX.State.save.bestScore : 0;
                    const bw = (typeof MAX !== 'undefined' && MAX.State && MAX.State.save) ? MAX.State.save.bestWave : 0;
                    const elBS = document.getElementById('victoryBestScore');
                    const elBW = document.getElementById('victoryBestWave');
                    if (elBS) elBS.innerText = bs;
                    if (elBW) elBW.innerText = bw;
                } catch(e){}

                try { document.getElementById('victoryScreen').classList.remove('hidden'); } catch(e){}
            }
        };

        // --- 5. UTILS ---
        function checkCollision(c1, c2) { if(!c1 || !c2 || c1.__noCollide || c2.__noCollide || isNaN(c1.x) || isNaN(c2.x)) return false; const dist = Math.hypot(c1.x - c2.x, c1.y - c2.y); return dist < c1.radius + c2.radius; }
        function checkCircleRect(circle, rect) {
            if(isNaN(circle.x) || isNaN(circle.y)) return false; let testX = circle.x; let testY = circle.y;
            if (circle.x < rect.x) testX = rect.x; else if (circle.x > rect.x + rect.width) testX = rect.x + rect.width;
            if (circle.y < rect.y) testY = rect.y; else if (circle.y > rect.y + rect.height) testY = rect.y + rect.height;
            let distX = circle.x - testX; let distY = circle.y - testY; return (distX*distX + distY*distY) <= (circle.radius*circle.radius);
        }
        function isLineBlocked(x1, y1, x2, y2, obstacles) {
            const steps = 10; for(let i=0; i<=steps; i++) { const px = x1 + (x2-x1) * (i/steps); const py = y1 + (y2-y1) * (i/steps); for(let obs of obstacles) { if (px > obs.x && px < obs.x + obs.width && py > obs.y && py < obs.y + obs.height) return true; } } return false;
        }
        function hexToRgb(hex) {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : "255, 255, 255";
        }
        
        function createComplexExplosion(x, y, color) {
            if(isNaN(x) || isNaN(y)) return;
            const mult = 1;

            if (typeof MAX !== 'undefined') MAX.Audio.boom();

            // Shockwave
            Game.particles.push(new Particle(x, y, {type: 'shockwave', color: color, size: 5, maxRadius: 50, life: 0.5, decay: 0.1}));

            // Debris
            const debrisCount = Math.round(6 * mult);
            for(let i=0; i<debrisCount; i++) Game.particles.push(new Particle(x, y, {
                type: 'debris', color: color, size: 4 + Math.random()*4, life: 1.0, decay: 0.03,
                velocity: {x: (Math.random()-0.5)*10, y: (Math.random()-0.5)*10}
            }));

            // Smoke
            const smokeCount = Math.round(4 * mult);
            for(let i=0; i<smokeCount; i++) Game.particles.push(new Particle(x, y, {
                type: 'smoke', color: '#555', size: 10, life: 1.5, decay: 0.01,
                velocity: {x: (Math.random()-0.5)*2, y: (Math.random()-0.5)*2}
            }));

            // Sparks
            const sparkCount = Math.round(10 * mult);
            for(let i=0; i<sparkCount; i++) Game.particles.push(new Particle(x, y, {
                type: 'spark', color: color, size: 2, life: 0.25, decay: 0.08,
                velocity: {x: (Math.random()-0.5)*12, y: (Math.random()-0.5)*12}
            }));
        }
        function createExplosion(x, y, color, count) { // Legacy wrapper
            createComplexExplosion(x, y, color);
        }

        function createMuzzleFlash(x, y, color, count) { // Legacy wrapper
            createComplexExplosion(x, y, color);
        }
        function createMuzzleFlash(x, y, angle, color) {
            if (typeof MAX !== 'undefined') MAX.Audio.shoot();
            Game.particles.push(new Particle(x + Math.cos(angle)*10, y + Math.sin(angle)*10, {type: 'spark', color: color, size: 3, life: 0.1, decay: 0.5}));
        }
        function createDamageText(x, y, text, color) { if(isNaN(x)) return; Game.texts.push({ x, y, text, color, life: 1.0, dy: -1 }); }
        function chainLightning(startEnemy, baseDamage, count, range) {
            if (count <= 0) return;
            let nearest = null; let minDst = Infinity;
            Game.enemies.forEach(e => { if (e === startEnemy) return; const d = Math.hypot(e.x - startEnemy.x, e.y - startEnemy.y); if (d < range && d < minDst) { nearest = e; minDst = d; } });
            if (nearest) {
                nearest.hp -= baseDamage; createDamageText(nearest.x, nearest.y, Math.floor(baseDamage), '#FFEB3B');
                const steps = 10; const dx = (nearest.x - startEnemy.x) / steps; const dy = (nearest.y - startEnemy.y) / steps;
                for(let i=0; i<steps; i++) Game.particles.push(new Particle(startEnemy.x + dx*i, startEnemy.y + dy*i, {type: 'spark', color: '#FFEB3B', size: 2, life: 0.2}));
                chainLightning(nearest, baseDamage * 0.7, count - 1, range);
            }
        }

        function dropGold(x, y, amount, scatter = true) {
            if (isNaN(x) || isNaN(y)) return;
            const val = Math.max(0, Math.floor(amount || 0));
            if (val <= 0) return;
            const c = new Coin(x, y, val);
            if (scatter) { c.x += (Math.random()-0.5)*14; c.y += (Math.random()-0.5)*14; }
            Game.coins.push(c);
        }

        function dropPickup(x, y) {
            if(isNaN(x)) return;
            if (Math.random() > 0.35) return; // Tang len 35%
            const lootTable = [{id: 'HP_PACK', weight: 20}, {id: 'SHIELD', weight: 10}, {id: 'RAPID_FIRE', weight: 10}, {id: 'AMMO_NORMAL', weight: 15}, {id: 'AMMO_FIRE', weight: 10}, {id: 'AMMO_STUN', weight: 10}, {id: 'AMMO_PIERCE', weight: 10}, {id: 'AMMO_LIGHTNING', weight: 10}, {id: 'AMMO_HOMING', weight: 5}];
            const totalWeight = lootTable.reduce((sum, item) => sum + item.weight, 0);
            let random = Math.random() * totalWeight; let selectedItemKey = 'HP_PACK';
            for (const item of lootTable) { if (random < item.weight) { selectedItemKey = item.id; break; } random -= item.weight; }
            if (ITEM_TYPES[selectedItemKey]) Game.pickups.push(new Pickup(x, y, ITEM_TYPES[selectedItemKey]));
        }

        function dropBossWeapon(x, y) {
            if (isNaN(x) || isNaN(y)) return;
            const weapons = ['AMMO_FIRE', 'AMMO_STUN', 'AMMO_PIERCE', 'AMMO_LIGHTNING', 'AMMO_HOMING'];
            const key = weapons[(Math.random() * weapons.length) | 0];
            if (ITEM_TYPES[key]) {
                const px = x + (Math.random() - 0.5) * 18;
                const py = y + (Math.random() - 0.5) * 18;
                Game.pickups.push(new Pickup(px, py, ITEM_TYPES[key]));
            }
        }

        function drawMiniMap() {
            const mapSize = MINIMAP_SIZE; const mapX = canvas.width - mapSize - 20; const mapY = canvas.height - mapSize - 20;
            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(mapX, mapY, mapSize, mapSize);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(mapX, mapY, mapSize, mapSize);
            const scaleX = mapSize / WORLD_WIDTH; const scaleY = mapSize / WORLD_HEIGHT;
            if (Game.player) { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(mapX + Game.player.x * scaleX, mapY + Game.player.y * scaleY, 3, 0, Math.PI*2); ctx.fill(); }
            Game.enemies.forEach(e => { ctx.fillStyle = e.typeKey === 'BOSS' ? '#D50000' : '#f00'; const r = e.typeKey === 'BOSS' ? 6 : 2; ctx.beginPath(); ctx.arc(mapX + e.x * scaleX, mapY + e.y * scaleY, r, 0, Math.PI*2); ctx.fill(); });
            ctx.fillStyle = '#FFD700'; Game.pickups.forEach(p => { ctx.fillRect(mapX + p.x * scaleX - 1, mapY + p.y * scaleY - 1, 2, 2); });
            ctx.restore();
        }

        function loop() {
            if (!Game.active) return;
            requestAnimationFrame(loop);
            if (Game.paused) return;

            // Phase 10.1/12.1: show/hide P2 HUD + balance layout
            try {
                const __twoP = !!(Game.players && Game.players.length >= 2);
                const __hudP2 = document.getElementById('hudP2');
                if (__hudP2) __hudP2.style.display = __twoP ? 'flex' : 'none';
                const __row = document.getElementById('playersHudRow');
                if (__row) {
                    if (__twoP) __row.classList.add('twoP');
                    else __row.classList.remove('twoP');
                }
            } catch(e) {}
// FPS CAP (30..120). Note: requestAnimationFrame cannot exceed monitor refresh rate.
            if (typeof MAX !== 'undefined' && MAX.State && MAX.State.save && MAX.State.save.settings) {
                const cap = Math.max(30, Math.min(120, MAX.State.save.settings.fpsCap || 60));
                const frameMs = 1000 / cap;
                const now = performance.now();
                if (!Game._fpsCapLast) Game._fpsCapLast = now;
                if (now - Game._fpsCapLast < frameMs) return;
                Game._fpsCapLast = now;
            }

            try {
                // --- SELF-HEALING CHECK ---
                if (!Game.player || typeof Game.player.takeDamage !== 'function') {
                     console.warn("Player integrity lost. Respawning...");
                     Game.player = new Player(Game.selectedSystemId || 'default');
                }

                WaveManager.update();
                if(Game.player) Camera.update(Game.player);
                if(canvas.width > 0 && canvas.height > 0) { ctx.fillStyle = '#121212'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                ctx.save();
                let shakeX = 0, shakeY = 0; if (typeof MAX !== 'undefined' && MAX.State && MAX.State.save && !MAX.State.save.settings.shake) { Game.shake = 0; }
                if (!isNaN(Game.shake) && Game.shake > 0) { shakeX = Math.random() * Game.shake - Game.shake/2; shakeY = Math.random() * Game.shake - Game.shake/2; Game.shake *= 0.9; if(Game.shake < 0.5) Game.shake = 0; }
                if(!isNaN(Camera.x) && !isNaN(Camera.y)) { ctx.translate(-Camera.x + shakeX, -Camera.y + shakeY); }
                if (typeof drawPrettyMapBackground === 'function') {
                    drawPrettyMapBackground();
                } else {
                    ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
                    for (let y = 0; y <= WORLD_HEIGHT; y += 100) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD_WIDTH, y); ctx.stroke(); }
                    for (let x = 0; x <= WORLD_WIDTH; x += 100) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD_HEIGHT); ctx.stroke(); }
                    ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 5; ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
                }

                Game.obstacles.forEach(obs => obs.draw());
                
                // Phase 4: multi-player foundation (players[]). P1 remains Game.player (camera follow P1).
                const __m4 = (Input && Input.getMode) ? Input.getMode() : (Game.startMode || {difficulty:'hard', players:1});
                const __is2p4 = !!(__m4 && __m4.players === 2);

                // Enforce "no-mouse" for 2P (shooting via mouse is disabled; Phase 5 will add auto-shoot).
                if (__is2p4) { try { Input.mouse.down = false; } catch(e){} }

                if (Game.players && Game.players.length) {
                    const p1 = Game.players[0];
                    if (p1) { Game.__uiPid = 1; p1.update(Game.obstacles); p1.draw(); }

                    const p2 = Game.players[1];
                    if (p2) {
                        // Temporarily map Arrow keys -> WASD, and 1/2/3 -> Q/E/R for P2 update (no mouse).
                        const K = Input.keys || {};
                        const ow = K['w'], oa = K['a'], os = K['s'], od = K['d'], oq = K['q'], oe = K['e'], orr = K['r'];

                        K['w'] = !!K['arrowup'];
                        K['a'] = !!K['arrowleft'];
                        K['s'] = !!K['arrowdown'];
                        K['d'] = !!K['arrowright'];

                        K['q'] = !!K['1'];
                        K['e'] = !!K['2'];
                        K['r'] = !!K['3'];

                        // Redirect "cycle" actions for P2 (reuse Player.update's p1_* action hooks)
                        // IMPORTANT: bind original consumeAction to Input to avoid `this` loss (crash in some browsers).
                        const __ocRaw = Input.consumeAction;
                        const __oc = (typeof __ocRaw === 'function' && __ocRaw.bind) ? __ocRaw.bind(Input) : __ocRaw;
                        try {
                            if (typeof __oc === 'function') {
                                Input.consumeAction = (name) => {
                                    if (typeof __oc !== 'function') return false;
                                    if (name === 'p1_weapon_cycle') return __oc('p2_weapon_cycle');
                                    if (name === 'p1_target_cycle') return __oc('p2_target_cycle');
                                    return __oc(name);
                                };
                            }
                        } catch(e){}

                        Game.__uiPid = 2;
                        p2.update(Game.obstacles);
                        p2.draw();
                        Game.__uiPid = 1;

                        try { Input.consumeAction = __ocRaw; } catch(e){}

                        // Restore original keys
                        K['w'] = ow; K['a'] = oa; K['s'] = os; K['d'] = od; K['q'] = oq; K['e'] = oe; K['r'] = orr;

                        // Restore P1 HUD (P2 update writes to the same HUD; Phase 10 will split HUD per-player).
                        try {
                            Game.ui.updateWeaponInventory(p1.inventory, p1.currentWeaponIndex);
                            Game.ui.updateTankSystemUI(p1.systemId || Game.selectedSystemId);
                            Game.ui.updateSkillCooldown('clone', p1.skills.clone.lastUsed, getSystemSkillDef(p1.systemId, 'clone').cooldown);
                            Game.ui.updateSkillCooldown('stealth', p1.skills.stealth.lastUsed, getSystemSkillDef(p1.systemId, 'stealth').cooldown);
                            Game.ui.updateSkillCooldown('vampirism', p1.skills.vampirism.lastUsed, getSystemSkillDef(p1.systemId, 'vampirism').cooldown);
                        } catch(e){}
                    }
                } else if (Game.player) { Game.player.update(Game.obstacles); Game.player.draw(); }

                Game.clones.forEach(c => { c.update(Game.enemies, Game.obstacles, Game.projectiles); c.draw(); });
                Game.clones = Game.clones.filter(c => !c.markedForDeletion);

                // --- ENGINEER TURRETS ---
                if (Game.turrets && Game.turrets.length) {
                    Game.turrets.forEach(t => { t.update(Game.obstacles); t.draw(); });
                    Game.turrets = Game.turrets.filter(t => !t.markedForDeletion);
                }

                const __players = (Game.players && Game.players.length) ? Game.players : (Game.player ? [Game.player] : []);

                Game.pickups.forEach((p) => {
                    p.update(); p.draw();
                    if (p.markedForDeletion) return;
                    for (let __i = 0; __i < __players.length; __i++) {
                        const __pl = __players[__i];
                        if (!__pl) continue;
                        if (checkCollision(__pl, p)) {
                            if (p.config.type === 'HEAL') __pl.heal(p.config.value);
                            else if (p.config.type === 'BUFF') __pl.addBuff(p.config.buffType, p.config.duration);
                            else if (p.config.type === 'WEAPON') __pl.addWeapon(p.config.weaponId);
                            createDamageText(__pl.x, __pl.y - 30, p.config.label, p.config.color);
                            p.markedForDeletion = true;
                            break;
                        }
                    }
                });

                

                // --- COINS (Gold) ---
                Game.coins.forEach((c) => {
                    c.update(); c.draw();

                    if (!__players.length) return;

                    // Ch·ªçn ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ƒë·ªÉ h√∫t/nh·∫∑t (2P: ai g·∫ßn h∆°n th√¨ h√∫t/nh·∫∑t)
                    let __pl = null;
                    let __best = 1e18;
                    for (let __i = 0; __i < __players.length; __i++) {
                        const p = __players[__i];
                        if (!p) continue;
                        const d = Math.hypot(p.x - c.x, p.y - c.y);
                        if (d < __best) { __best = d; __pl = p; }
                    }
                    if (!__pl) return;

                    const dx = (__pl.x - c.x);
                    const dy = (__pl.y - c.y);
                    const dist = (__best || 0.0001);

                    const pr = (__pl.radius || 20);
                    const cr = (c.radius || 10);

                    // Nam ch√¢m h√∫t v√†ng: trong ph·∫°m vi +40px (ngo√†i va ch·∫°m), coin s·∫Ω bay v·ªÅ ph√≠a ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t
                    const magnetRange = pr + cr + 40 + 30 * ((Game.upgrades && Game.upgrades.magnetLv) ? Game.upgrades.magnetLv : 0);  // b·∫Øt ƒë·∫ßu h√∫t
                    const pickupRange = pr + cr + 6;   // nh·∫∑t th·∫≠t s·ª± (g·∫ßn s√°t)

                    if (dist < magnetRange) {
                        // k√©o c√†ng g·∫ßn c√†ng m·∫°nh (m∆∞·ª£t + ƒë√£ tay)
                        const tPull = 1 - (dist / magnetRange); // 0..1
                        const pull = 0.45 + tPull * 1.35;       // l·ª±c h√∫t
                        const ux = dx / dist;
                        const uy = dy / dist;

                        // tƒÉng t·ªëc v·ªÅ ph√≠a player
                        c.vx = (c.vx || 0) + ux * pull;
                        c.vy = (c.vy || 0) + uy * pull;

                        // gi·ªõi h·∫°n t·ªëc ƒë·ªô ƒë·ªÉ kh√¥ng "d·ªã" (px/frame-ish)
                        const v = Math.hypot(c.vx, c.vy);
                        const vmax = 10 + tPull * 10; // c√†ng g·∫ßn c√†ng nhanh
                        if (v > vmax) { c.vx = (c.vx / v) * vmax; c.vy = (c.vy / v) * vmax; }

                        // n·∫øu ƒë√£ ƒë·ªß g·∫ßn th√¨ nh·∫∑t
                        if (dist < pickupRange) {
                            Game.gold += c.value;
                            Game.ui.updateGold(Game.gold);
                            createDamageText(__pl.x, __pl.y - 30, `+${c.value}`, '#FFD700');
                            c.markedForDeletion = true;
                        }
                    }
                });



                // --- BOSS MINES (m√¨n n·ªï ch·∫≠m) ---
                if (Game.bossMines && Game.bossMines.length) {
                    const nowM = Date.now();
                    for (let i = Game.bossMines.length - 1; i >= 0; i--) {
                        const m = Game.bossMines[i];
                        const t = m.detonateAt - nowM;
                        const pct = Math.max(0, Math.min(1, t / (m.delay || 1500)));

                        // Draw warning (Ultra)
                        if (typeof BossFX !== 'undefined' && BossFX && typeof BossFX.drawMine === 'function') {
                            BossFX.drawMine(m, pct);
                        } else {
                            ctx.save();
                            ctx.fillStyle = 'rgba(255,152,0,0.10)';
                            ctx.beginPath(); ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2); ctx.fill();
                            ctx.strokeStyle = 'rgba(255,152,0,0.95)';
                            ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.arc(m.x, m.y, m.radius * (0.35 + 0.65 * pct), 0, Math.PI * 2); ctx.stroke();
                            ctx.restore();
                        }

                        if (nowM >= m.detonateAt) {
                            createComplexExplosion(m.x, m.y, '#FF9800');
                            if (typeof BossFX !== 'undefined' && BossFX && typeof BossFX.mineDetonateFX === 'function') BossFX.mineDetonateFX(m.x, m.y, m.radius || 80);

                            if (__players && __players.length) {
                                for (let __i = 0; __i < __players.length; __i++) {
                                    const __pl = __players[__i];
                                    if (!__pl || typeof __pl.takeDamage !== 'function') continue;
                                    const dP = Math.hypot(__pl.x - m.x, __pl.y - m.y);
                                    if (dP <= m.radius + __pl.radius) __pl.takeDamage(m.damage);
                                }
                            }
                            if (Game.clones && Game.clones.length) {
                                Game.clones.forEach(c => {
                                    const dC = Math.hypot(c.x - m.x, c.y - m.y);
                                    if (dC <= m.radius + c.radius) c.takeDamage(m.damage);
                                });
                            }

                            Game.bossMines.splice(i, 1);
                        }
                    }
                }

                // Mage Blizzard (R): ƒë·∫°n ƒë·ªãch ch·∫°m v√†o b√£o tuy·∫øt s·∫Ω tan bi·∫øn
                let mageBlizzardActive = false;
                let bzX = 0, bzY = 0, bzR = 0;
                if (Game.player && Game.player.systemId === 'mage' && Game.player.mage && Game.player.mage.blizzard && Game.player.mage.blizzard.active) {
                    const cfg = getSystemSkillDef('mage', 'vampirism') || {};
                    mageBlizzardActive = true;
                    bzX = Game.player.mage.blizzard.x;
                    bzY = Game.player.mage.blizzard.y;
                    bzR = (cfg.radius != null) ? cfg.radius : 220;
                }

                Game.projectiles.forEach(p => {
                    p.update();

                    // Remove enemy bullets inside Blizzard (outer circle)
                    if (mageBlizzardActive && !p.markedForDeletion && p.owner === 'ENEMY') {
                        const d = Math.hypot(p.x - bzX, p.y - bzY);
                        if (d <= bzR) {
                            p.markedForDeletion = true;
                            // subtle visual pop (light)
                            if (typeof createMuzzleFlash === 'function') createMuzzleFlash(p.x, p.y, 0, '#00E5FF');
                        }
                    }

                    if (!p.markedForDeletion) p.draw();
                });


                Game.enemies.forEach(e => {
                    e.update(__players, Game.clones, Game.obstacles); e.draw();
                    if (__players && __players.length) {
                        for (let __i = 0; __i < __players.length; __i++) {
                            const __pl = __players[__i];
                            if (!__pl) continue;
                            if (checkCollision(__pl, e)) {
                                if (typeof __pl.takeDamage === 'function') __pl.takeDamage(e.contactDamage || 5, { enemy: e, type: 'CONTACT' });
                                const angle = Math.atan2(e.y - __pl.y, e.x - __pl.x);
                                e.x += Math.cos(angle) * 10; e.y += Math.sin(angle) * 10;
                                break;
                            }
                        }
                    }
                    Game.clones.forEach(c => {
                        if (checkCollision(c, e)) { c.takeDamage(e.contactDamage || 5); const angle = Math.atan2(e.y - c.y, e.x - c.x); e.x += Math.cos(angle) * 10; e.y += Math.sin(angle) * 10; }
                    });
                });

                Game.projectiles.forEach(b => {
                    if (b.markedForDeletion) return;
                    let wallHit = false;
                    for(let obs of Game.obstacles) { 
                        if (checkCircleRect({x: b.x, y: b.y, radius: b.radius}, obs)) { 
                            if (b.config.special === 'PIERCE' || b.typeKey === 'PIERCING') { if(Math.random() < 0.2) createComplexExplosion(b.x, b.y, '#ccc'); } 
                            else { b.markedForDeletion = true; createComplexExplosion(b.x, b.y, '#aaa'); wallHit = true; break; }
                        } 
                    }
                    if(wallHit) return;

                    if (b.owner !== 'PLAYER') {
                        if (__players && __players.length) {
                             for (let __i = 0; __i < __players.length; __i++) {
                                 const __pl = __players[__i];
                                 if (!__pl) continue;
                                 if (checkCollision(b, __pl)) {
                                     if (typeof __pl.takeDamage === 'function') __pl.takeDamage(b.config.damage, { enemy: b.sourceEnemy || null, bullet: b, type: 'BULLET' });
                                     b.markedForDeletion = true; createComplexExplosion(b.x, b.y, '#E040FB');
                                     break;
                                 }
                             }
                        }
                        Game.clones.forEach(c => {
                            if (checkCollision(b, c)) { c.takeDamage(b.config.damage); b.markedForDeletion = true; createComplexExplosion(b.x, b.y, '#E040FB'); }
                        });
                        return;
                    }
                    Game.enemies.forEach(e => {
                        if (b.markedForDeletion) return; if (b.hitList.includes(e.id)) return;
                        if (checkCollision(b, e)) {
                            const dmgMult = (b.owner === 'PLAYER') ? (1 + 0.1 * ((Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0)) : 1;
                            const dmg = b.config.damage * dmgMult;
                            if (!b.config.noDirectHit) e.hp -= dmg;
if (b.owner === 'PLAYER' && Game.player && typeof Game.player.gainUltiCharge === 'function') Game.player.gainUltiCharge(0.5);
                            if (Game.player && Game.player.systemId === 'default' && Game.player.skills.vampirism.active && b.owner === 'PLAYER') {
                                // Lifesteal with cap per second
                                const now2 = Date.now();
                                if (!Game.player.vampHeal) Game.player.vampHeal = { windowStart: now2, healed: 0 };
                                if (now2 - Game.player.vampHeal.windowStart >= 1000) { Game.player.vampHeal.windowStart = now2; Game.player.vampHeal.healed = 0; }
                                const cap = (SKILL_CONFIG.VAMPIRISM.capPerSecond || 0);
                                const want = dmg * (SKILL_CONFIG.VAMPIRISM.leechPercent || 0);
                                const remain = (cap > 0) ? Math.max(0, cap - Game.player.vampHeal.healed) : want;
                                const healAmount = (cap > 0) ? Math.min(want, remain) : want;
                                if (healAmount > 0) { Game.player.vampHeal.healed += healAmount; Game.player.heal(healAmount); }
                            }
                            createDamageText(e.x, e.y, Math.round(dmg), b.config.color); createComplexExplosion(b.x, b.y, b.config.color);
                            if (b.config.effect) {
                                let eff = b.config.effect;
                                if (b.owner === 'PLAYER' && eff.type === 'BURN' && typeof eff.tickDamage === 'number') {
                                    eff = { ...eff, tickDamage: eff.tickDamage * dmgMult };
                                }
                                e.applyEffect(eff);
                            }
if (b.config.special === 'CHAIN') chainLightning(e, (dmg * b.config.chainDmgFactor), b.config.chainCount, b.config.chainRange);
                            if (b.config.special === 'EXPLODE') {
                                const r = b.config.explosionRadius || 120;
                                const splash = (b.config.splashFactor != null) ? b.config.splashFactor : 0.75;
                                const includeHit = !!b.config.noDirectHit;

                                // Shockwave ring (visual): v√≤ng tr√≤n lan to ra, ph√°t s√°ng m·∫°nh
                                if (b.config.shockwave) {
                                    Game.particles.push(new Particle(b.x, b.y, { type: 'shockwave', color: (b.config.shockColor || b.config.color), size: 10, maxRadius: r, decay: 0.05, glowBlur: 28, glowColor: (b.config.shockColor || b.config.color) }));
                                }

                                Game.enemies.forEach(e2 => {
                                    if (!e2 || e2.hp <= 0 || e2.markedForDeletion) return;
                                    if (!includeHit && e2 === e) return;

                                    const d2 = Math.hypot(e2.x - b.x, e2.y - b.y);
                                    if (d2 <= r) {
                                        const f = Math.max(0.08, 1 - (d2 / r)); // g·∫ßn t√¢m ƒëau nh·∫•t, xa gi·∫£m m·∫°nh
                                        const base = includeHit ? dmg : (dmg * splash);
                                        const sd = Math.round(base * f);
                                        if (sd > 0) {
                                            e2.hp -= sd;
                                            createDamageText(e2.x, e2.y, sd, b.config.color);
                                        }
                                    }
                                });

                                Game.shake = Math.max(Game.shake, 10);
                            }
                            if (b.config.special === 'PIERCE') { b.pierceCount--; b.hitList.push(e.id); if (b.pierceCount <= 0) b.markedForDeletion = true; } else { b.markedForDeletion = true; }
                        }
                    });
                });

                Game.enemies = Game.enemies.filter(e => {
                    if (e.hp <= 0) {
                        createComplexExplosion(e.x, e.y, e.config.color); Game.score += e.config.score; Game.ui.updateScore(Game.score); if (e.typeKey === 'BOSS') dropBossWeapon(e.x, e.y); else dropPickup(e.x, e.y); dropGold(e.x, e.y, (e.config && !isNaN(e.config.gold)) ? e.config.gold : 0); 
                        if(Game.player && typeof Game.player.gainUltiCharge === 'function') Game.player.gainUltiCharge(2);
                        return false;
                    } return !e.markedForDeletion;
                });
                Game.projectiles = Game.projectiles.filter(p => !p.markedForDeletion);
                Game.pickups = Game.pickups.filter(p => !p.markedForDeletion);
                Game.coins = Game.coins.filter(c => !c.markedForDeletion);
                Game.particles.forEach(p => p.update()); Game.particles.forEach(p => p.draw()); Game.particles = Game.particles.filter(p => !p.markedForDeletion);
                Game.texts.forEach((t, i) => { ctx.fillStyle = t.color; ctx.font = 'bold 16px Arial'; ctx.globalAlpha = t.life; ctx.fillText(t.text, t.x, t.y); t.y += t.dy; t.life -= 0.02; if(t.life <= 0) Game.texts.splice(i, 1); ctx.globalAlpha = 1; });
                if (typeof MAX !== 'undefined' && MAX.State.save.settings.minimap) drawMiniMap();
                ctx.restore();
                Game.ui.updateEnemies(Game.enemies.length);
                // FPS Counter
                if (typeof MAX !== 'undefined') {
                    const now = performance.now();
                    MAX.State.fps.frames++;
                    if (now - MAX.State.fps.last >= 500) {
                        MAX.State.fps.value = Math.round((MAX.State.fps.frames * 1000) / (now - MAX.State.fps.last));
                        MAX.State.fps.last = now;
                        MAX.State.fps.frames = 0;
                        const fpsVal = document.getElementById('fpsVal');
                        if (fpsVal && MAX.State.save.settings.fps) fpsVal.textContent = MAX.State.fps.value;
                    }
                }
                if (Game.players && Game.players.length) { if (Game.players.every(p => p && p.hp <= 0)) Game.gameOver(); } else { if (Game.player && Game.player.hp <= 0) Game.gameOver(); }
            } catch (err) { console.error("Game Loop Error:", err); }
        }

        
        // Load saved tank system selection (optional)
        try {
            const savedSys = localStorage.getItem('tankSystem');
            if (savedSys && document.querySelector(`input[name="tankSystem"][value="${savedSys}"]`)) {
                document.querySelector(`input[name="tankSystem"][value="${savedSys}"]`).checked = true;
                Game.selectedSystemId = savedSys;
            }
        } catch(e) {}



// ============================================
// N√ÇNG C·∫§P ƒê·ªí H·ªåA - TH√äM V√ÄO CU·ªêI FILE SCRIPT
// ƒê·∫∑t tr∆∞·ªõc d√≤ng: 
        // ============================================
        // START SCREEN 16:9 + PREVIEW + SKILL PANEL (v27)
        // ============================================
        (function(){
            const SYS_UI = {
                default: {
                    name: 'Chi·∫øn Binh',
                    accent: '#4CAF50',
                    tagline: 'B·ªÅn b·ªâ ‚Ä¢ t·ª± h·ªìi ph·ª•c theo damage (R)',
                    gfx: { body:['#2E7D32','#4CAF50','#66BB6A'], turret:['#1B5E20','#2E7D32'], glow:'rgba(76,175,80,0.35)', sigil:'#45ff74' }
                },
                speed: {
                    name: 'T·ªëc ƒê·ªô',
                    accent: '#29B6F6',
                    tagline: 'C∆° ƒë·ªông ‚Ä¢ l∆∞·ªõt li√™n t·ª•c ‚Ä¢ cu·ªìng t·ªëc',
                    gfx: { body:['#006064','#00ACC1','#4DD0E1'], turret:['#004D40','#006064'], glow:'rgba(41,182,246,0.35)', sigil:'#29B6F6' }
                },
                engineer: {
                    name: 'K·ªπ S∆∞',
                    accent: '#FF7043',
                    tagline: 'C√¥ng tr√¨nh ‚Ä¢ th√°p ph√°o ‚Ä¢ EMP',
                    // ƒë·ªïi t√¥ng sang cam/ƒë·ªìng ƒë·ªÉ kh√°c Gi√°p S·∫Øt
                    gfx: { body:['#5D4037','#8D6E63','#BCAAA4'], turret:['#3E2723','#5D4037'], glow:'rgba(255,112,67,0.35)', sigil:'#FF7043' }
                },
                juggernaut: {
                    name: 'Gi√°p S·∫Øt',
                    accent: '#FFD54F',
                    tagline: 'Tanker ‚Ä¢ gi√°p ph·∫£n v√†ng kim ‚Ä¢ ph√°o ƒë√†i',
                    gfx: { body:['#4E342E','#6D4C41','#8D6E63'], turret:['#3E2723','#4E342E'], glow:'rgba(255,213,79,0.35)', sigil:'#FFD54F' }
                },
                mage: {
                    name: 'Ph√°p S∆∞',
                    accent: '#BA68C8',
                    tagline: 'Glass cannon ‚Ä¢ b√£o tuy·∫øt cu·ªën s·∫°ch',
                    gfx: { body:['#4A148C','#7B1FA2','#BA68C8'], turret:['#311B92','#4A148C'], glow:'rgba(186,104,200,0.45)', sigil:'#BA68C8' }
                }
            };

            // M√¥ t·∫£ k·ªπ nƒÉng (text), c√≤n cooldown/duration l·∫•y t·ª´ config n·∫øu c√≥
            const SYS_SKILLS = {
                default: {
                    Q: { name:'Ph√¢n Th√¢n Chi·∫øn ƒê·∫•u', desc:'T·∫°o ph√¢n th√¢n b·∫Øn h·ªó tr·ª£. Damage t·ª´ ph√¢n th√¢n v·∫´n t√≠nh c√°c h·ªá s·ªë v√† c√≥ th·ªÉ h√∫t m√°u khi R b·∫≠t.' },
                    E: { name:'T√†ng H√¨nh', desc:'T√†ng h√¨nh trong th·ªùi gian ng·∫Øn ƒë·ªÉ n√© s√°t th∆∞∆°ng/ƒëi v√≤ng sau. (Gi·∫£m hi·ªÉn th·ªã & kh√≥ b·ªã focus).' },
                    R: { name:'H√∫t M√°u', desc:'Trong th·ªùi gian hi·ªáu l·ª±c, h·ªìi m√°u theo % damage g√¢y ra (c√≥ gi·ªõi h·∫°n h·ªìi/gi√¢y) ‚Äî ƒë√∫ng ch·∫•t Chi·∫øn Binh.' }
                },
                speed: {
                    Q: { name:'L∆∞·ªõt', desc:'L∆∞·ªõt theo h∆∞·ªõng WASD; n·∫øu ƒë·ª©ng y√™n th√¨ l∆∞·ªõt theo h∆∞·ªõng n√≤ng. Trong l√∫c l∆∞·ªõt s·∫Ω kh√¥ng b·∫Øn.' },
                    E: { name:'Phase', desc:'Mi·ªÖn th∆∞∆°ng ng·∫Øn. N·∫øu nh·∫≠n damage trong Phase th√¨ chuy·ªÉn th√†nh h·ªìi 50% m√°u theo damage.' },
                    R: { name:'Adrenaline', desc:'Cu·ªìng t·ªëc: tƒÉng damage + speed v√† gi·∫£m h·ªìi chi√™u b·∫Øn (cooldown * 0.5 ƒë√∫ng 1 l·∫ßn).' }
                },
                engineer: {
                    Q: { name:'Th√°p Ph√°o', desc:'Tri·ªáu h·ªìi th√°p ph√°o h·ªó tr·ª£ b·∫Øn. V·ªã tr√≠ ƒë·∫∑t th√°p r·∫•t quan tr·ªçng ƒë·ªÉ gi·ªØ g√≥c b·∫Øn.' },
                    E: { name:'S·ª≠a Ch·ªØa', desc:'H·ªìi ph·ª•c/ƒë·∫©y m·∫°nh kh·∫£ nƒÉng sinh t·ªìn trong giao tranh.' },
                    R: { name:'Xung EMP', desc:'Xung ƒëi·ªán m·∫°nh: l√†m tan bi·∫øn ƒë·∫°n ƒë·ªãch trong v√πng v√† ƒë√≥ng bƒÉng boss (radius x3, freeze x2).' }
                },
                juggernaut: {
                    Q: { name:'Gi√°p Ph·∫£n', desc:'B·∫≠t khi√™n v√†ng kim: gi·∫£m damage nh·∫≠n v√†o v√† ph·∫£n s√°t th∆∞∆°ng (kh√¥ng ph·∫£n boss).' },
                    E: { name:'C√∫ H√∫c', desc:'H√∫c c·ª±c l·ª±c theo h∆∞·ªõng n√≤ng s√∫ng, t·∫°o l·ª±c ƒë·∫©y v√† m·ªü giao tranh. D√πng ƒë·ªÉ √°p s√°t/tho√°t hi·ªÉm.' },
                    R: { name:'Ph√°o ƒê√†i', desc:'Chuy·ªÉn sang Siege Mode: b·∫Øn ROCKET (homing), gi·∫£m damage nh·∫≠n v√†o, rocket k·∫ø th·ª´a level v≈© kh√≠.' }
                },
                mage: {
                    Q: { name:'H·ªèa C·∫ßu', desc:'B·∫Øn h·ªèa c·∫ßu l·ªõn, bay ch·∫≠m, n·ªï AOE c√≥ falloff (g·∫ßn t√¢m ƒëau nh·∫•t) + shockwave glow.' },
                    E: { name:'D·ªãch Chuy·ªÉn', desc:'Blink: d·ªãch chuy·ªÉn nhanh, reposition ƒë·ªÉ gi·ªØ kho·∫£ng c√°ch ‚Äî ƒë√∫ng ch·∫•t ph√°p s∆∞.' },
                    R: { name:'B√£o Tuy·∫øt', desc:'C∆°n b√£o di chuy·ªÉn theo n√≤ng, kh√≥a m·ª•c ti√™u ·ªü t√¢m nh·ªè. ƒê·∫°n ƒë·ªãch bay v√†o v√πng b√£o s·∫Ω tan bi·∫øn.' }
                }
            };

            const SLOT_TO_KEY = { Q:'clone', E:'stealth', R:'vampirism' };

            function fmtMs(ms){
                if (ms == null || isNaN(ms)) return '‚Äî';
                const s = ms / 1000;
                return (s >= 10 ? s.toFixed(0) : s.toFixed(1)) + 's';
            }

            function getSkillDef(sysId, slot){
                try{
                    if (typeof getSystemSkillDef === 'function') {
                        return getSystemSkillDef(sysId, SLOT_TO_KEY[slot]) || {};
                    }
                }catch(e){}
                return {};
            }

            function setText(id, v){
                const el = document.getElementById(id);
                if (el) el.textContent = v;
            }

            function refreshProgress(){
                try{
                    const bs = (typeof MAX !== 'undefined' && MAX.Save && MAX.Save.save) ? MAX.Save.save.bestScore : 0;
                    const bw = (typeof MAX !== 'undefined' && MAX.Save && MAX.Save.save) ? MAX.Save.save.bestWave  : 0;
                    setText('startBestScore', bs ?? 0);
                    setText('startBestWave', bw ?? 0);
                }catch(e){}
            }

            function updateActiveSysItem(sysId){
                document.querySelectorAll('#systemList .sysItem').forEach(el=>{
                    el.classList.toggle('active', el.getAttribute('data-sys') === sysId);
                });
            }

            function renderSkills(sysId){
                const wrap = document.getElementById('systemDetails');
                const tag = document.getElementById('sysTagline');
                if (!wrap) return;

                const ui = SYS_UI[sysId] || SYS_UI.default;
                if (tag) tag.textContent = `${ui.name} ‚Äî ${ui.tagline}`;

                const skillText = SYS_SKILLS[sysId] || SYS_SKILLS.default;

                const slots = ['Q','E','R'];
                const cards = slots.map(slot=>{
                    const def = getSkillDef(sysId, slot);
                    const name = (skillText[slot] && skillText[slot].name) ? skillText[slot].name : slot;
                    const desc = (skillText[slot] && skillText[slot].desc) ? skillText[slot].desc : '';
                    const cd = (def.cooldown != null) ? fmtMs(def.cooldown) : '‚Äî';
                    const dur = (def.duration != null) ? fmtMs(def.duration) : (def.time != null ? fmtMs(def.time) : '‚Äî');

                    return `
                        <div class="skillCard">
                            <div class="skillKey" style="background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.18); box-shadow: 0 0 14px ${ui.gfx.glow};">${slot}</div>
                            <div>
                                <div class="skillName">${name}</div>
                                <div class="skillDesc">${desc}</div>
                                <div class="skillStats">Th·ªùi l∆∞·ª£ng: <b>${dur}</b> ‚Ä¢ H·ªìi chi√™u: <b>${cd}</b></div>
                            </div>
                        </div>
                    `;
                }).join('');

                wrap.innerHTML = cards;
            }

            // ==== Preview drawing (lightweight) ====
            function rr(ctx, x, y, w, h, r){
                if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); return; }
                r = Math.min(r, w/2, h/2);
                ctx.beginPath();
                ctx.moveTo(x+r, y);
                ctx.lineTo(x+w-r, y);
                ctx.quadraticCurveTo(x+w, y, x+w, y+r);
                ctx.lineTo(x+w, y+h-r);
                ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
                ctx.lineTo(x+r, y+h);
                ctx.quadraticCurveTo(x, y+h, x, y+h-r);
                ctx.lineTo(x, y+r);
                ctx.quadraticCurveTo(x, y, x+r, y);
            }

            function drawTank(ctx, sysId, t, scale){
                const ui = SYS_UI[sysId] || SYS_UI.default;
                const g = ui.gfx;
                const w = ctx.canvas.width, h = ctx.canvas.height;

                ctx.clearRect(0,0,w,h);

                // background subtle grid (cheap)
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                const step = 40 * scale;
                for (let x = (t*10)%step; x < w; x += step){
                    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
                }
                for (let y = (t*12)%step; y < h; y += step){
                    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
                }
                ctx.restore();

                const cx = w*0.5, cy = h*0.52;

                // sigil ring
                ctx.save();
                ctx.translate(cx, cy+22*scale);
                const pulse = 0.7 + Math.sin(t*2.2)*0.15;
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = g.sigil;
                ctx.lineWidth = 3*scale;
                ctx.beginPath();
                ctx.arc(0,0,58*scale + Math.sin(t*1.5)*2*scale, 0, Math.PI*2);
                ctx.stroke();

                ctx.globalAlpha = 0.20 * pulse;
                ctx.fillStyle = g.sigil;
                ctx.beginPath();
                ctx.arc(0,0,62*scale, 0, Math.PI*2);
                ctx.fill();

                // simple emblem in circle (per system)
                ctx.globalAlpha = 0.85;
                ctx.fillStyle = 'rgba(0,0,0,0.45)';
                ctx.beginPath();
                ctx.arc(0,0,26*scale,0,Math.PI*2);
                ctx.fill();

                ctx.fillStyle = g.sigil;
                ctx.font = `900 ${Math.round(18*scale)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const emblem = (sysId==='speed')?'‚ö°':(sysId==='engineer')?'üõ†':(sysId==='juggernaut')?'üõ°':(sysId==='mage')?'‚ú¶':'‚úö';
                ctx.fillText(emblem, 0, 1*scale);

                ctx.restore();

                // tank
                ctx.save();
                ctx.translate(cx, cy);

                // glow
                ctx.shadowBlur = 22*scale;
                ctx.shadowColor = g.glow;

                // tracks
                ctx.fillStyle = 'rgba(0,0,0,0.65)';
                rr(ctx, -58*scale, -40*scale, 16*scale, 80*scale, 6*scale); ctx.fill();
                rr(ctx,  42*scale, -40*scale, 16*scale, 80*scale, 6*scale); ctx.fill();

                ctx.shadowBlur = 0;

                // body gradient
                const grad = ctx.createRadialGradient(-10*scale, -12*scale, 0, 0, 0, 70*scale);
                grad.addColorStop(0, g.body[2] || g.body[1] || g.body[0]);
                grad.addColorStop(0.55, g.body[1] || g.body[0]);
                grad.addColorStop(1, g.body[0]);
                ctx.fillStyle = grad;
                rr(ctx, -46*scale, -46*scale, 92*scale, 92*scale, 14*scale);
                ctx.fill();

                // highlight
                ctx.fillStyle = 'rgba(255,255,255,0.14)';
                rr(ctx, -38*scale, -38*scale, 44*scale, 16*scale, 8*scale);
                ctx.fill();

                // turret rotate slow
                const ang = Math.sin(t*0.9) * 0.35;
                ctx.rotate(ang);

                const tGrad = ctx.createRadialGradient(-8*scale, -8*scale, 0, 0, 0, 40*scale);
                tGrad.addColorStop(0, g.turret[1] || g.turret[0]);
                tGrad.addColorStop(1, g.turret[0]);
                ctx.fillStyle = tGrad;
                ctx.beginPath(); ctx.arc(0,0,30*scale,0,Math.PI*2); ctx.fill();

                // barrel
                const bGrad = ctx.createLinearGradient(0, -10*scale, 0, 10*scale);
                bGrad.addColorStop(0, '#777');
                bGrad.addColorStop(0.5, '#999');
                bGrad.addColorStop(1, '#555');
                ctx.fillStyle = bGrad;
                rr(ctx, 0, -10*scale, 74*scale, 20*scale, 8*scale);
                ctx.fill();

                // barrel tip
                ctx.fillStyle = g.sigil;
                rr(ctx, 64*scale, -12*scale, 14*scale, 24*scale, 6*scale);
                ctx.fill();

                // system-specific small details
                ctx.save();
                ctx.rotate(-ang);
                if (sysId === 'engineer'){
                    // bolts
                    ctx.fillStyle = 'rgba(255,112,67,0.9)';
                    for (let i=0;i<6;i++){
                        const a = i*Math.PI*2/6 + t*0.5;
                        ctx.beginPath();
                        ctx.arc(Math.cos(a)*44*scale, Math.sin(a)*44*scale, 2.3*scale, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
                if (sysId === 'juggernaut'){
                    // gold plating lines
                    ctx.strokeStyle = 'rgba(255,213,79,0.9)';
                    ctx.lineWidth = 2*scale;
                    ctx.beginPath();
                    ctx.moveTo(-46*scale, 0); ctx.lineTo(46*scale, 0);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, -46*scale); ctx.lineTo(0, 46*scale);
                    ctx.stroke();
                }
                if (sysId === 'mage'){
                    // arcane sparkles
                    ctx.fillStyle = 'rgba(186,104,200,0.95)';
                    for (let i=0;i<8;i++){
                        const a = i*Math.PI*2/8 + t*1.1;
                        const rr2 = 52*scale + Math.sin(t*2+i)*3*scale;
                        ctx.beginPath();
                        ctx.arc(Math.cos(a)*rr2, Math.sin(a)*rr2, 2.4*scale, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
                if (sysId === 'speed'){
                    // streaks
                    ctx.globalAlpha = 0.25;
                    ctx.strokeStyle = 'rgba(41,182,246,0.95)';
                    ctx.lineWidth = 6*scale;
                    ctx.lineCap = 'round';
                    for (let i=0;i<4;i++){
                        ctx.beginPath();
                        ctx.moveTo(-70*scale - i*18*scale, -18*scale + i*12*scale);
                        ctx.lineTo(-10*scale - i*12*scale, -30*scale + i*10*scale);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                ctx.restore();

                ctx.restore();
            }

            function drawMini(sysId){
                const el = document.querySelector(`canvas.sysMini[data-sys="${sysId}"]`);
                if (!el) return;
                const ctx = el.getContext('2d');
                if (!ctx) return;
                drawTank(ctx, sysId, 0.0, 0.45);
            }

            function drawAllMinis(){
                document.querySelectorAll('canvas.sysMini').forEach(c=>{
                    const sysId = c.getAttribute('data-sys');
                    const ctx = c.getContext('2d');
                    if (ctx) drawTank(ctx, sysId, 0.0, 0.45);
                });
            }

            function getSelectedSys(){
                const sel = document.querySelector('input[name="tankSystem"]:checked');
                return (sel && sel.value) ? sel.value : 'default';
            }

            function updateUI(){
                const sysId = getSelectedSys();
                updateActiveSysItem(sysId);
                renderSkills(sysId);
                refreshProgress();
            }

            function init(){
                const start = document.getElementById('startScreen');
                const pv = document.getElementById('systemPreview');
                if (!start || !pv) return;
// Keep preview canvas backing-store in sync with its CSS box (no stretch)
const fitPreviewCanvas = () => {
    const rect = pv.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width || 0));
    const h = Math.max(1, Math.round(rect.height || 0));
    if (pv.width !== w || pv.height !== h) {
        pv.width = w;
        pv.height = h;
    }
};

// Throttle resize work to 1x / animation frame
let __pvFitQueued = false;
const requestFitPreview = () => {
    if (__pvFitQueued) return;
    __pvFitQueued = true;
    requestAnimationFrame(() => {
        __pvFitQueued = false;
        try { if (start.classList.contains('hidden')) return; } catch (e) {}
        try { fitPreviewCanvas(); } catch (e) {}
    });
};

// First fit after layout
requestFitPreview();

// Best option: observe actual element size changes (flex, scrollbars, font load, etc.)
let __pvRO = null;
try {
    if (typeof ResizeObserver !== 'undefined') {
        __pvRO = new ResizeObserver(() => requestFitPreview());
        __pvRO.observe(pv);
        if (pv.parentElement) __pvRO.observe(pv.parentElement);
    }
} catch (e) {}

// Fallback
window.addEventListener('resize', requestFitPreview);
// mark active on click for whole label (even if input not changed)
                document.querySelectorAll('#systemList .sysItem').forEach(item=>{
                    item.addEventListener('click', ()=>{
                        const inp = item.querySelector('input[type="radio"]');
                        if (inp) { inp.checked = true; updateUI(); }
                    });
                });

                document.querySelectorAll('input[name="tankSystem"]').forEach(r=>{
                    r.addEventListener('change', updateUI);
                });

                drawAllMinis();
                updateUI();

                // lightweight animation loop for preview only
                const pvCtx = pv.getContext('2d');
                let running = true;
                let __pvLastFit = 0;
                const stop = ()=>{ running = false; };
                const btn = document.getElementById('startBtn');
                btn && btn.addEventListener('click', stop);

                function loop(){
                    if (!running) return;
                    // stop when screen hidden
                    if (start.classList.contains('hidden')) return;
                    const sysId = getSelectedSys();
                    const t = (Date.now() % 100000) / 1000;
                    // Occasional safety-fit (in case CSS changes without a window resize)
                    if ((Date.now() - __pvLastFit) > 600) { __pvLastFit = Date.now(); requestFitPreview(); }
                    if (pvCtx) drawTank(pvCtx, sysId, t, 1);
                    requestAnimationFrame(loop);
                }
                requestAnimationFrame(loop);

                // refresh progress when user opens menu again
                try{
                    const _ret = window.returnToMenu;
                    // don't override; just refresh when menu shown (best effort)
                }catch(e){}
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();








// ============================================

// Polyfill roundRect (cho browser c≈©)
(() => {
  try {
    if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        r = (typeof r === 'number') ? r : 0;
        r = Math.max(0, r);
        const rr = Math.min(r, Math.abs(w) / 2, Math.abs(h) / 2);
        this.moveTo(x + rr, y);
        this.arcTo(x + w, y, x + w, y + h, rr);
        this.arcTo(x + w, y + h, x, y + h, rr);
        this.arcTo(x, y + h, x, y, rr);
        this.arcTo(x, y, x + w, y, rr);
        this.closePath();
        return this;
      };
    }
  } catch (e) {}
})();

// ===== C·∫§U H√åNH ƒê·ªí H·ªåA =====
const GFX = {
    // Theo h·ªá xe (systemId). L∆∞u √Ω: h·ªá Chi·∫øn Binh l√† 'default'.
    SYSTEMS: {
        // CHI·∫æN BINH (default/warrior)
        default: {
            body: ['#1B5E20', '#2E7D32', '#66BB6A'],
            turret: ['#0E3B14', '#1B5E20'],
            glow: 'rgba(76, 175, 80, 0.32)',
            accent: '#FF5252',
            track: '#121212',
            trackDetail: '#2b2b2b'
        },
        warrior: {
            body: ['#1B5E20', '#2E7D32', '#66BB6A'],
            turret: ['#0E3B14', '#1B5E20'],
            glow: 'rgba(76, 175, 80, 0.32)',
            accent: '#FF5252',
            track: '#121212',
            trackDetail: '#2b2b2b'
        },
        // T·ªêC ƒê·ªò (speed)
        speed: {
            body: ['#004D40', '#006064', '#26C6DA'],
            turret: ['#00363A', '#004D40'],
            glow: 'rgba(0, 229, 255, 0.28)',
            accent: '#00E5FF',
            track: '#071416',
            trackDetail: '#12343a'
        },
        // K·ª∏ S∆Ø (engineer)
        engineer: {
            body: ['#263238', '#455A64', '#90A4AE'],
            turret: ['#11191c', '#263238'],
            glow: 'rgba(255, 171, 0, 0.20)',
            accent: '#FFAB00',
            sigilAccent: '#00E676',
            track: '#101214',
            trackDetail: '#2a2f33'
        },
        // GI√ÅP S·∫ÆT (juggernaut)
        juggernaut: {
            body: ['#212121', '#37474F', '#546E7A'],
            turret: ['#161616', '#212121'],
            glow: 'rgba(255, 193, 7, 0.20)',
            accent: '#FFD54F',
            sigilAccent: '#B0BEC5',
            sigilSecondary: '#FFD54F',
            track: '#0f0f0f',
            trackDetail: '#2a2a2a'
        },
        // PH√ÅP S∆Ø (mage)
        mage: {
            body: ['#1A237E', '#283593', '#7986CB'],
            turret: ['#0D1454', '#1A237E'],
            glow: 'rgba(0, 229, 255, 0.18)',
            accent: '#B3E5FC',
            track: '#0b0f16',
            trackDetail: '#1a2436'
        }
    },

    // Backward-compat: gi·ªØ PLAYER (m·∫∑c ƒë·ªãnh) ƒë·ªÉ c√°c patch c≈© kh√¥ng g√£y
    PLAYER: {
        body: ['#1B5E20', '#2E7D32', '#66BB6A'],
        turret: ['#0E3B14', '#1B5E20'],
        glow: 'rgba(76, 175, 80, 0.32)',
        accent: '#FF5252',
        track: '#121212',
        trackDetail: '#2b2b2b'
    },

    CLONE: {
        body: ['#0277BD', '#29B6F6', '#4FC3F7'],
        turret: ['#01579B', '#0277BD'],
        glow: 'rgba(41, 182, 246, 0.4)',
        accent: '#81D4FA',
        track: '#101820',
        trackDetail: '#1b2b3a'
    },
    ENEMIES: {
        RED: { body: ['#C62828', '#E53935', '#EF5350'], glow: 'rgba(229, 57, 53, 0.4)' },
        BLACK: { body: ['#212121', '#424242', '#616161'], outline: '#757575', glow: 'rgba(97, 97, 97, 0.4)' },
        YELLOW: { body: ['#F9A825', '#FFD600', '#FFEB3B'], glow: 'rgba(255, 214, 0, 0.5)' },
        PURPLE: { body: ['#6A1B9A', '#9C27B0', '#BA68C8'], glow: 'rgba(156, 39, 176, 0.4)' },
        BOSS: { body: ['#B71C1C', '#D32F2F', '#F44336'], core: ['#FF6F00', '#FF8F00', '#FFA000'], glow: 'rgba(244, 67, 54, 0.5)' }
    }
};

// ===== H√ÄM T·∫†O GRADIENT =====
function createTankGradient(x, y, radius, colors) {
    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius * 1.5);
    gradient.addColorStop(0, colors[2] || colors[1] || colors[0]);
    gradient.addColorStop(0.5, colors[1] || colors[0]);
    gradient.addColorStop(1, colors[0]);
    return gradient;
}

// ===== H√ÄM M√ÄU AN TO√ÄN (tr√°nh l·ªói addColorStop v·ªõi m√†u hex sai) =====
function __normHex6(c) {
    if (typeof c !== 'string') return null;
    const s = c.trim();
    if (s[0] !== '#') return null;
    const raw = s.slice(1);
    if (/^[0-9a-fA-F]{3}$/.test(raw)) {
        return '#' + raw.split('').map(ch => ch + ch).join('');
    }
    if (/^[0-9a-fA-F]{6}$/.test(raw)) return '#' + raw;
    if (/^[0-9a-fA-F]{8}$/.test(raw)) return '#' + raw.slice(0, 6); // drop alpha
    return null;
}

function __colorWithAlpha(color, a) {
    a = Math.max(0, Math.min(1, a));
    if (typeof color !== 'string') return `rgba(255,255,255,${a})`;
    const s = color.trim();

    // rgb/rgba -> √©p alpha
    const m = s.match(/^rgba?\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+))?\s*\)$/i);
    if (m) return `rgba(${m[1]}, ${m[2]}, ${m[3]}, ${a})`;

    const h = __normHex6(s);
    if (h) {
        const r = parseInt(h.slice(1, 3), 16);
        const g = parseInt(h.slice(3, 5), 16);
        const b = parseInt(h.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${a})`;
    }

    // named colors/others: best-effort (kh√¥ng √©p alpha)
    return s;
}

function __safeColor(color, fallback) {
    fallback = fallback || '#FFFFFF';
    if (typeof color !== 'string') return fallback;
    const s = color.trim();

    // Hex: ch·ªâ nh·∫≠n #RGB/#RRGGBB/#RRGGBBAA; sai -> fallback
    if (s[0] === '#') {
        const h = __normHex6(s);
        return h || fallback;
    }

    // rgb/rgba/transparent ho·∫∑c c√°c format h·ª£p l·ªá kh√°c
    if (s.startsWith('rgb') || s === 'transparent') return s;

    // named colors: best-effort
    return s || fallback;
}


// ===== JUGGERNAUT FX CACHE (Q shield + E ram) =====
const __JUGGER_FX = { shield: new Map(), ramTrail: null, ramTrailDpr: 0 };

function __getJuggerShieldSprite(baseR, dpr) {
    try {
        dpr = (dpr || 1);
        const key = Math.round(baseR) + '@' + dpr;
        if (__JUGGER_FX.shield.has(key)) return __JUGGER_FX.shield.get(key);

        const pad = 24;
        const size = Math.ceil((baseR + pad) * 2 * dpr);
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const g = c.getContext('2d');
        g.clearRect(0, 0, size, size);
        g.save();
        g.translate(size / 2, size / 2);
        g.scale(dpr, dpr);

        const TAU = Math.PI * 2;
        // metal gradient for plates
        const rg = g.createRadialGradient(-baseR * 0.25, -baseR * 0.25, 0, 0, 0, baseR * 1.35);
        rg.addColorStop(0, 'rgba(255, 244, 214, 0.95)');
        rg.addColorStop(0.35, 'rgba(255, 213, 79, 0.95)');
        rg.addColorStop(0.75, 'rgba(255, 152, 0, 0.75)');
        rg.addColorStop(1, 'rgba(120, 70, 0, 0.55)');

        // segmented ring (armor plates)
        const segs = 12;
        for (let i = 0; i < segs; i++) {
            const a0 = (i / segs) * TAU;
            const a1 = a0 + (TAU / segs) * 0.78;
            g.strokeStyle = rg;
            g.lineCap = 'round';
            g.lineWidth = 7.5;
            g.beginPath();
            g.arc(0, 0, baseR, a0, a1);
            g.stroke();

            // plate rivet
            const am = (a0 + a1) * 0.5;
            const rx = Math.cos(am) * (baseR - 2);
            const ry = Math.sin(am) * (baseR - 2);
            g.fillStyle = 'rgba(0,0,0,0.35)';
            g.beginPath();
            g.arc(rx + 1, ry + 1, 2.8, 0, TAU);
            g.fill();
            g.fillStyle = 'rgba(255, 248, 225, 0.85)';
            g.beginPath();
            g.arc(rx, ry, 2.5, 0, TAU);
            g.fill();
        }

        // inner ring
        g.strokeStyle = 'rgba(255, 248, 225, 0.35)';
        g.lineWidth = 2;
        g.beginPath();
        g.arc(0, 0, baseR - 9, 0, TAU);
        g.stroke();

        // outer rim
        g.strokeStyle = 'rgba(0,0,0,0.25)';
        g.lineWidth = 3;
        g.beginPath();
        g.arc(0, 0, baseR + 7, 0, TAU);
        g.stroke();

        // spikes (symbolize reflect)
        g.fillStyle = 'rgba(255, 193, 7, 0.65)';
        g.strokeStyle = 'rgba(0,0,0,0.25)';
        g.lineWidth = 1.5;
        for (let i = 0; i < 4; i++) {
            const ang = i * (Math.PI / 2) + Math.PI / 4;
            const sx = Math.cos(ang) * (baseR + 5);
            const sy = Math.sin(ang) * (baseR + 5);
            const nx = Math.cos(ang);
            const ny = Math.sin(ang);
            const px = -ny;
            const py = nx;
            g.beginPath();
            g.moveTo(sx + px * 4, sy + py * 4);
            g.lineTo(sx + nx * 13, sy + ny * 13);
            g.lineTo(sx - px * 4, sy - py * 4);
            g.closePath();
            g.fill();
            g.stroke();
        }

        // subtle notch ticks
        g.globalAlpha = 0.22;
        g.strokeStyle = 'rgba(255, 235, 59, 0.9)';
        g.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
            const ang = i * (TAU / 8);
            const x0 = Math.cos(ang) * (baseR - 2);
            const y0 = Math.sin(ang) * (baseR - 2);
            const x1 = Math.cos(ang) * (baseR + 10);
            const y1 = Math.sin(ang) * (baseR + 10);
            g.beginPath();
            g.moveTo(x0, y0);
            g.lineTo(x1, y1);
            g.stroke();
        }
        g.globalAlpha = 1;

        g.restore();

        const out = { c, baseR, size: size / dpr };
        __JUGGER_FX.shield.set(key, out);
        return out;
    } catch (e) {
        return null;
    }
}

function __getJuggerRamTrailSprite(dpr) {
    dpr = (dpr || 1);
    if (__JUGGER_FX.ramTrail && __JUGGER_FX.ramTrailDpr === dpr) return __JUGGER_FX.ramTrail;

    const w = Math.round(260 * dpr);
    const h = Math.round(90 * dpr);
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const g = c.getContext('2d');
    g.clearRect(0, 0, w, h);

    // outer glow ribbon
    let lg = g.createLinearGradient(0, 0, w, 0);
    lg.addColorStop(0, 'rgba(255,193,7,0)');
    lg.addColorStop(0.20, 'rgba(255,193,7,0.22)');
    lg.addColorStop(0.55, 'rgba(255,152,0,0.18)');
    lg.addColorStop(1, 'rgba(255,152,0,0)');
    g.fillStyle = lg;
    g.beginPath();
    g.ellipse(w * 0.58, h * 0.5, w * 0.58, h * 0.34, 0, 0, Math.PI * 2);
    g.fill();

    // core streak
    lg = g.createLinearGradient(0, 0, w, 0);
    lg.addColorStop(0, 'rgba(255,255,255,0)');
    lg.addColorStop(0.18, 'rgba(255,255,255,0.22)');
    lg.addColorStop(0.55, 'rgba(255,235,59,0.18)');
    lg.addColorStop(1, 'rgba(255,235,59,0)');
    g.fillStyle = lg;
    g.beginPath();
    g.ellipse(w * 0.62, h * 0.5, w * 0.56, h * 0.12, 0, 0, Math.PI * 2);
    g.fill();

    __JUGGER_FX.ramTrail = { c, w: w / dpr, h: h / dpr };
    __JUGGER_FX.ramTrailDpr = dpr;
    return __JUGGER_FX.ramTrail;
}



// ===== BLIZZARD FX CACHE (Mage R) =====
const __BLZ_FX = { fogA: new Map(), fogB: new Map(), wall: new Map(), streak: null, streakDpr: 0 };

function __getBlizzardStreakSprite(dpr) {
    dpr = (dpr || 1);
    if (__BLZ_FX.streak && __BLZ_FX.streakDpr === dpr) return __BLZ_FX.streak;

    const w = Math.round(140 * dpr);
    const h = Math.round(22 * dpr);
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const g = c.getContext('2d');
    g.clearRect(0, 0, w, h);

    // long streak gradient (transparent -> white/blue -> transparent)
    const lg = g.createLinearGradient(0, 0, w, 0);
    lg.addColorStop(0, 'rgba(255,255,255,0)');
    lg.addColorStop(0.12, 'rgba(255,255,255,0.30)');
    lg.addColorStop(0.35, 'rgba(255,255,255,0.55)');
    lg.addColorStop(0.55, 'rgba(0,229,255,0.35)');
    lg.addColorStop(0.75, 'rgba(255,255,255,0.35)');
    lg.addColorStop(1, 'rgba(255,255,255,0)');

    g.fillStyle = lg;
    g.beginPath();
    g.ellipse(w * 0.55, h * 0.5, w * 0.52, h * 0.22, 0, 0, Math.PI * 2);
    g.fill();

    // thin core line
    g.globalAlpha = 0.65;
    const lg2 = g.createLinearGradient(0, 0, w, 0);
    lg2.addColorStop(0, 'rgba(255,255,255,0)');
    lg2.addColorStop(0.20, 'rgba(255,255,255,0.55)');
    lg2.addColorStop(0.55, 'rgba(255,255,255,0.45)');
    lg2.addColorStop(1, 'rgba(255,255,255,0)');
    g.strokeStyle = lg2;
    g.lineWidth = Math.max(1, 2 * dpr);
    g.lineCap = 'round';
    g.beginPath();
    g.moveTo(w * 0.08, h * 0.5);
    g.lineTo(w * 0.94, h * 0.5);
    g.stroke();
    g.globalAlpha = 1;

    __BLZ_FX.streak = { c, w: w / dpr, h: h / dpr };
    __BLZ_FX.streakDpr = dpr;
    return __BLZ_FX.streak;
}

function __getBlizzardFogSprite(radius, variant, dpr) {
    try {
        dpr = (dpr || 1);
        const key = Math.round(radius) + '_v' + (variant || 0) + '@' + dpr;
        const map = (variant === 1) ? __BLZ_FX.fogB : __BLZ_FX.fogA;
        if (map.has(key)) return map.get(key);

        const pad = radius * 0.42 + 34;
        const R = radius + pad;
        const size = Math.ceil((R * 2) * dpr);
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const g = c.getContext('2d');
        g.clearRect(0, 0, size, size);

        g.save();
        g.translate(size / 2, size / 2);
        g.scale(dpr, dpr);

        const TAU = Math.PI * 2;

        // base mist
        const rg = g.createRadialGradient(-radius * 0.22, -radius * 0.22, 0, 0, 0, R);
        if (variant === 1) {
            rg.addColorStop(0, 'rgba(255,255,255,0.10)');
            rg.addColorStop(0.35, 'rgba(255,255,255,0.07)');
            rg.addColorStop(0.75, 'rgba(0,229,255,0.045)');
        } else {
            rg.addColorStop(0, 'rgba(0,229,255,0.08)');
            rg.addColorStop(0.40, 'rgba(255,255,255,0.06)');
            rg.addColorStop(0.80, 'rgba(255,255,255,0.03)');
        }
        rg.addColorStop(1, 'rgba(0,0,0,0)');

        g.fillStyle = rg;
        g.beginPath();
        g.arc(0, 0, R, 0, TAU);
        g.fill();

        // swirl arcs (painted once)
        g.lineCap = 'round';
        g.strokeStyle = (variant === 1) ? 'rgba(255,255,255,0.065)' : 'rgba(255,255,255,0.055)';
        g.lineWidth = (variant === 1) ? 2.1 : 1.6;
        const arcs = 30;
        for (let i = 0; i < arcs; i++) {
            const rr = radius * (0.25 + (i / arcs) * 0.92) + (i % 3) * 2;
            const a0 = (i * 0.37) % TAU;
            const a1 = a0 + (0.45 + (i % 5) * 0.07);
            g.beginPath();
            g.arc(0, 0, rr, a0, a1);
            g.stroke();
        }

        // snow speckles
        const dots = 110;
        for (let i = 0; i < dots; i++) {
            const pr = Math.sqrt(Math.random()) * radius * 1.05;
            const pa = Math.random() * TAU;
            const px = Math.cos(pa) * pr;
            const py = Math.sin(pa) * pr;
            const s = 0.8 + Math.random() * 1.8;
            g.fillStyle = (Math.random() < 0.25) ? 'rgba(0,229,255,0.10)' : 'rgba(255,255,255,0.12)';
            g.beginPath();
            g.arc(px, py, s, 0, TAU);
            g.fill();
        }

        g.restore();

        const out = { c, size: size / dpr, r: R };
        map.set(key, out);
        return out;
    } catch (e) {
        return null;
    }
}

function __getBlizzardWallSprite(radius, dpr) {
    try {
        dpr = (dpr || 1);
        const key = Math.round(radius) + '@' + dpr;
        if (__BLZ_FX.wall.has(key)) return __BLZ_FX.wall.get(key);

        const pad = 54;
        const R = radius + pad;
        const size = Math.ceil((R * 2) * dpr);
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const g = c.getContext('2d');
        g.clearRect(0, 0, size, size);

        g.save();
        g.translate(size / 2, size / 2);
        g.scale(dpr, dpr);

        const TAU = Math.PI * 2;

        // outer icy rim
        const rg = g.createRadialGradient(0, 0, radius * 0.9, 0, 0, R);
        rg.addColorStop(0, 'rgba(0,229,255,0.00)');
        rg.addColorStop(0.35, 'rgba(0,229,255,0.08)');
        rg.addColorStop(0.70, 'rgba(255,255,255,0.10)');
        rg.addColorStop(1, 'rgba(255,255,255,0.00)');

        g.strokeStyle = 'rgba(0,229,255,0.32)';
        g.lineWidth = 6;
        g.beginPath();
        g.arc(0, 0, radius + 6, 0, TAU);
        g.stroke();

        // turbulent wall fill
        g.fillStyle = rg;
        g.beginPath();
        g.arc(0, 0, R, 0, TAU);
        g.fill();

        // icy teeth (jagged spikes)
        const teeth = 44;
        g.fillStyle = 'rgba(255,255,255,0.10)';
        for (let i = 0; i < teeth; i++) {
            const a = (i / teeth) * TAU;
            const len = 10 + (i % 4) * 4;
            const w = 5 + (i % 3) * 2;
            const x0 = Math.cos(a) * (radius + 10);
            const y0 = Math.sin(a) * (radius + 10);
            const x1 = Math.cos(a) * (radius + 10 + len);
            const y1 = Math.sin(a) * (radius + 10 + len);
            const ax = Math.cos(a + Math.PI / 2) * w;
            const ay = Math.sin(a + Math.PI / 2) * w;
            g.beginPath();
            g.moveTo(x0 - ax, y0 - ay);
            g.lineTo(x0 + ax, y0 + ay);
            g.lineTo(x1, y1);
            g.closePath();
            g.fill();
        }

        // inner dash ring
        g.strokeStyle = 'rgba(255,255,255,0.12)';
        g.lineWidth = 2;
        g.setLineDash([10, 8]);
        g.beginPath();
        g.arc(0, 0, radius - 10, 0, TAU);
        g.stroke();
        g.setLineDash([]);

        g.restore();

        const out = { c, size: size / dpr, r: R };
        __BLZ_FX.wall.set(key, out);
        return out;
    } catch (e) {
        return null;
    }
}


// ===== SYSTEM SIGILS (v√≤ng tr√≤n + bi·ªÉu t∆∞·ª£ng d∆∞·ªõi ch√¢n theo t·ª´ng h·ªá) =====
// M·ª•c ti√™u: m·ªói h·ªá c√≥ 1 sigil ri√™ng bi·ªát (nh·∫π, cache sprite), emblem n·∫±m d∆∞·ªõi t√¢m v√≤ng.
const __SYS_SIGIL_FX = { cache: new Map() };

function __sigilKey(sysId, dpr) {
    return String(sysId || 'default') + '@' + String(dpr || 1);
}

function __drawEmblem(g, sysId, primary, secondary) {
    const TAU = Math.PI * 2;
    g.save();
    g.lineJoin = 'round';
    g.lineCap = 'round';

    // helper
    const stroke2 = (w, c) => { g.lineWidth = w; g.strokeStyle = c; };

    if (sysId === 'speed') {
        // Lightning bolt + chevrons
        g.fillStyle = __colorWithAlpha(primary, 0.92);
        g.strokeStyle = __colorWithAlpha('#FFFFFF', 0.35);
        g.lineWidth = 2.4;
        g.beginPath();
        g.moveTo(-8, -18);
        g.lineTo(3, -18);
        g.lineTo(-4, -2);
        g.lineTo(10, -2);
        g.lineTo(-6, 18);
        g.lineTo(-2, 4);
        g.lineTo(-14, 4);
        g.closePath();
        g.fill();
        g.stroke();

        // tiny chevrons
        g.strokeStyle = __colorWithAlpha(primary, 0.55);
        g.lineWidth = 2.2;
        for (let i = 0; i < 3; i++) {
            const y = 14 + i * 6;
            g.beginPath();
            g.moveTo(-14, y);
            g.lineTo(0, y - 6);
            g.lineTo(14, y);
            g.stroke();
        }

    } else if (sysId === 'engineer') {
        // Gear
        const teeth = 10;
        const r1 = 12, r2 = 18;
        g.fillStyle = __colorWithAlpha(primary, 0.92);
        g.strokeStyle = __colorWithAlpha('#FFFFFF', 0.22);
        g.lineWidth = 2;

        // teeth
        g.beginPath();
        for (let i = 0; i < teeth; i++) {
            const a = (i / teeth) * TAU;
            const a2 = a + TAU / (teeth * 2);
            g.lineTo(Math.cos(a) * r2, Math.sin(a) * r2);
            g.lineTo(Math.cos(a2) * r1, Math.sin(a2) * r1);
        }
        g.closePath();
        g.fill();
        g.stroke();

        // inner hub
        g.fillStyle = __colorWithAlpha('#0b0b0b', 0.35);
        g.beginPath();
        g.arc(0, 0, 7.5, 0, TAU);
        g.fill();
        g.strokeStyle = __colorWithAlpha(primary, 0.35);
        g.lineWidth = 1.6;
        g.stroke();

    } else if (sysId === 'juggernaut') {
        // Heavy plate shield + rivets
        g.fillStyle = __colorWithAlpha(primary, 0.92);
        g.strokeStyle = __colorWithAlpha(secondary, 0.55);
        g.lineWidth = 2.6;
        g.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * TAU - Math.PI / 2;
            const rr = (i % 2 === 0) ? 18 : 14;
            g.lineTo(Math.cos(a) * rr, Math.sin(a) * rr);
        }
        g.closePath();
        g.fill();
        g.stroke();

        // rivets
        g.fillStyle = __colorWithAlpha('#FFFFFF', 0.22);
        for (let i = 0; i < 4; i++) {
            const a = (i / 4) * TAU + 0.3;
            g.beginPath();
            g.arc(Math.cos(a) * 10, Math.sin(a) * 10, 1.9, 0, TAU);
            g.fill();
        }

    } else if (sysId === 'mage') {
        // Arcane crystal glyph
        g.fillStyle = __colorWithAlpha(primary, 0.85);
        g.strokeStyle = __colorWithAlpha('#FFFFFF', 0.22);
        g.lineWidth = 2.2;

        // diamond
        g.beginPath();
        g.moveTo(0, -18);
        g.lineTo(14, 0);
        g.lineTo(0, 18);
        g.lineTo(-14, 0);
        g.closePath();
        g.fill();
        g.stroke();

        // inner rune
        g.strokeStyle = __colorWithAlpha(primary, 0.55);
        g.lineWidth = 2;
        g.beginPath();
        g.moveTo(0, -10);
        g.lineTo(6, 0);
        g.lineTo(0, 10);
        g.lineTo(-6, 0);
        g.closePath();
        g.stroke();

    } else {
        // default/warrior: shield + crossed swords
        g.save();
        // swords behind
        g.strokeStyle = __colorWithAlpha(primary, 0.45);
        g.lineWidth = 3.2;
        g.beginPath();
        g.moveTo(-16, 14);
        g.lineTo(16, -14);
        g.moveTo(-16, -14);
        g.lineTo(16, 14);
        g.stroke();

        // shield
        g.fillStyle = __colorWithAlpha(primary, 0.92);
        g.strokeStyle = __colorWithAlpha('#FFFFFF', 0.22);
        g.lineWidth = 2.4;
        g.beginPath();
        g.moveTo(0, -18);
        g.quadraticCurveTo(14, -12, 14, 0);
        g.quadraticCurveTo(14, 14, 0, 20);
        g.quadraticCurveTo(-14, 14, -14, 0);
        g.quadraticCurveTo(-14, -12, 0, -18);
        g.closePath();
        g.fill();
        g.stroke();

        // crest slash
        g.strokeStyle = __colorWithAlpha(secondary, 0.55);
        g.lineWidth = 2.2;
        g.beginPath();
        g.moveTo(-6, -2);
        g.lineTo(6, 6);
        g.stroke();
        g.restore();
    }

    g.restore();
}

function __getSystemSigilSprites(sysId, cfg, dpr) {
    try {
        dpr = (dpr || 1);
        const key = __sigilKey(sysId, dpr);
        if (__SYS_SIGIL_FX.cache.has(key)) return __SYS_SIGIL_FX.cache.get(key);

        const TAU = Math.PI * 2;
        const accent = __safeColor((cfg && (cfg.sigilAccent || cfg.accent)) || '#00E5FF', '#00E5FF');
        const glow = (cfg && cfg.glow) ? cfg.glow : __colorWithAlpha(accent, 0.25);
        const secondary = __safeColor((cfg && (cfg.sigilSecondary || (cfg.body && cfg.body[2]))) || '#FFFFFF', '#FFFFFF');

        const baseSize = 180;     // CSS px
        const baseR = 64;         // reference radius
        const cBase = document.createElement('canvas');
        cBase.width = Math.round(baseSize * dpr);
        cBase.height = Math.round(baseSize * dpr);
        const gb = cBase.getContext('2d');
        gb.setTransform(dpr, 0, 0, dpr, 0, 0);
        gb.translate(baseSize / 2, baseSize / 2);

        // soft floor glow
        const rg = gb.createRadialGradient(-10, -10, 0, 0, 0, baseR * 1.35);
        rg.addColorStop(0, __colorWithAlpha(accent, 0.18));
        rg.addColorStop(0.28, __colorWithAlpha(accent, 0.14));
        rg.addColorStop(0.60, __colorWithAlpha(accent, 0.08));
        rg.addColorStop(1, __colorWithAlpha(accent, 0.0));
        gb.fillStyle = rg;
        gb.beginPath();
        gb.arc(0, 0, baseR * 1.12, 0, TAU);
        gb.fill();

        // main ring
        gb.strokeStyle = __colorWithAlpha(accent, 0.48);
        gb.lineWidth = 3;
        gb.beginPath();
        gb.arc(0, 0, baseR * 0.98, 0, TAU);
        gb.stroke();

        // ticks
        gb.strokeStyle = __colorWithAlpha('#FFFFFF', 0.12);
        gb.lineWidth = 2;
        for (let i = 0; i < 12; i++) {
            const a = i * (TAU / 12);
            const r1 = baseR * 0.84;
            const r2 = baseR * 0.98;
            gb.beginPath();
            gb.moveTo(Math.cos(a) * r1, Math.sin(a) * r1);
            gb.lineTo(Math.cos(a) * r2, Math.sin(a) * r2);
            gb.stroke();
        }

        // inner dot ring
        gb.fillStyle = __colorWithAlpha(accent, 0.22);
        for (let i = 0; i < 10; i++) {
            const a = i * (TAU / 10);
            gb.beginPath();
            gb.arc(Math.cos(a) * (baseR * 0.62), Math.sin(a) * (baseR * 0.62), 1.4, 0, TAU);
            gb.fill();
        }

        // overlay sprite (rotating segments)
        const cOv = document.createElement('canvas');
        cOv.width = Math.round(baseSize * dpr);
        cOv.height = Math.round(baseSize * dpr);
        const go = cOv.getContext('2d');
        go.setTransform(dpr, 0, 0, dpr, 0, 0);
        go.translate(baseSize / 2, baseSize / 2);

        go.strokeStyle = __colorWithAlpha(accent, 0.28);
        go.lineWidth = 4;
        go.setLineDash([10, 10]);
        go.beginPath();
        go.arc(0, 0, baseR * 1.05, 0, TAU);
        go.stroke();
        go.setLineDash([]);

        // 4 arc segments
        go.strokeStyle = __colorWithAlpha(secondary, 0.18);
        go.lineWidth = 3;
        for (let i = 0; i < 4; i++) {
            const a0 = i * (TAU / 4) + 0.25;
            const a1 = a0 + 0.55;
            go.beginPath();
            go.arc(0, 0, baseR * 0.78, a0, a1);
            go.stroke();
        }

        // emblem sprite
        const eSize = 96;
        const cEm = document.createElement('canvas');
        cEm.width = Math.round(eSize * dpr);
        cEm.height = Math.round(eSize * dpr);
        const ge = cEm.getContext('2d');
        ge.setTransform(dpr, 0, 0, dpr, 0, 0);
        ge.translate(eSize / 2, eSize / 2);

        // emblem soft glow backdrop (cheap)
        const erg = ge.createRadialGradient(-6, -6, 0, 0, 0, 32);
        erg.addColorStop(0, __colorWithAlpha(accent, 0.18));
        erg.addColorStop(0.5, __colorWithAlpha(accent, 0.08));
        erg.addColorStop(1, __colorWithAlpha(accent, 0));
        ge.fillStyle = erg;
        ge.beginPath();
        ge.arc(0, 0, 28, 0, TAU);
        ge.fill();

        // emblem itself
        __drawEmblem(ge, sysId, accent, secondary);

        const out = {
            base: cBase,
            overlay: cOv,
            emblem: cEm,
            meta: { baseSize, baseR, eSize }
        };

        __SYS_SIGIL_FX.cache.set(key, out);
        return out;
    } catch (e) {
        return null;
    }
}

function __drawSystemSigilUnderfoot(player, cfg, alpha) {
    try {
        const sysId = (player && player.systemId) ? player.systemId : 'default';
        const now = Date.now();
        const dpr = (typeof window !== 'undefined' && window.devicePixelRatio) ? window.devicePixelRatio : 1;
        const s = __getSystemSigilSprites(sysId, cfg, dpr);
        if (!s) return;

        const meta = s.meta;
        const baseR = meta.baseR;
        const desiredR = (player.radius || 22) + 28;
        const scale = desiredR / baseR;
        const drawS = meta.baseSize * scale;
        const t = now / 1000;
        const pulse = 1 + Math.sin(now / 210) * 0.018;

        // Mage ƒë√£ c√≥ aura ri√™ng r·∫•t ƒë·∫πp; ·ªü ƒë√¢y ch·ªâ v·∫Ω emblem + overlay nh·∫π ƒë·ªÉ kh√¥ng b·ªã ch·ªìng ring qu√° d√†y.
        const drawRing = (sysId !== 'mage');

        ctx.save();
        // v·∫Ω d∆∞·ªõi th√¢n xe -> alpha v·ª´a ph·∫£i
        const a0 = Math.max(0, Math.min(1, alpha || 1));

        if (drawRing) {
            ctx.globalAlpha = a0 * 0.35;
            ctx.save();
            ctx.rotate(t * 0.35);
            ctx.drawImage(s.base, -drawS / 2, -drawS / 2, drawS, drawS);
            ctx.restore();

            ctx.globalAlpha = a0 * 0.25;
            ctx.save();
            ctx.rotate(-t * 0.9);
            ctx.drawImage(s.overlay, -drawS / 2, -drawS / 2, drawS, drawS);
            ctx.restore();
        } else {
            // mage: ch·ªâ overlay m·ªèng
            ctx.globalAlpha = a0 * 0.12;
            ctx.save();
            ctx.rotate(-t * 0.85);
            ctx.drawImage(s.overlay, -drawS / 2, -drawS / 2, drawS, drawS);
            ctx.restore();
        }

        // emblem position (d∆∞·ªõi t√¢m v√≤ng)
        const emS = meta.eSize * scale;
        const emY = desiredR * 0.52;

        // back glow
        ctx.globalAlpha = a0 * 0.22;
        ctx.save();
        ctx.translate(0, emY);
        const gPulse = 1 + Math.sin(now / 170) * 0.06;
        ctx.scale(gPulse, gPulse);
        ctx.drawImage(s.emblem, -emS / 2, -emS / 2, emS, emS);
        ctx.restore();

        // crisp emblem
        ctx.globalAlpha = a0 * 0.55;
        ctx.save();
        ctx.translate(0, emY);
        ctx.scale(pulse, pulse);
        ctx.drawImage(s.emblem, -emS / 2, -emS / 2, emS, emS);
        ctx.restore();

        ctx.restore();
    } catch (e) {}
}
// ===== GHI ƒê√à PH∆Ø∆†NG TH·ª®C DRAW C·ª¶A PLAYER =====
const _originalPlayerDraw = Player.prototype.draw;
Player.prototype.draw = function() {
    const __sysId = (this.systemId || 'default');
    const cfg = (GFX.SYSTEMS && (GFX.SYSTEMS[__sysId] || (this.systemId==='default' ? GFX.SYSTEMS.default : null))) ? (GFX.SYSTEMS[__sysId] || GFX.SYSTEMS.default) : (GFX.PLAYER || {});
    
    ctx.save();

// === HI·ªÜU ·ª®NG: SPEED DASH (Q) ‚Äî FLASH LIGHTNING TRAIL (OPTIMIZED) ===
    // Gi·ªØ vibe "The Flash" nh∆∞ng t·ªëi ∆∞u: cache beam sprite + bolts theo nh·ªãp, h·∫°n ch·∫ø shadowBlur/composite.
    (function(){
        try {
            const now = Date.now();
            if (this.systemId !== 'speed') return;

            const isDashing = !!(this.dash && this.dash.active && now <= this.dash.endTime);
            if (!this.__dashFxOpt) this.__dashFxOpt = { trail: [], bolts: [], nextBoltAt: 0, sparks: [], nextSparkAt: 0, beam: null, beamDpr: 0 };
            const fx = this.__dashFxOpt;

            const keepMs = 260; // ƒëu√¥i ng·∫Øn h∆°n ƒë·ªÉ gi·∫£m overdraw nh∆∞ng v·∫´n d√†i/ƒë·∫πp

            // Ghi l·∫°i v·ªát khi dash
            if (isDashing) {
                fx.trail.push({ x: this.x, y: this.y, t: now });
                if (fx.trail.length > 16) fx.trail.shift();
            }

            // Gi·ªØ v·ªát ng·∫Øn sau khi dash k·∫øt th√∫c
            fx.trail = (fx.trail || []).filter(p => (now - (p.t || now)) <= keepMs);

            // H∆∞·ªõng dash (fallback theo movement)
            const last = fx.trail[fx.trail.length - 1];
            const prev = fx.trail[Math.max(0, fx.trail.length - 2)];
            const mvx = (last && prev) ? (last.x - prev.x) : 0;
            const mvy = (last && prev) ? (last.y - prev.y) : 0;
            const vx = (isDashing ? (this.dash.vx || mvx) : mvx);
            const vy = (isDashing ? (this.dash.vy || mvy) : mvy);
            const ang = Math.atan2(vy || 0, (vx || 1));

            // ---- Beam sprite cache (v·∫Ω 1 l·∫ßn, d√πng drawImage m·ªói frame) ----
            const dpr = ((typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1) || 1);
            if (!fx.beam || fx.beamDpr !== dpr) {
                fx.beamDpr = dpr;
                const bw = Math.round(220 * dpr);
                const bh = Math.round(70 * dpr);
                const c = document.createElement('canvas');
                c.width = bw; c.height = bh;
                const g = c.getContext('2d');
                g.clearRect(0, 0, bw, bh);

                // Glow body
                const lg = g.createLinearGradient(0, 0, bw, 0);
                lg.addColorStop(0, 'rgba(255,255,255,0)');
                lg.addColorStop(0.08, 'rgba(255,255,255,0.35)');
                lg.addColorStop(0.35, 'rgba(0,229,255,0.35)');
                lg.addColorStop(1, 'rgba(0,229,255,0)');
                g.fillStyle = lg;
                g.beginPath();
                g.ellipse(bw * 0.55, bh * 0.5, bw * 0.55, bh * 0.32, 0, 0, Math.PI * 2);
                g.fill();

                // Core streak
                const lg2 = g.createLinearGradient(0, 0, bw, 0);
                lg2.addColorStop(0, 'rgba(255,255,255,0)');
                lg2.addColorStop(0.12, 'rgba(255,255,255,0.55)');
                lg2.addColorStop(0.5, 'rgba(129,212,250,0.30)');
                lg2.addColorStop(1, 'rgba(0,229,255,0)');
                g.fillStyle = lg2;
                g.beginPath();
                g.ellipse(bw * 0.60, bh * 0.5, bw * 0.55, bh * 0.12, 0, 0, Math.PI * 2);
                g.fill();

                fx.beam = { c, w: bw / dpr, h: bh / dpr };
            }

            // ---- Bolts cache (update ~90ms/l·∫ßn khi ƒëang dash) ----
            const makeBolt = (len, amp, steps) => {
                const pts = [{ x: 0, y: 0 }];
                for (let i = 1; i < steps; i++) {
                    const tt = i / steps;
                    const j = (Math.random() - 0.5) * amp * (1 - tt);
                    pts.push({ x: -len * tt, y: j });
                }
                pts.push({ x: -len, y: 0 });
                return pts;
            };

            if (isDashing && now >= fx.nextBoltAt) {
                fx.nextBoltAt = now + 90;
                fx.bolts.length = 0;
                for (let i = 0; i < 2; i++) {
                    fx.bolts.push({
                        off: (Math.random() - 0.5) * 26,
                        pts: makeBolt(120 + Math.random() * 70, 18, 7)
                    });
                }
            }

            // ---- Spark cache (update ~70ms/l·∫ßn khi dash) ----
            if (isDashing && now >= fx.nextSparkAt) {
                fx.nextSparkAt = now + 70;
                for (let i = 0; i < 5; i++) {
                    fx.sparks.push({
                        x: Math.random() * 170,
                        y: (Math.random() - 0.5) * 30,
                        t: now,
                        life: 200 + Math.random() * 160
                    });
                }
                if (fx.sparks.length > 28) fx.sparks.splice(0, fx.sparks.length - 28);
            }
            fx.sparks = (fx.sparks || []).filter(sp => (now - sp.t) <= sp.life);

            // ---- Draw trail ribbon (r·∫ª: 3 path stroke) ----
            if (fx.trail.length > 1) {
                ctx.save();
                ctx.lineCap = 'round';

                const drawSlice = (fromIdx, toIdx, lw, stroke, shadow) => {
                    if (toIdx <= fromIdx) return;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = lw;
                    if (shadow) {
                        ctx.shadowBlur = shadow.blur;
                        ctx.shadowColor = shadow.color;
                    } else {
                        ctx.shadowBlur = 0;
                    }
                    ctx.beginPath();
                    ctx.moveTo(fx.trail[fromIdx].x, fx.trail[fromIdx].y);
                    for (let i = fromIdx + 1; i <= toIdx; i++) {
                        const p = fx.trail[i];
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                };

                const n = fx.trail.length;
                const iA = Math.max(0, n - 5);
                const iB = Math.max(0, n - 10);

                // outer glow feel (shadowBlur nh·ªè, 1-2 l·∫ßn stroke th√¥i)
                drawSlice(0, Math.min(iB, n - 1), 10, 'rgba(0,229,255,0.06)');
                if (iB < n - 1) drawSlice(iB, Math.min(iA, n - 1), 14, 'rgba(0,229,255,0.10)', { blur: 8, color: 'rgba(0,229,255,0.55)' });
                if (iA < n - 1) drawSlice(iA, n - 1, 18, 'rgba(0,229,255,0.14)', { blur: 10, color: 'rgba(0,229,255,0.60)' });

                // inner white core
                if (iB < n - 1) drawSlice(iB, n - 1, 5, 'rgba(255,255,255,0.10)');

                ctx.restore();
            }

            // ---- Beam sprite behind tank (only while dashing) ----
            if (isDashing && fx.beam) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(ang + Math.PI); // v·∫Ω v·ªÅ ph√≠a sau
                const len = 175;
                ctx.globalAlpha = 0.95;
                ctx.drawImage(fx.beam.c, -len, -fx.beam.h / 2, len, fx.beam.h);
                ctx.restore();
            }

            // ---- Bolts + sparks (cheap strokes/arcs) ----
            if (isDashing && fx.bolts && fx.bolts.length) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(ang + Math.PI);

                for (let i = 0; i < fx.bolts.length; i++) {
                    const b = fx.bolts[i];
                    ctx.save();
                    ctx.translate(0, b.off);

                    // cyan thick glow
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = 'rgba(0,229,255,0.22)';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(b.pts[0].x, b.pts[0].y);
                    for (let k = 1; k < b.pts.length; k++) ctx.lineTo(b.pts[k].x, b.pts[k].y);
                    ctx.stroke();

                    // yellow core
                    ctx.strokeStyle = 'rgba(255,235,59,0.32)';
                    ctx.lineWidth = 2.2;
                    ctx.beginPath();
                    ctx.moveTo(b.pts[0].x, b.pts[0].y);
                    for (let k = 1; k < b.pts.length; k++) ctx.lineTo(b.pts[k].x, b.pts[k].y);
                    ctx.stroke();

                    ctx.restore();
                }

                // sparks
                for (let i = 0; i < fx.sparks.length; i++) {
                    const sp = fx.sparks[i];
                    const age = now - sp.t;
                    const a = Math.max(0, 1 - age / sp.life);
                    ctx.fillStyle = `rgba(255,255,255,${0.08 + 0.16 * a})`;
                    ctx.beginPath();
                    ctx.arc(-(22 + sp.x), sp.y, 1.0 + 1.2 * a, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        } catch (e) { /* silent */ }
    }).call(this);

ctx.translate(this.x, this.y);
    
    // Alpha cho stealth/phase
    let alpha = 1;
    if (this.isStealth) alpha = 0.4;
    if (this.buffs.phase && this.buffs.phase.active) alpha = 0.35;
    ctx.globalAlpha = alpha;
    



    // === SYSTEM SIGIL (v√≤ng tr√≤n + bi·ªÉu t∆∞·ª£ng d∆∞·ªõi ch√¢n theo h·ªá) ===
    __drawSystemSigilUnderfoot(this, cfg, alpha);

    // === MAGE PASSIVE AURA (√°nh s√°ng ph√©p thu·∫≠t) ‚Äî nh·∫π nh∆∞ng r√µ vibe ===
    if (this.systemId === 'mage') {
        try {
            const now = Date.now();
            if (!this.__mageAuraFx) this.__mageAuraFx = { dpr: 0, sprite: null, meta: null };
            const fx = this.__mageAuraFx;
            const dpr = (typeof window !== 'undefined' && window.devicePixelRatio) ? window.devicePixelRatio : 1;

            if (!fx.sprite || fx.dpr !== dpr) {
                fx.dpr = dpr;
                const baseSize = 180; // CSS px
                const baseR = 64;
                const c = document.createElement('canvas');
                c.width = Math.round(baseSize * dpr);
                c.height = Math.round(baseSize * dpr);
                const g = c.getContext('2d');
                g.setTransform(dpr, 0, 0, dpr, 0, 0);
                g.translate(baseSize / 2, baseSize / 2);

                // Soft halo (white-blue)
                const rg = g.createRadialGradient(-10, -10, 0, 0, 0, baseR * 1.35);
                rg.addColorStop(0, 'rgba(255,255,255,0.18)');
                rg.addColorStop(0.22, 'rgba(179,229,252,0.24)');
                rg.addColorStop(0.55, 'rgba(0,229,255,0.12)');
                rg.addColorStop(1, 'rgba(0,229,255,0)');
                g.fillStyle = rg;
                g.beginPath();
                g.arc(0, 0, baseR * 1.15, 0, Math.PI * 2);
                g.fill();

                // Rune ring
                g.strokeStyle = 'rgba(179,229,252,0.38)';
                g.lineWidth = 3;
                g.beginPath();
                g.arc(0, 0, baseR * 0.98, 0, Math.PI * 2);
                g.stroke();

                // Small rune ticks
                g.strokeStyle = 'rgba(255,255,255,0.16)';
                g.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    const a = i * (Math.PI * 2 / 12);
                    const r1 = baseR * 0.86;
                    const r2 = baseR * 0.98;
                    g.beginPath();
                    g.moveTo(Math.cos(a) * r1, Math.sin(a) * r1);
                    g.lineTo(Math.cos(a) * r2, Math.sin(a) * r2);
                    g.stroke();
                }

                // Inner sparkle cluster (static)
                g.fillStyle = 'rgba(255,255,255,0.22)';
                for (let i = 0; i < 18; i++) {
                    const a = (i / 18) * Math.PI * 2;
                    const rr = 10 + (i % 6) * 2;
                    g.beginPath();
                    g.arc(Math.cos(a) * rr, Math.sin(a) * rr, (i % 3 === 0) ? 1.4 : 1.0, 0, Math.PI * 2);
                    g.fill();
                }

                fx.sprite = c;
                fx.meta = { baseSize, baseR };
            }

            const meta = fx.meta;
            const desiredR = (this.radius || 22) + 32;
            const scale = desiredR / meta.baseR;
            const drawS = meta.baseSize * scale;
            const t = now / 1000;

            ctx.save();
            // t√¥n tr·ªçng alpha stealth/phase (alpha ƒëang set b√™n ngo√†i)
            ctx.globalAlpha = alpha * 0.55;
            ctx.rotate(t * 0.6);
            ctx.drawImage(fx.sprite, -drawS / 2, -drawS / 2, drawS, drawS);

            ctx.globalAlpha = alpha * 0.22;
            ctx.rotate(-t * 1.6);
            ctx.drawImage(fx.sprite, -drawS / 2, -drawS / 2, drawS, drawS);

            // 6 spark orbit (si√™u nh·∫π)
            ctx.globalAlpha = alpha * 0.55;
            ctx.fillStyle = 'rgba(255,255,255,0.75)';
            for (let i = 0; i < 6; i++) {
                const a = t * 2.2 + i * (Math.PI * 2 / 6);
                const r = desiredR - 8 + Math.sin(t * 4 + i) * 1.5;
                ctx.beginPath();
                ctx.arc(Math.cos(a) * r, Math.sin(a) * r, 1.6, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        } catch (e) {}
    }

// Hi·ªáu ·ª©ng k·ªπ nƒÉng (N√ÇNG C·∫§P: Warrior R - H√∫t M√°u) ‚Äî ULTRALITE (∆∞u ti√™n m∆∞·ª£t, v·∫´n ƒë√∫ng ‚Äúdrain‚Äù)
    const __isWarrior = (this.systemId === 'default' || this.systemId === 'warrior');
    if (__isWarrior && this.skills && this.skills.vampirism && this.skills.vampirism.active) {
        try {
            const now = Date.now();
            const TAU = Math.PI * 2;
            const t = now / 1000;
            const pulse = 0.6 + Math.sin(now / 140) * 0.4;
            const outer = this.radius + 24;

            // State/cache (si√™u nh·∫π)
            if (!this.__vampFxLite) this.__vampFxLite = { nextScan: 0, targets: [], auraR: 0, auraGrad: null, crest: null, crestDpr: 0 };
            const fx = this.__vampFxLite;

            // Scan m·ª•c ti√™u theo nh·ªãp (gi·∫£m load)
            if (now >= (fx.nextScan || 0)) {
                fx.nextScan = now + 180;
                const maxTargets = 2;
                const maxD2 = 320 * 320;
                const picked = [];

                if (typeof Game !== 'undefined' && Game.enemies && Game.enemies.length) {
                    for (let i = 0; i < Game.enemies.length; i++) {
                        const e = Game.enemies[i];
                        if (!e || e.hp <= 0) continue;
                        const dx = e.x - this.x;
                        const dy = e.y - this.y;
                        const d2 = dx * dx + dy * dy;
                        if (d2 >= maxD2) continue;
                        picked.push({ dx, dy, d2 });
                    }
                    picked.sort((a, b) => a.d2 - b.d2);
                }

                fx.targets = picked.slice(0, maxTargets);
            }

            // Aura (cache gradient theo b√°n k√≠nh)
            if (!fx.auraGrad || fx.auraR !== outer) {
                fx.auraR = outer;
                const g = ctx.createRadialGradient(0, 0, 0, 0, 0, outer * 1.6);
                g.addColorStop(0, 'rgba(255,255,255,0.03)');
                g.addColorStop(0.22, 'rgba(255,23,68,0.15)');
                g.addColorStop(0.70, 'rgba(255,23,68,0.07)');
                g.addColorStop(1, 'rgba(255,23,68,0)');
                fx.auraGrad = g;
            }

            ctx.save();
            // IMPORTANT: tr√°nh shadowBlur l·ªõn + tr√°nh composite 'lighter' ƒë·ªÉ m∆∞·ª£t
            ctx.shadowBlur = 0;
            ctx.globalCompositeOperation = 'source-over';

            // Aura + v√≤ng h√∫t
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = fx.auraGrad;
            ctx.beginPath();
            ctx.arc(0, 0, outer * 1.22, 0, TAU);
            ctx.fill();

            ctx.globalAlpha = 0.35 + 0.25 * pulse;
            ctx.strokeStyle = 'rgba(255, 82, 82, 0.95)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, outer + 6 + Math.sin(t * 5) * 2, 0, TAU);
            ctx.stroke();

            // Beams h√∫t m√°u (√≠t n√©t, v·∫´n ‚Äúdrain‚Äù r√µ)
            const targets = fx.targets || [];
            if (targets.length) {
                ctx.lineCap = 'round';
                for (let i = 0; i < targets.length; i++) {
                    const b = targets[i];
                    const sx = b.dx, sy = b.dy;
                    const len = Math.max(1, Math.sqrt(b.d2));
                    const nx = -sy / len, ny = sx / len;
                    const wob = Math.sin(t * 10 + i * 2.1) * 10;
                    const mx = sx * 0.55 + nx * wob;
                    const my = sy * 0.55 + ny * wob;

                    // Outer (ƒë·ªè ƒë·∫≠m)
                    ctx.globalAlpha = 0.35 + 0.20 * pulse;
                    ctx.strokeStyle = 'rgba(183, 28, 28, 0.85)';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.quadraticCurveTo(mx, my, 0, 0);
                    ctx.stroke();

                    // Inner (s√°ng)
                    ctx.globalAlpha = 0.55 + 0.25 * pulse;
                    ctx.strokeStyle = 'rgba(255, 235, 238, 0.95)';
                    ctx.lineWidth = 2.2;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.quadraticCurveTo(mx, my, 0, 0);
                    ctx.stroke();

                    // 1 gi·ªçt m√°u ch·∫°y v·ªÅ t√¢m (r·∫•t nh·∫π)
                    const tt = (t * 1.8 + i * 0.33) % 1;
                    const px = sx * (1 - tt);
                    const py = sy * (1 - tt);
                    ctx.globalAlpha = 0.55 + 0.25 * pulse;
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2.0, 0, TAU);
                    ctx.fill();

                    ctx.globalAlpha = 0.35;
                    ctx.fillStyle = 'rgba(255, 23, 68, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 3.4, 0, TAU);
                    ctx.fill();
                }
            }

            // Crest ‚Äúchi·∫øn binh‚Äù (cache offscreen, drawImage m·ªói frame)
            const dpr = (typeof window !== 'undefined' && window.devicePixelRatio) ? window.devicePixelRatio : 1;
            if (!fx.crest || fx.crestDpr !== dpr) {
                fx.crestDpr = dpr;
                const c = document.createElement('canvas');
                const size = 64;
                c.width = Math.round(size * dpr);
                c.height = Math.round(size * dpr);
                const cctx = c.getContext('2d');
                cctx.scale(dpr, dpr);
                cctx.translate(size / 2, size / 2);

                // ring
                cctx.strokeStyle = 'rgba(255, 82, 82, 0.85)';
                cctx.lineWidth = 2;
                cctx.beginPath();
                cctx.arc(0, 0, 22, 0, TAU);
                cctx.stroke();

                // shield (simple)
                cctx.fillStyle = 'rgba(183, 28, 28, 0.35)';
                cctx.strokeStyle = 'rgba(255, 235, 238, 0.7)';
                cctx.lineWidth = 2;
                cctx.beginPath();
                cctx.moveTo(0, -16);
                cctx.lineTo(14, -8);
                cctx.lineTo(11, 10);
                cctx.quadraticCurveTo(0, 18, -11, 10);
                cctx.lineTo(-14, -8);
                cctx.closePath();
                cctx.fill();
                cctx.stroke();

                // crossed swords
                cctx.strokeStyle = 'rgba(255, 235, 238, 0.9)';
                cctx.lineWidth = 3;
                cctx.lineCap = 'round';
                cctx.beginPath();
                cctx.moveTo(-10, 10);
                cctx.lineTo(10, -10);
                cctx.stroke();
                cctx.beginPath();
                cctx.moveTo(10, 10);
                cctx.lineTo(-10, -10);
                cctx.stroke();

                fx.crest = c;
            }

            if (fx.crest) {
                const size = 54;
                ctx.save();
                ctx.translate(0, -(this.radius + 38));
                ctx.globalAlpha = 0.55 + 0.25 * pulse;
                ctx.drawImage(fx.crest, -size / 2, -size / 2, size, size);
                ctx.restore();
            }

            ctx.restore();
        } catch (e) { /* silent */ }
    } else if (this.skills && this.skills.vampirism && this.skills.vampirism.active) {
        // fallback (n·∫øu system kh√°c d√πng vampirism)
        ctx.strokeStyle = '#FF5252';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255, 82, 82, 0.1)';
        ctx.fill();
    }

    // === HI·ªÜU ·ª®NG: SPEED PHASE (E) & ADRENALINE (R) ‚Äî ƒë·∫πp, ƒë√∫ng ch·ªß ƒë·ªÅ, t·ªëi ∆∞u m∆∞·ª£t ===
    const __isSpeedSys = (this.systemId === 'speed');
    const __nowFX = Date.now();
    const __TAU = Math.PI * 2;

    if (this.buffs.phase && this.buffs.phase.active) {
        if (__isSpeedSys) {
            try {
                if (!this.__speedBuffFx) this.__speedBuffFx = { dpr: 0, phaseSprite: null, phaseMeta: null, adrSprite: null, adrMeta: null, nextBoltAt: 0, bolts: [] };
                const __fx = this.__speedBuffFx;
                const __dpr = (typeof window !== 'undefined' && window.devicePixelRatio) ? window.devicePixelRatio : 1;
                if (__fx.dpr !== __dpr) {
                    __fx.dpr = __dpr;
                    __fx.phaseSprite = null; __fx.phaseMeta = null;
                    __fx.adrSprite = null; __fx.adrMeta = null;
                    __fx.bolts = []; __fx.nextBoltAt = 0;
                }

                // Build PHASE sprite (cache)
                if (!__fx.phaseSprite) {
                    const baseSize = 140;  // CSS px
                    const baseR = 56;
                    const c = document.createElement('canvas');
                    c.width = Math.round(baseSize * __dpr);
                    c.height = Math.round(baseSize * __dpr);
                    const g = c.getContext('2d');
                    g.setTransform(__dpr, 0, 0, __dpr, 0, 0);
                    g.translate(baseSize / 2, baseSize / 2);

                    // Outer ring
                    const rg = g.createRadialGradient(-10, -10, 0, 0, 0, baseR * 1.25);
                    rg.addColorStop(0, 'rgba(255,255,255,0.12)');
                    rg.addColorStop(0.35, 'rgba(129,212,250,0.22)');
                    rg.addColorStop(1, 'rgba(129,212,250,0)');
                    g.fillStyle = rg;
                    g.beginPath();
                    g.arc(0, 0, baseR * 1.15, 0, __TAU);
                    g.fill();

                    g.strokeStyle = 'rgba(129,212,250,0.75)';
                    g.lineWidth = 4;
                    g.beginPath();
                    g.arc(0, 0, baseR, 0, __TAU);
                    g.stroke();

                    // Shield segments
                    g.strokeStyle = 'rgba(255,255,255,0.14)';
                    g.lineWidth = 3;
                    for (let i = 0; i < 6; i++) {
                        const a = i * (__TAU / 6);
                        g.beginPath();
                        g.arc(0, 0, baseR - 7, a - 0.22, a + 0.22);
                        g.stroke();
                    }

                    // Scanlines (clip)
                    g.save();
                    g.beginPath();
                    g.arc(0, 0, baseR - 10, 0, __TAU);
                    g.clip();
                    g.rotate(-0.25);
                    g.strokeStyle = 'rgba(255,255,255,0.06)';
                    g.lineWidth = 2;
                    for (let y = -80; y <= 80; y += 10) {
                        g.beginPath();
                        g.moveTo(-90, y);
                        g.lineTo(90, y + 22);
                        g.stroke();
                    }
                    g.restore();

                    // Inner core ring
                    g.strokeStyle = 'rgba(255,255,255,0.12)';
                    g.lineWidth = 2;
                    g.beginPath();
                    g.arc(0, 0, baseR * 0.55, 0, __TAU);
                    g.stroke();

                    __fx.phaseSprite = c;
                    __fx.phaseMeta = { baseSize, baseR };
                }

                const t = __nowFX / 1000;
                const pulse = 0.55 + Math.sin(__nowFX / 120) * 0.45;
                const desiredR = this.radius + 20;
                const meta = __fx.phaseMeta;
                const scale = desiredR / meta.baseR;
                const drawS = meta.baseSize * scale;

                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = 0;

                // 2 l·ªõp sprite xoay ng∆∞·ª£c chi·ªÅu t·∫°o c·∫£m gi√°c ‚Äúphase field‚Äù
                ctx.globalAlpha = 0.78;
                ctx.rotate(t * 0.85);
                ctx.drawImage(__fx.phaseSprite, -drawS/2, -drawS/2, drawS, drawS);

                ctx.globalAlpha = 0.28 + 0.18 * pulse;
                ctx.rotate(-t * 1.9);
                ctx.drawImage(__fx.phaseSprite, -drawS/2, -drawS/2, drawS, drawS);

                // Spark nodes (r·∫•t √≠t) quanh v√≤ng
                ctx.globalAlpha = 0.45 + 0.25 * pulse;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                for (let i = 0; i < 6; i++) {
                    const a = t * 2.4 + i * (__TAU / 6);
                    const r = desiredR + 3 + Math.sin(t * 5 + i) * 1.5;
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * r;
                    ctx.beginPath();
                    ctx.arc(x, y, 1.4, 0, __TAU);
                    ctx.fill();
                }

                // Inner shimmer arcs
                ctx.globalAlpha = 0.16 + 0.12 * pulse;
                ctx.strokeStyle = 'rgba(129,212,250,0.55)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const a0 = t * 1.8 + i * (__TAU / 3);
                    ctx.beginPath();
                    ctx.arc(0, 0, desiredR - 9, a0, a0 + 0.95);
                    ctx.stroke();
                }

                ctx.restore();
            } catch (e) {
                // fallback
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 16, 0, Math.PI * 2);
                ctx.strokeStyle = '#81D4FA';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        } else {
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 16, 0, Math.PI * 2);
            ctx.strokeStyle = '#81D4FA';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    if (this.buffs.adrenaline && this.buffs.adrenaline.active) {
        if (__isSpeedSys) {
            try {
                if (!this.__speedBuffFx) this.__speedBuffFx = { dpr: 0, phaseSprite: null, phaseMeta: null, adrSprite: null, adrMeta: null, nextBoltAt: 0, bolts: [] };
                const __fx = this.__speedBuffFx;
                const __dpr = (typeof window !== 'undefined' && window.devicePixelRatio) ? window.devicePixelRatio : 1;
                if (__fx.dpr !== __dpr) {
                    __fx.dpr = __dpr;
                    __fx.phaseSprite = null; __fx.phaseMeta = null;
                    __fx.adrSprite = null; __fx.adrMeta = null;
                    __fx.bolts = []; __fx.nextBoltAt = 0;
                }

                // Build ADRENALINE sprite (cache)
                if (!__fx.adrSprite) {
                    const baseSize = 160;
                    const baseR = 64;
                    const c = document.createElement('canvas');
                    c.width = Math.round(baseSize * __dpr);
                    c.height = Math.round(baseSize * __dpr);
                    const g = c.getContext('2d');
                    g.setTransform(__dpr, 0, 0, __dpr, 0, 0);
                    g.translate(baseSize / 2, baseSize / 2);

                    // Aura disk
                    const rg = g.createRadialGradient(-12, -12, 0, 0, 0, baseR * 1.35);
                    rg.addColorStop(0, 'rgba(255,255,255,0.10)');
                    rg.addColorStop(0.28, 'rgba(41,182,246,0.16)');
                    rg.addColorStop(0.62, 'rgba(0,229,255,0.10)');
                    rg.addColorStop(1, 'rgba(0,229,255,0)');
                    g.fillStyle = rg;
                    g.beginPath();
                    g.arc(0, 0, baseR * 1.20, 0, __TAU);
                    g.fill();

                    // Outer ring
                    g.strokeStyle = 'rgba(0,229,255,0.65)';
                    g.lineWidth = 4;
                    g.beginPath();
                    g.arc(0, 0, baseR, 0, __TAU);
                    g.stroke();

                    // Chevrons / speed marks
                    g.fillStyle = 'rgba(255,255,255,0.08)';
                    for (let i = 0; i < 12; i++) {
                        const a = i * (__TAU / 12);
                        const x = Math.cos(a) * (baseR - 6);
                        const y = Math.sin(a) * (baseR - 6);
                        g.save();
                        g.translate(x, y);
                        g.rotate(a);
                        g.beginPath();
                        g.moveTo(0, 0);
                        g.lineTo(-10, -4);
                        g.lineTo(-10, 4);
                        g.closePath();
                        g.fill();
                        g.restore();
                    }

                    // Inner ring
                    g.strokeStyle = 'rgba(255,255,255,0.10)';
                    g.lineWidth = 2;
                    g.beginPath();
                    g.arc(0, 0, baseR * 0.62, 0, __TAU);
                    g.stroke();

                    __fx.adrSprite = c;
                    __fx.adrMeta = { baseSize, baseR };
                }

                const t = __nowFX / 1000;
                const pulse = 0.55 + Math.sin(__nowFX / 110) * 0.45;
                const desiredR = this.radius + 18;
                const meta = __fx.adrMeta;
                const scale = desiredR / meta.baseR;
                const drawS = meta.baseSize * scale;

                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = 0;

                // Aura sprite (2 l·ªõp xoay)
                ctx.globalAlpha = 0.62 + 0.18 * pulse;
                ctx.rotate(t * 0.9);
                ctx.drawImage(__fx.adrSprite, -drawS/2, -drawS/2, drawS, drawS);

                ctx.globalAlpha = 0.22 + 0.16 * pulse;
                ctx.rotate(-t * 1.8);
                ctx.drawImage(__fx.adrSprite, -drawS/2, -drawS/2, drawS, drawS);

                // Speed lines ph√≠a sau theo h∆∞·ªõng n√≤ng (cu·ªìng t·ªëc)
                ctx.save();
                ctx.rotate(this.angle + Math.PI);
                ctx.globalAlpha = 0.22 + 0.22 * pulse;
                ctx.lineCap = 'round';
                ctx.strokeStyle = 'rgba(0,229,255,0.40)';
                ctx.lineWidth = 3;
                for (let i = -2; i <= 2; i++) {
                    const wob = 0.5 + Math.sin(t * 9 + i) * 0.5;
                    const len = 18 + wob * 28;
                    const y = i * 5.2;
                    const sx = this.radius + 10;
                    ctx.beginPath();
                    ctx.moveTo(sx, y);
                    ctx.lineTo(sx + len, y);
                    ctx.stroke();
                }
                ctx.restore();

                // Orbit segments (nh√¨n ‚Äúcu·ªìng t·ªëc‚Äù nh∆∞ng r·∫ª)
                ctx.globalAlpha = 0.18 + 0.16 * pulse;
                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                ctx.lineWidth = 2;
                const segs = 6;
                for (let i = 0; i < segs; i++) {
                    const a0 = t * 2.2 + i * (__TAU / segs);
                    ctx.beginPath();
                    ctx.arc(0, 0, desiredR + 6, a0, a0 + 0.55);
                    ctx.stroke();
                }

                // Lightning bolts (precomputed points; built below in JS-safe way)
                if (!__fx.__boltSafe) {
                    __fx.__boltSafe = true;
                }
                // ensure bolts exist
                if (!Array.isArray(__fx.bolts)) __fx.bolts = [];
                if (__nowFX >= (__fx.nextBoltAt || 0)) {
                    __fx.nextBoltAt = __nowFX + 120;
                    __fx.bolts.length = 0;
                    const steps = 5;
                    for (let b = 0; b < 2; b++) {
                        const pts = [];
                        const startA = Math.random() * __TAU;
                        const span = 0.55 + Math.random() * 0.35;
                        for (let i = 0; i <= steps; i++) {
                            const aa = startA + (span * i / steps);
                            const rr = desiredR + 4 + (Math.random() - 0.5) * 6;
                            pts.push({ x: Math.cos(aa) * rr, y: Math.sin(aa) * rr });
                        }
                        __fx.bolts.push(pts);
                    }
                }

                if (__fx.bolts && __fx.bolts.length) {
                    ctx.globalAlpha = 0.20 + 0.18 * pulse;
                    ctx.strokeStyle = 'rgba(255,235,59,0.45)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < __fx.bolts.length; i++) {
                        const pts = __fx.bolts[i];
                        if (!pts || pts.length < 2) continue;
                        ctx.beginPath();
                        ctx.moveTo(pts[0].x, pts[0].y);
                        for (let k = 1; k < pts.length; k++) ctx.lineTo(pts[k].x, pts[k].y);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            } catch (e) {
                // fallback
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 12, 0, Math.PI * 2);
                ctx.strokeStyle = '#29B6F6';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        } else {
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 12, 0, Math.PI * 2);
            ctx.strokeStyle = '#29B6F6';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
    
    if (this.buffs.shield.active) {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
        ctx.strokeStyle = COLORS.shield;
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'rgba(0, 191, 255, 0.1)';
        ctx.fill();
    }
    

    // === HI·ªÜU ·ª®NG: JUGGERNAUT Q ‚Äî GI√ÅP PH·∫¢N (v√†ng kim, g·ªì gh·ªÅ, m·∫°nh m·∫Ω) ===
    if (this.systemId === 'juggernaut' && this.buffs.juggerShield && this.buffs.juggerShield.active && Date.now() <= this.buffs.juggerShield.endTime) {
        try {
            const nowJS = Date.now();
            const pulse = 0.55 + Math.sin(nowJS / 120) * 0.45;
            const t = nowJS / 1000;
            const desiredR = this.radius + 14;
            const dpr = ((typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1) || 1);

            // sprite armor ring (cache)
            const spr = __getJuggerShieldSprite(36, dpr);
            if (spr) {
                const scale = desiredR / spr.baseR;
                const drawS = spr.size * scale;

                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = 0;

                // plate ring (2 l·ªõp xoay nh·∫π)
                ctx.globalAlpha = 0.78 + 0.10 * pulse;
                ctx.rotate(t * 1.35);
                ctx.drawImage(spr.c, -drawS / 2, -drawS / 2, drawS, drawS);

                ctx.globalAlpha = 0.22 + 0.10 * pulse;
                ctx.rotate(-t * 2.2);
                ctx.drawImage(spr.c, -drawS / 2, -drawS / 2, drawS, drawS);

                // glint sweep (ph·∫£n chi·∫øu)
                const a0 = t * 3.0;
                ctx.globalAlpha = 0.16 + 0.20 * pulse;
                ctx.strokeStyle = 'rgba(255,255,255,0.55)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, desiredR + 2, a0, a0 + 0.9);
                ctx.stroke();

                // shard rays (nh√¨n ‚Äúph·∫£n s√°t th∆∞∆°ng‚Äù)
                ctx.globalAlpha = 0.10 + 0.18 * pulse;
                ctx.strokeStyle = 'rgba(255, 235, 59, 0.55)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const aa = a0 + i * (Math.PI * 2 / 6);
                    const x0 = Math.cos(aa) * (desiredR + 2);
                    const y0 = Math.sin(aa) * (desiredR + 2);
                    const x1 = Math.cos(aa) * (desiredR + 14);
                    const y1 = Math.sin(aa) * (desiredR + 14);
                    ctx.beginPath();
                    ctx.moveTo(x0, y0);
                    ctx.lineTo(x1, y1);
                    ctx.stroke();
                }

                ctx.restore();
            } else {
                // fallback simple ring
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 14, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 213, 79, 0.85)';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        } catch (e) {
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 14, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 213, 79, 0.85)';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }

    // === HI·ªÜU ·ª®NG: JUGGERNAUT E ‚Äî C√ö H√öC (uy l·ª±c, t·ªëi ∆∞u) ===
    if (this.systemId === 'juggernaut' && this.ram && this.ram.active && Date.now() <= this.ram.endTime) {
        try {
            const nowR = Date.now();
            const pulse = 0.5 + Math.sin(nowR / 75) * 0.5;
            const dpr = ((typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1) || 1);
            const trailSpr = __getJuggerRamTrailSprite(dpr);

            // direction of ram
            const vx = (this.ram.vx || 0);
            const vy = (this.ram.vy || 0);
            let ang = Math.atan2(vy, vx);
            if (!isFinite(ang)) ang = (this.angle || 0);

            // cache sparks (avoid random every frame)
            if (!this.__ramFxOpt) this.__ramFxOpt = { sparks: [], nextAt: 0 };
            const fx = this.__ramFxOpt;
            if (nowR >= (fx.nextAt || 0)) {
                fx.nextAt = nowR + 80;
                fx.sparks.length = 0;
                for (let i = 0; i < 7; i++) {
                    fx.sparks.push({
                        a: (Math.random() - 0.5) * 0.65,
                        l: 10 + Math.random() * 18,
                        w: 1.2 + Math.random() * 1.2
                    });
                }
            }

            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 0;

            // back trail ribbon
            ctx.save();
            ctx.rotate(ang + Math.PI);
            ctx.globalAlpha = 0.75 + 0.12 * pulse;
            const len = 190;
            ctx.drawImage(trailSpr.c, -len, -trailSpr.h / 2, len, trailSpr.h);
            ctx.globalAlpha = 0.18 + 0.12 * pulse;
            ctx.drawImage(trailSpr.c, -len * 0.8, -trailSpr.h / 2, len * 0.8, trailSpr.h);
            ctx.restore();

            // front impact cone
            ctx.save();
            ctx.rotate(ang);
            const sx = this.radius + 10;
            const tip = sx + 72;
            ctx.globalAlpha = 0.22 + 0.20 * pulse;
            ctx.fillStyle = 'rgba(255, 193, 7, 0.16)';
            ctx.strokeStyle = 'rgba(255, 235, 59, 0.38)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(sx, 0);
            ctx.lineTo(tip, -20);
            ctx.lineTo(tip + 10, 0);
            ctx.lineTo(tip, 20);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // shock ring at nose
            ctx.globalAlpha = 0.10 + 0.14 * pulse;
            ctx.strokeStyle = 'rgba(255, 152, 0, 0.35)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx + 18, 0, 18 + pulse * 4, -0.8, 0.8);
            ctx.stroke();

            // sparks
            ctx.globalAlpha = 0.20 + 0.25 * pulse;
            ctx.strokeStyle = 'rgba(255,255,255,0.45)';
            for (let i = 0; i < fx.sparks.length; i++) {
                const sp = fx.sparks[i];
                ctx.lineWidth = sp.w;
                ctx.beginPath();
                ctx.moveTo(tip, 0);
                ctx.lineTo(tip + Math.cos(sp.a) * sp.l, Math.sin(sp.a) * sp.l);
                ctx.stroke();
            }

            ctx.restore();
            ctx.restore();
        } catch (e) {
            // no-op
        }
    }


    // === HI·ªÜU ·ª®NG: JUGGERNAUT SIEGE MODE (R) ===
    // Hi·ªáu ·ª©ng ph√°o ƒë√†i: aura v√†ng + v√≤ng quay + x·∫£ nhi·ªát ph√≠a sau n√≤ng
    if (this.systemId === 'juggernaut' && this.buffs.siege && this.buffs.siege.active && Date.now() <= this.buffs.siege.endTime) {
        const now = Date.now();
        const t = now / 140;
        const pulse = 0.5 + Math.sin(t * 2.2) * 0.5;

        ctx.save();
        ctx.globalAlpha *= 0.95;

        const r = this.radius + 20 + pulse * 3;

        // Ground aura (ƒë·ªï s√°ng m·ªÅm)
        const aura = ctx.createRadialGradient(0, 0, 0, 0, 0, r + 26);
        aura.addColorStop(0, 'rgba(255, 193, 7, 0.00)');
        aura.addColorStop(0.55, `rgba(255, 193, 7, ${0.10 + 0.08 * pulse})`);
        aura.addColorStop(1, 'rgba(255, 193, 7, 0.00)');
        ctx.fillStyle = aura;
        ctx.beginPath();
        ctx.arc(0, 0, r + 26, 0, Math.PI * 2);
        ctx.fill();

        // Outer ring + rotating segments
        ctx.shadowBlur = 22;
        ctx.shadowColor = 'rgba(255, 193, 7, 0.85)';
        ctx.strokeStyle = `rgba(255, 213, 79, ${0.35 + 0.25 * pulse})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();

        ctx.shadowBlur = 16;
        ctx.shadowColor = 'rgba(255, 152, 0, 0.9)';
        ctx.lineWidth = 6;
        ctx.strokeStyle = `rgba(255, 152, 0, ${0.22 + 0.25 * pulse})`;
        const segs = 10;
        for (let i = 0; i < segs; i++) {
            const a0 = (t * 0.9) + i * (Math.PI * 2 / segs);
            ctx.beginPath();
            ctx.arc(0, 0, r - 6, a0, a0 + 0.35);
            ctx.stroke();
        }

        // Heat vents opposite turret direction (x·∫£ nhi·ªát ph√≠a sau)
        ctx.shadowBlur = 0;
        const dx = Math.cos(this.angle);
        const dy = Math.sin(this.angle);
        const px = -dy;
        const py = dx;
        ctx.lineWidth = 2;
        for (let i = -3; i <= 3; i++) {
            const wob = 0.5 + Math.sin(t * 3.1 + i) * 0.5;
            const len = 10 + wob * 14;
            const sx = (-dx) * (this.radius + 10) + px * (i * 3.2);
            const sy = (-dy) * (this.radius + 10) + py * (i * 3.2);
            const ex = sx + (-dx) * len;
            const ey = sy + (-dy) * len;

            ctx.strokeStyle = `rgba(255, 87, 34, ${0.25 + 0.35 * wob})`;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.stroke();

            ctx.fillStyle = `rgba(255, 235, 59, ${0.18 + 0.35 * wob})`;
            ctx.beginPath();
            ctx.arc(ex, ey, 1.8 + wob * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Inner plate (v√≤ng trong nh·∫π)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.18)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 8 + Math.sin(t * 1.8) * 1.5, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
    }

    // === N√ÇNG C·∫§P: Glow effect ===
    ctx.shadowBlur = 14;
    ctx.shadowColor = cfg.glow;

    // === GIAO DI·ªÜN THEO H·ªÜ (Chi·∫øn Binh / T·ªëc ƒê·ªô / K·ªπ S∆∞ / Gi√°p S·∫Øt / Ph√°p S∆∞) ===
    const __tNow = Date.now();
    const __sys = __sysId || 'default';

    // ∆Ø·ªõc l∆∞·ª£ng v·∫≠n t·ªëc ƒë·ªÉ v·∫Ω hi·ªáu ·ª©ng m·∫∑c ƒë·ªãnh (nh·∫π)
    if (!this.__gfxPrev) this.__gfxPrev = { x: this.x, y: this.y, t: __tNow };
    const __dxp = (this.x - this.__gfxPrev.x);
    const __dyp = (this.y - this.__gfxPrev.y);
    const __dtp = Math.max(1, (__tNow - this.__gfxPrev.t) || 16);
    const __spd = Math.hypot(__dxp, __dyp) * (16 / __dtp);
    this.__gfxPrev.x = this.x; this.__gfxPrev.y = this.y; this.__gfxPrev.t = __tNow;

    // Scale theo radius (n·∫øu sau n√†y thay ƒë·ªïi)
    const __baseR = 22;
    const __scale = ((this.radius || __baseR) / __baseR);
    if (!isNaN(__scale) && __scale > 0 && Math.abs(__scale - 1) > 0.001) ctx.scale(__scale, __scale);

    // K√≠ch th∆∞·ªõc th√¢n/track theo h·ªá
    const bw = (__sys === 'speed') ? 40 : (__sys === 'juggernaut') ? 46 : (__sys === 'mage') ? 42 : 44;
    const bh = (__sys === 'speed') ? 38 : (__sys === 'juggernaut') ? 46 : (__sys === 'mage') ? 42 : 44;
    const corner = (__sys === 'speed') ? 10 : (__sys === 'juggernaut') ? 5 : (__sys === 'mage') ? 8 : 6;

    const gap = (__sys === 'juggernaut') ? 5 : 4;
    const trackW = (__sys === 'speed') ? 7 : (__sys === 'juggernaut') ? 10 : 8;
    const trackH = bh + 4;
    const leftX = -(bw / 2 + gap);
    const rightX = (bw / 2 - gap);

    // --- Hi·ªáu ·ª©ng m·∫∑c ƒë·ªãnh (nh·∫π) d∆∞·ªõi xe ---
    (function(){
        const t = __tNow * 0.001;
        ctx.save();
        if (__sys === 'mage') {
            ctx.globalAlpha = 0.14;
            ctx.strokeStyle = __colorWithAlpha(cfg.accent || '#B3E5FC', 0.30);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, (this.radius || 22) + 10 + Math.sin(t * 2) * 1.5, 0, Math.PI * 2);
            ctx.stroke();
            // 4 h·∫°t bƒÉng nh·ªè
            ctx.globalAlpha = 0.45;
            ctx.fillStyle = __colorWithAlpha(cfg.accent || '#B3E5FC', 0.55);
            for (let i = 0; i < 4; i++) {
                const a = t * 1.3 + i * (Math.PI * 2 / 4);
                ctx.beginPath();
                ctx.arc(Math.cos(a) * 18, Math.sin(a) * 18, 2.1, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (__sys === 'speed' && __spd > 0.7) {
            // speed lines nh·∫π khi di chuy·ªÉn
            const ang = Math.atan2(__dyp, __dxp);
            const dx = Math.cos(ang), dy = Math.sin(ang);
            ctx.globalAlpha = 0.28;
            ctx.strokeStyle = __colorWithAlpha(cfg.accent || '#00E5FF', 0.38);
            ctx.lineWidth = 2;
            for (let i = -1; i <= 1; i++) {
                const px = -dy * (i * 6);
                const py = dx * (i * 6);
                ctx.beginPath();
                ctx.moveTo(-dx * 10 + px, -dy * 10 + py);
                ctx.lineTo(-dx * 26 + px, -dy * 26 + py);
                ctx.stroke();
            }
        } else if (__sys === 'engineer') {
            // nh·ªãp nƒÉng l∆∞·ª£ng nh·ªè
            ctx.globalAlpha = 0.14;
            ctx.strokeStyle = __colorWithAlpha(cfg.accent || '#FFAB00', 0.28);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 18 + Math.sin(t * 3.1) * 1.2, 0, Math.PI * 2);
            ctx.stroke();
        } else if (__sys === 'juggernaut' && __spd > 0.6) {
            // b·ª•i n·∫∑ng nh·∫π
            ctx.globalAlpha = 0.14;
            ctx.fillStyle = 'rgba(160, 160, 160, 0.14)';
            ctx.beginPath();
            ctx.ellipse(-10, 16, 10, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(10, 16, 10, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }).call(this);

    // === X√çCH XE ===
    ctx.shadowBlur = 0;
    ctx.fillStyle = (cfg.track || '#1a1a1a');
    ctx.fillRect(leftX, -trackH/2, trackW, trackH);
    ctx.fillRect(rightX, -trackH/2, trackW, trackH);

    // Chi ti·∫øt x√≠ch
    ctx.fillStyle = (cfg.trackDetail || '#333');
    const step = (__sys === 'speed') ? 7 : (__sys === 'juggernaut') ? 9 : 8;
    for (let i = -trackH/2 + 4; i < trackH/2 - 4; i += step) {
        const w = Math.max(3, trackW - 2);
        ctx.fillRect(leftX + 1, i, w, 3);
        ctx.fillRect(rightX + 1, i, w, 3);
    }

    // === TH√ÇN XE (theo h·ªá) ===
    ctx.shadowBlur = 14;
    ctx.shadowColor = cfg.glow;

    const bodyGrad = createTankGradient(0, 0, Math.max(bw, bh) * 0.55, cfg.body);
    ctx.fillStyle = bodyGrad;
    ctx.beginPath();
    ctx.roundRect(-bw/2, -bh/2, bw, bh, corner);
    ctx.fill();

    // Highlight tr√™n th√¢n
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath();
    ctx.roundRect(-bw/2 + 3, -bh/2 + 3, bw * 0.45, bh * 0.22, Math.max(2, corner - 3));
    ctx.fill();

    // --- Decal/chi ti·∫øt theo h·ªá ---
    const rivet = (x,y) => {
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath(); ctx.arc(x, y, 1.8, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.22)';
        ctx.beginPath(); ctx.arc(x-0.5, y-0.5, 0.8, 0, Math.PI * 2); ctx.fill();
    };

    if (__sys === 'engineer') {
        // Hazard stripe + bolts + antenna
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = 'rgba(255,171,0,0.20)';
        ctx.fillRect(-bw/2 + 4, 3, bw - 8, 8);
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 2;
        for (let x = -bw/2 + 6; x < bw/2 - 6; x += 6) {
            ctx.beginPath();
            ctx.moveTo(x, 3);
            ctx.lineTo(x + 6, 11);
            ctx.stroke();
        }
        for (const p of [[-bw/2+5,-bh/2+5],[bw/2-5,-bh/2+5],[-bw/2+5,bh/2-5],[bw/2-5,bh/2-5]]) rivet(p[0],p[1]);

        // Antenna
        ctx.strokeStyle = 'rgba(200,200,200,0.75)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bw/2-10, -bh/2+6);
        ctx.lineTo(bw/2-6, -bh/2-10);
        ctx.stroke();
        ctx.fillStyle = __colorWithAlpha(cfg.accent, 0.85);
        ctx.beginPath();
        ctx.arc(bw/2-6, -bh/2-10, 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    } else if (__sys === 'juggernaut') {
        // Plating n·∫∑ng + rivets + vi·ªÅn gi√°p
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 213, 79, 0.22)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(-bw/2+2, -bh/2+2, bw-4, bh-4, corner);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(0,0,0,0.28)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-bw*0.15, -bh/2+3);
        ctx.lineTo(-bw*0.15, bh/2-3);
        ctx.moveTo(bw*0.15, -bh/2+3);
        ctx.lineTo(bw*0.15, bh/2-3);
        ctx.stroke();

        for (const p of [[-bw/2+6,-bh/2+6],[bw/2-6,-bh/2+6],[-bw/2+6,bh/2-6],[bw/2-6,bh/2-6],[-bw*0.15,0],[bw*0.15,0]]) rivet(p[0],p[1]);

        // Front plow
        ctx.fillStyle = 'rgba(0,0,0,0.22)';
        ctx.beginPath();
        ctx.moveTo(-bw/2, -8);
        ctx.lineTo(-bw/2-6, 0);
        ctx.lineTo(-bw/2, 8);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    } else if (__sys === 'speed') {
        // Th√¢n thon + fins
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = 'rgba(0,0,0,0.18)';
        ctx.beginPath();
        ctx.moveTo(-bw/2+4, -10);
        ctx.lineTo(-bw/2-8, -2);
        ctx.lineTo(-bw/2+4, 6);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(bw/2-4, -10);
        ctx.lineTo(bw/2+8, -2);
        ctx.lineTo(bw/2-4, 6);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = __colorWithAlpha(cfg.accent, 0.32);
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-bw/2+6, 0);
        ctx.lineTo(bw/2-6, 0);
        ctx.stroke();
        ctx.restore();
    } else if (__sys === 'mage') {
        // Crystal corners + rune dots
        ctx.save();
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = __colorWithAlpha(cfg.accent, 0.30);
        const cr = 7;
        for (const p of [[-bw/2+6,-bh/2+6],[bw/2-6,-bh/2+6],[-bw/2+6,bh/2-6],[bw/2-6,bh/2-6]]) {
            ctx.beginPath();
            ctx.moveTo(p[0], p[1]-cr);
            ctx.lineTo(p[0]+cr, p[1]);
            ctx.lineTo(p[0], p[1]+cr);
            ctx.lineTo(p[0]-cr, p[1]);
            ctx.closePath();
            ctx.fill();
        }
        ctx.globalAlpha = 0.55;
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        for (let i = 0; i < 8; i++) {
            const a = (__tNow * 0.002) + i * (Math.PI * 2 / 8);
            ctx.beginPath();
            ctx.arc(Math.cos(a)*14, Math.sin(a)*14, 1.2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    } else {
        // Warrior: front ram + crest
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = 'rgba(0,0,0,0.22)';
        ctx.beginPath();
        ctx.moveTo(0, -bh/2);
        ctx.lineTo(10, -bh/2-8);
        ctx.lineTo(20, -bh/2);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(0, bh/2);
        ctx.lineTo(10, bh/2+8);
        ctx.lineTo(20, bh/2);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = __colorWithAlpha(cfg.accent || '#FF5252', 0.25);
        ctx.beginPath();
        ctx.roundRect(-6, -6, 12, 12, 3);
        ctx.fill();
        ctx.restore();
    }

    // === TH√ÅP PH√ÅO (theo h·ªá) ===
    ctx.rotate(this.angle);

    const wObj = this.getCurrentWeaponObj();
    const wConfig = (BULLET_TYPES && wObj && wObj.id && BULLET_TYPES[wObj.id]) ? BULLET_TYPES[wObj.id] : { color: '#ffffff' };
    const muzzleColor = __safeColor(wConfig.color, (cfg.accent || '#ffffff'));

    const turretR = (__sys === 'speed') ? 16 : (__sys === 'juggernaut') ? 20 : 18;
    const barrelLen = (__sys === 'speed') ? 46 : (__sys === 'juggernaut') ? 38 : 42;
    const barrelW = (__sys === 'speed') ? 10 : (__sys === 'juggernaut') ? 14 : 12;

    // ƒê·∫ø th√°p ph√°o
    const turretGrad = ctx.createRadialGradient(-3, -3, 0, 0, 0, turretR);
    turretGrad.addColorStop(0, cfg.turret[1]);
    turretGrad.addColorStop(1, cfg.turret[0]);
    ctx.fillStyle = turretGrad;

    // Engineer: base ki·ªÉu gear
    if (__sys === 'engineer') {
        ctx.beginPath();
        const teeth = 10;
        for (let i = 0; i < teeth; i++) {
            const a = i * (Math.PI * 2 / teeth);
            const r1 = turretR * 0.92;
            const r2 = turretR * 1.06;
            const r = (i % 2 === 0) ? r2 : r1;
            const x = Math.cos(a) * r;
            const y = Math.sin(a) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 2;
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(0, 0, turretR, 0, Math.PI * 2);
        ctx.fill();
    }

    // Mage: rune ring
    if (__sys === 'mage') {
        ctx.save();
        ctx.globalAlpha = 0.55;
        ctx.strokeStyle = __colorWithAlpha(cfg.accent, 0.35);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, turretR + 3, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        for (let i = 0; i < 8; i++) {
            const a = (__tNow * 0.003) + i * (Math.PI * 2 / 8);
            ctx.beginPath();
            ctx.arc(Math.cos(a) * (turretR + 3), Math.sin(a) * (turretR + 3), 1.2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }

    // N√≤ng s√∫ng
    const barrelGrad = ctx.createLinearGradient(0, -barrelW/2, 0, barrelW/2);
    barrelGrad.addColorStop(0, '#555');
    barrelGrad.addColorStop(0.35, '#777');
    barrelGrad.addColorStop(0.75, '#555');
    barrelGrad.addColorStop(1, '#333');
    ctx.fillStyle = barrelGrad;
    ctx.fillRect(0, -barrelW/2, barrelLen, barrelW);

    // Gia c·ªë n√≤ng (Jugger n·∫∑ng)
    if (__sys === 'juggernaut') {
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(6, -barrelW/2 - 2, 16, 4);
        ctx.fillRect(6, barrelW/2 - 2, 16, 4);
    }

    // ƒê·∫ßu n√≤ng ph√°t s√°ng theo v≈© kh√≠
    ctx.fillStyle = muzzleColor;
    ctx.shadowBlur = 8;
    ctx.shadowColor = muzzleColor;
    ctx.fillRect(barrelLen - 5, -barrelW/2 - 1, 10, barrelW + 2);

    // Highlight n√≤ng
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(5, -barrelW/2 + 2, Math.max(10, barrelLen * 0.55), 3);

    // Chi ti·∫øt th√°p ph√°o
    ctx.fillStyle = 'rgba(0,0,0,0.30)';
    ctx.beginPath();
    ctx.arc(0, 0, Math.max(6, turretR * 0.45), 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();

    // V·∫Ω B√£o Tuy·∫øt (Mage) ‚Äî BLIZZARD STORM (s·ª©c m·∫°nh thi√™n nhi√™n)
    // T·ªëi ∆∞u: d√πng sprite cache + streak regen theo nh·ªãp, clip trong v√≤ng tr√≤n
    if (this.systemId === 'mage' && this.mage && this.mage.blizzard && this.mage.blizzard.active) {
        const bz = this.mage.blizzard;
        const skillCfg = getSystemSkillDef('mage', 'vampirism') || {};
        const outerR = (skillCfg.radius != null) ? skillCfg.radius : 220;
        const innerR = (skillCfg.innerRadius != null) ? skillCfg.innerRadius : 70;

        const now = Date.now();
        const t = now * 0.001;
        const TAU = Math.PI * 2;
        const dpr = ((typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1) || 1);

        // FX state (per blizzard instance)
        if (!bz.__stormFx) {
            const winds = [];
            const n = 22;
            for (let i = 0; i < n; i++) {
                const a = (i / n) * TAU;
                winds.push({
                    a0: a,
                    r0: (0.18 + (i % 7) / 7 * 0.75),
                    spd: 0.9 + (i % 5) * 0.18,
                    len: 45 + (i % 6) * 18,
                    wid: 1.2 + (i % 3) * 0.6,
                    phase: (i * 17) % 360
                });
            }
            bz.__stormFx = { last: 0, winds, gust: 0 };
        }
        const fx = bz.__stormFx;

        // regen theo nh·ªãp ƒë·ªÉ tr√°nh random/loop n·∫∑ng m·ªói frame
        if (!fx.last || (now - fx.last) > 90) {
            fx.last = now;
            fx.gust = (fx.gust + 1) % 100000;
        }

        const fogA = __getBlizzardFogSprite(outerR, 0, dpr);
        const fogB = __getBlizzardFogSprite(outerR, 1, dpr);
        const wall = __getBlizzardWallSprite(outerR, dpr);
        const streak = __getBlizzardStreakSprite(dpr);

        ctx.save();
        ctx.translate(bz.x, bz.y);

        // ---- clip trong v√πng b√£o ----
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, outerR, 0, TAU);
        ctx.clip();

        // Base mist fill (nh·∫π nh∆∞ng d√†y)
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = 'rgba(0, 229, 255, 0.10)';
        ctx.beginPath();
        ctx.arc(0, 0, outerR, 0, TAU);
        ctx.fill();

        // Fog layers (sprite cache)
        if (fogA) {
            ctx.save();
            ctx.globalAlpha = 0.26;
            ctx.rotate(t * 0.35);
            ctx.drawImage(fogA.c, -fogA.size / 2, -fogA.size / 2, fogA.size, fogA.size);
            ctx.restore();
        }
        if (fogB) {
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.rotate(-t * 0.52);
            ctx.drawImage(fogB.c, -fogB.size / 2, -fogB.size / 2, fogB.size, fogB.size);
            ctx.restore();
        }

        // Wind streaks ‚Äî "c∆°n b√£o cu·ªën" (streak sprite)
        if (streak) {
            const count = fx.winds.length;
            const swirlDir = 1;
            for (let i = 0; i < count; i++) {
                const w = fx.winds[i];
                const ang = w.a0 + swirlDir * (t * w.spd) + Math.sin((fx.gust + i) * 0.17) * 0.08;
                const rr = outerR * (w.r0 + 0.06 * Math.sin(t * 1.9 + i));

                const x = Math.cos(ang) * rr;
                const y = Math.sin(ang) * rr;

                ctx.save();
                ctx.globalAlpha = 0.35;
                ctx.translate(x, y);
                ctx.rotate(ang + Math.PI / 2);

                const edgeFade = Math.max(0, Math.min(1, 1 - (rr / outerR) * 0.9));
                ctx.globalAlpha *= (0.55 + edgeFade);

                const ww = streak.w;
                const hh = streak.h;
                const scaleL = (w.len / 140);
                const scaleW = (w.wid / 2.0);
                ctx.scale(scaleL, scaleW);
                ctx.drawImage(streak.c, -ww * 0.55, -hh * 0.5, ww, hh);
                ctx.restore();
            }
        }

        // Inner eye (trung t√¢m b√¨nh y√™n h∆°n, v·∫´n c√≥ tuy·∫øt xo√°y)
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.beginPath();
        ctx.arc(0, 0, innerR, 0, TAU);
        ctx.fill();

        ctx.globalAlpha = 0.55;
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        for (let i = 0; i < 10; i++) {
            const a = t * 2.0 + i * (TAU / 10);
            const r = innerR * (0.25 + 0.35 * Math.sin(t * 1.4 + i));
            ctx.beginPath();
            ctx.arc(Math.cos(a) * r, Math.sin(a) * r, 2.2, 0, TAU);
            ctx.fill();
        }
        ctx.restore();

        ctx.restore(); // end clip

        // ---- Storm wall ring (sprite cache) ----
        if (wall) {
            ctx.save();
            ctx.globalAlpha = 0.75;
            ctx.rotate(t * 0.45);
            ctx.drawImage(wall.c, -wall.size / 2, -wall.size / 2, wall.size, wall.size);
            ctx.restore();
        }

        // Outer outline + pulse
        const pulse = 0.65 + Math.sin(t * 6.0) * 0.12;
        ctx.strokeStyle = skillCfg.color || 'rgba(0,229,255,0.7)';
        ctx.globalAlpha = 0.65;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, outerR, 0, TAU);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.globalAlpha = 0.55 * pulse;
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 12]);
        ctx.beginPath();
        ctx.arc(0, 0, outerR - 10, 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]);

        // Inner outline (eye)
        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.40)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, innerR, 0, TAU);
        ctx.stroke();

        // Locked = m·∫Øt b√£o "kh√≥a" m·ª•c ti√™u
        if (bz.locked) {
            ctx.globalAlpha = 0.90;
            ctx.strokeStyle = 'rgba(255,255,255,0.85)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, innerR + 10 + Math.sin(t * 3.0) * 3, 0, TAU);
            ctx.stroke();

            ctx.globalAlpha = 0.55;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-innerR * 0.65, 0);
            ctx.lineTo(innerR * 0.65, 0);
            ctx.moveTo(0, -innerR * 0.65);
            ctx.lineTo(0, innerR * 0.65);
            ctx.stroke();
        }

        ctx.restore();
    }
};

// ===== GHI ƒê√à PH∆Ø∆†NG TH·ª®C DRAW C·ª¶A ENEMY =====
const _originalEnemyDraw = Enemy.prototype.draw;
Enemy.prototype.draw = function() {
    const cfg = GFX.ENEMIES[this.typeKey] || GFX.ENEMIES.RED;
    
    // BOSS v·∫Ω ri√™ng
    if (this.typeKey === 'BOSS') {
        this.drawBoss();
        return;
    }
    
    ctx.save();
    ctx.translate(this.x, this.y);
    
    // Hi·ªáu ·ª©ng stun
    if (this.effects.stun.active) {
        ctx.strokeStyle = '#00BCD4';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Glow
    ctx.shadowBlur = 12;
    ctx.shadowColor = cfg.glow;
    
    // X√≠ch xe (cho BLACK)
    if (this.typeKey === 'BLACK') {
        ctx.fillStyle = '#111';
        ctx.fillRect(-this.radius - 3, -this.radius, 6, this.radius * 2);
        ctx.fillRect(this.radius - 3, -this.radius, 6, this.radius * 2);
    }
    
    // Th√¢n xe v·ªõi gradient
    const bodyGrad = createTankGradient(0, 0, this.radius, cfg.body);
    ctx.fillStyle = bodyGrad;
    
    // Vi·ªÅn cho BLACK
    if (cfg.outline) {
        ctx.strokeStyle = cfg.outline;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2, 4);
        ctx.stroke();
    }
    
    ctx.beginPath();
    ctx.roundRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2, 4);
    ctx.fill();
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath();
    ctx.roundRect(-this.radius + 3, -this.radius + 3, this.radius - 3, this.radius / 2, 2);
    ctx.fill();
    
    // Th√°p ph√°o
    ctx.rotate(this.angle);
    ctx.shadowBlur = 0;
    
    // ƒê·∫ø th√°p
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2);
    ctx.fill();
    
    // N√≤ng s√∫ng
    ctx.fillStyle = '#333';
    ctx.fillRect(0, -5, this.radius + 5, 10);
    
    // ƒê·∫ßu n√≤ng
    const bulletColor = this.typeKey === 'YELLOW' ? '#FFF59D' : '#E040FB';
    ctx.fillStyle = bulletColor;
    ctx.fillRect(this.radius, -6, 6, 12);
    
    ctx.restore();
    
    // Thanh m√°u (kh√¥ng ph·∫£i BOSS)
    const hpPercent = this.hp / this.maxHp;
    ctx.fillStyle = '#333';
    ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30, 5);
    
    const hpGrad = ctx.createLinearGradient(this.x - 15, 0, this.x + 15, 0);
    if (hpPercent > 0.5) {
        hpGrad.addColorStop(0, '#4CAF50');
        hpGrad.addColorStop(1, '#8BC34A');
    } else if (hpPercent > 0.25) {
        hpGrad.addColorStop(0, '#FF9800');
        hpGrad.addColorStop(1, '#FFC107');
    } else {
        hpGrad.addColorStop(0, '#f44336');
        hpGrad.addColorStop(1, '#E91E63');
    }
    ctx.fillStyle = hpGrad;
    ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30 * hpPercent, 5);
};

// ===== PH∆Ø∆†NG TH·ª®C V·∫º BOSS =====
Enemy.prototype.drawBoss = function() {
    const cfg = GFX.ENEMIES.BOSS;
    const size = this.radius;
    
    ctx.save();
    ctx.translate(this.x, this.y);
    
    // Aura cu·ªìng n·ªô
    if (this.bossAI && this.bossAI.enraged) {
        const pulse = 0.5 + Math.sin(Date.now() / 80) * 0.3;
        ctx.fillStyle = `rgba(255, 23, 68, ${0.1 * pulse})`;
        ctx.beginPath();
        ctx.arc(0, 0, size * 1.8, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = `rgba(255, 23, 68, ${0.6 * pulse})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // B√≥ng ƒë·ªï
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(5, 8, size * 0.9, size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Glow
    ctx.shadowBlur = 30;
    ctx.shadowColor = cfg.glow;
    
    // Th√¢n boss - h√¨nh l·ª•c gi√°c
    const bodyGrad = createTankGradient(0, 0, size, cfg.body);
    ctx.fillStyle = bodyGrad;
    
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const px = Math.cos(angle) * size;
        const py = Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    
    // Vi·ªÅn v√†ng
    ctx.strokeStyle = '#FFEB3B';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // L√µi nƒÉng l∆∞·ª£ng
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
    ctx.fill();
    
    const corePulse = 0.8 + Math.sin(Date.now() / 200) * 0.2;
    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.5);
    coreGrad.addColorStop(0, cfg.core[2]);
    coreGrad.addColorStop(0.5, cfg.core[1]);
    coreGrad.addColorStop(1, cfg.core[0]);
    
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.4 * corePulse, 0, Math.PI * 2);
    ctx.fill();
    
    // M·∫Øt/c·∫£m bi·∫øn
    ctx.fillStyle = '#FFEB3B';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#FFEB3B';
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    // Th√°p ph√°o ƒëa n√≤ng
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    const barrelLength = size * 1.2;
    const barrelWidth = 12;
    
    // ƒê·∫ø th√°p
    ctx.fillStyle = '#7F0000';
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
    ctx.fill();
    
    // N√≤ng ch√≠nh
    ctx.fillStyle = '#424242';
    ctx.fillRect(0, -barrelWidth/2, barrelLength, barrelWidth);
    
    // N√≤ng ph·ª•
    ctx.fillRect(0, -barrelWidth * 1.5, barrelLength * 0.8, barrelWidth * 0.7);
    ctx.fillRect(0, barrelWidth * 0.8, barrelLength * 0.8, barrelWidth * 0.7);
    
    // ƒê·∫ßu n√≤ng ph√°t s√°ng
    ctx.fillStyle = '#FF5722';
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#FF5722';
    ctx.fillRect(barrelLength - 5, -barrelWidth/2 - 2, 8, barrelWidth + 4);
    
    ctx.restore();
    
    // Telegraph (gi·ªØ nguy√™n t·ª´ code g·ªëc)
    if (this.bossAI) {
        const now2 = Date.now();
        const ai = this.bossAI;

        if (ai.state === 'charge_windup') {
            ctx.save();
            ctx.strokeStyle = 'rgba(255,23,68,0.9)';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + Math.cos(ai.chargeDir) * 280, this.y + Math.sin(ai.chargeDir) * 280);
            ctx.stroke();
            ctx.restore();
        }

        if (ai.state === 'radial_windup') {
            ctx.save();
            const t = Math.max(0, Math.min(1, (ai.stateEnd - now2) / 550));
            const r = 110 + (1 - t) * 50;
            ctx.strokeStyle = 'rgba(255,23,68,0.75)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        if (ai.state === 'summon_cast') {
            ctx.save();
            const t = Math.max(0, Math.min(1, (ai.stateEnd - now2) / 650));
            const r = 90 + (1 - t) * 70;
            ctx.strokeStyle = 'rgba(255,235,59,0.75)';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
        }
    }
};

// ===== GHI ƒê√à PH∆Ø∆†NG TH·ª®C DRAW C·ª¶A BULLET =====
const _originalBulletDraw = Bullet.prototype.draw;

// Bullet sprite cache (nh·∫π FPS)
const __BULLET_GFX = { sprites: new Map() };

function __bulletRoundRectPath(g, x, y, w, h, r) {
    r = Math.max(0, Math.min(r, Math.min(w, h) / 2));
    g.beginPath();
    g.moveTo(x + r, y);
    g.lineTo(x + w - r, y);
    g.arcTo(x + w, y, x + w, y + r, r);
    g.lineTo(x + w, y + h - r);
    g.arcTo(x + w, y + h, x + w - r, y + h, r);
    g.lineTo(x + r, y + h);
    g.arcTo(x, y + h, x, y + h - r, r);
    g.lineTo(x, y + r);
    g.arcTo(x, y, x + r, y, r);
    g.closePath();
}

function __getBulletSprite(typeKey, baseColor, radius, dpr) {
    try {
        dpr = dpr || 1;
        radius = Math.max(2, radius || 4);
        const col = __safeColor(baseColor, '#FFFFFF');
        const key = `${typeKey}|${col}|${Math.round(radius*10)/10}|${dpr}`;
        if (__BULLET_GFX.sprites.has(key)) return __BULLET_GFX.sprites.get(key);

        const r = radius;
        const L = r * 5.2; // base length budget
        const W = r * 2.6;
        const pad = 18;
        const cw = Math.ceil((L + pad * 2) * dpr);
        const ch = Math.ceil((W + pad * 2) * dpr);

        const c = document.createElement('canvas');
        c.width = cw; c.height = ch;
        const g = c.getContext('2d');
        g.clearRect(0, 0, cw, ch);

        g.save();
        g.translate(cw / 2, ch / 2);
        g.scale(dpr, dpr);

        const colA = (a) => __colorWithAlpha(col, a);

        // Common soft outer glow (draw once in sprite)
        if (typeKey !== 'PIERCING') {
            const og = g.createRadialGradient(-r*0.6, -r*0.6, 0, 0, 0, r*2.6);
            og.addColorStop(0, colA(0.55));
            og.addColorStop(0.5, colA(0.18));
            og.addColorStop(1, 'transparent');
            g.fillStyle = og;
            g.beginPath();
            g.arc(0, 0, r*2.4, 0, Math.PI*2);
            g.fill();
        }

        switch (typeKey) {
            case 'NORMAL': {
                // Metallic slug (capsule) with tiny tip
                const bodyL = r*3.9, bodyW = r*1.35;
                const grad = g.createLinearGradient(-bodyL/2, 0, bodyL/2, 0);
                grad.addColorStop(0, 'rgba(255,255,255,0.95)');
                grad.addColorStop(0.25, 'rgba(210,210,210,0.95)');
                grad.addColorStop(0.55, 'rgba(140,140,140,0.95)');
                grad.addColorStop(1, 'rgba(255,255,255,0.75)');
                g.fillStyle = grad;
                __bulletRoundRectPath(g, -bodyL/2, -bodyW/2, bodyL, bodyW, bodyW/2);
                g.fill();

                // Tip cone
                g.fillStyle = 'rgba(255,255,255,0.9)';
                g.beginPath();
                g.moveTo(bodyL/2, -bodyW/2);
                g.lineTo(bodyL/2 + r*0.9, 0);
                g.lineTo(bodyL/2, bodyW/2);
                g.closePath();
                g.fill();

                // Small highlight line
                g.strokeStyle = 'rgba(255,255,255,0.55)';
                g.lineWidth = 1;
                g.beginPath();
                g.moveTo(-bodyL/2 + r*0.3, -bodyW*0.18);
                g.lineTo(bodyL/2 - r*0.1, -bodyW*0.18);
                g.stroke();

                // Color ring at base (subtle)
                g.strokeStyle = colA(0.65);
                g.lineWidth = 1.5;
                g.beginPath();
                g.arc(-bodyL/2 + r*0.2, 0, r*0.55, 0, Math.PI*2);
                g.stroke();
                break;
            }

            case 'STUN': {
                // Cyan stun orb with rings + shock cross
                const rg = g.createRadialGradient(-r*0.4, -r*0.4, 0, 0, 0, r*1.9);
                rg.addColorStop(0, 'rgba(255,255,255,0.95)');
                rg.addColorStop(0.25, colA(0.95));
                rg.addColorStop(0.8, colA(0.35));
                rg.addColorStop(1, 'transparent');
                g.fillStyle = rg;
                g.beginPath(); g.arc(0,0,r*1.35,0,Math.PI*2); g.fill();

                g.strokeStyle = colA(0.75);
                g.lineWidth = 2;
                g.beginPath(); g.arc(0,0,r*1.25,0,Math.PI*2); g.stroke();
                g.globalAlpha = 0.55;
                g.beginPath(); g.arc(0,0,r*0.75,0,Math.PI*2); g.stroke();
                g.globalAlpha = 1;

                g.strokeStyle = 'rgba(255,255,255,0.85)';
                g.lineWidth = 1.5;
                g.beginPath();
                g.moveTo(-r*0.55, 0); g.lineTo(r*0.55, 0);
                g.moveTo(0, -r*0.55); g.lineTo(0, r*0.55);
                g.stroke();
                break;
            }

            case 'LIGHTNING': {
                // Bolt shard (zigzag spear)
                const boltL = r*4.6;
                const boltW = r*1.25;

                g.fillStyle = colA(0.95);
                g.beginPath();
                g.moveTo(-boltL/2, -boltW*0.2);
                g.lineTo(-boltL*0.05, -boltW*0.7);
                g.lineTo(-boltL*0.15, -boltW*0.15);
                g.lineTo(boltL*0.15, -boltW*0.85);
                g.lineTo(boltL*0.05, -boltW*0.1);
                g.lineTo(boltL/2, 0);
                g.lineTo(boltL*0.05, boltW*0.1);
                g.lineTo(boltL*0.15, boltW*0.85);
                g.lineTo(-boltL*0.15, boltW*0.15);
                g.lineTo(-boltL*0.05, boltW*0.7);
                g.lineTo(-boltL/2, boltW*0.2);
                g.closePath();
                g.fill();

                g.strokeStyle = 'rgba(255,255,255,0.8)';
                g.lineWidth = 1.25;
                g.beginPath();
                g.moveTo(-boltL/2 + r*0.3, 0);
                g.lineTo(boltL/2 - r*0.2, 0);
                g.stroke();
                break;
            }

            case 'FIRE': {
                // Flame droplet
                const flameL = r*4.8;
                const flameW = r*2.4;

                const fg = g.createLinearGradient(-flameL/2, 0, flameL/2, 0);
                fg.addColorStop(0, 'rgba(255,235,59,0.95)');
                fg.addColorStop(0.35, 'rgba(255,152,0,0.92)');
                fg.addColorStop(1, colA(0.95));

                g.fillStyle = fg;
                g.beginPath();
                g.moveTo(flameL*0.55, 0);
                g.quadraticCurveTo(flameL*0.15, -flameW*0.55, -flameL*0.35, 0);
                g.quadraticCurveTo(flameL*0.15, flameW*0.55, flameL*0.55, 0);
                g.closePath();
                g.fill();

                // inner core
                g.fillStyle = 'rgba(255,255,255,0.55)';
                g.beginPath();
                g.moveTo(flameL*0.35, 0);
                g.quadraticCurveTo(flameL*0.10, -flameW*0.28, -flameL*0.15, 0);
                g.quadraticCurveTo(flameL*0.10, flameW*0.28, flameL*0.35, 0);
                g.closePath();
                g.fill();
                break;
            }

            case 'PIERCING': {
                // Needle + arrowhead (no big glow)
                const needleL = r*5.6;
                const needleW = Math.max(2, r*0.75);

                g.fillStyle = colA(0.95);
                __bulletRoundRectPath(g, -needleL/2, -needleW/2, needleL*0.78, needleW, needleW/2);
                g.fill();

                g.beginPath();
                g.moveTo(needleL*0.28, -needleW*0.9);
                g.lineTo(needleL/2, 0);
                g.lineTo(needleL*0.28, needleW*0.9);
                g.closePath();
                g.fill();

                g.strokeStyle = 'rgba(255,255,255,0.6)';
                g.lineWidth = 1;
                g.beginPath();
                g.moveTo(-needleL/2 + r*0.25, -needleW*0.18);
                g.lineTo(needleL*0.25, -needleW*0.18);
                g.stroke();
                break;
            }

            case 'HOMING': {
                // Arcane orb + fins (spin in main draw)
                const rg = g.createRadialGradient(-r*0.45, -r*0.45, 0, 0, 0, r*1.9);
                rg.addColorStop(0, 'rgba(255,255,255,0.85)');
                rg.addColorStop(0.25, colA(0.95));
                rg.addColorStop(0.85, colA(0.35));
                rg.addColorStop(1, 'transparent');

                g.fillStyle = rg;
                g.beginPath(); g.arc(0,0,r*1.35,0,Math.PI*2); g.fill();

                g.strokeStyle = colA(0.75);
                g.lineWidth = 2;
                g.beginPath(); g.arc(0,0,r*1.25,0,Math.PI*2); g.stroke();

                // orbit ring
                g.globalAlpha = 0.55;
                g.lineWidth = 1.5;
                g.beginPath(); g.ellipse(0,0,r*1.55,r*0.85,0.2,0,Math.PI*2); g.stroke();
                g.globalAlpha = 1;

                // fins (3)
                g.fillStyle = colA(0.9);
                for (let i=0;i<3;i++){
                    const a = i*(Math.PI*2/3);
                    const x = Math.cos(a)*r*1.35;
                    const y = Math.sin(a)*r*1.35;
                    g.save();
                    g.translate(x,y);
                    g.rotate(a);
                    g.beginPath();
                    g.moveTo(0,0);
                    g.lineTo(r*0.85, r*0.22);
                    g.lineTo(r*0.85,-r*0.22);
                    g.closePath();
                    g.fill();
                    g.restore();
                }

                // core
                g.fillStyle = 'rgba(0,0,0,0.35)';
                g.beginPath(); g.arc(0,0,r*0.55,0,Math.PI*2); g.fill();
                g.fillStyle = 'rgba(255,255,255,0.65)';
                g.beginPath(); g.arc(-r*0.18,-r*0.18,r*0.20,0,Math.PI*2); g.fill();
                break;
            }

            default: {
                // Generic energy orb
                const rg = g.createRadialGradient(-r*0.45, -r*0.45, 0, 0, 0, r*2.0);
                rg.addColorStop(0, 'rgba(255,255,255,0.85)');
                rg.addColorStop(0.3, colA(0.9));
                rg.addColorStop(0.9, colA(0.25));
                rg.addColorStop(1, 'transparent');
                g.fillStyle = rg;
                g.beginPath(); g.arc(0,0,r*1.4,0,Math.PI*2); g.fill();
                g.strokeStyle = colA(0.55);
                g.lineWidth = 1.5;
                g.beginPath(); g.arc(0,0,r*1.25,0,Math.PI*2); g.stroke();
                break;
            }
        }

        g.restore();

        const sprite = { canvas: c, w: cw / dpr, h: ch / dpr };
        __BULLET_GFX.sprites.set(key, sprite);
        return sprite;
    } catch (e) {
        return null;
    }
}

Bullet.prototype.draw = function() {
    ctx.save();

    const tk = this.typeKey;
    const baseColor = __safeColor(this.config && this.config.color, '#FFFFFF');
    const dpr = (window.devicePixelRatio || 1);

    // ========== TRAIL (tu·ª≥ lo·∫°i) ==========
    if (this.trail && this.trail.length > 1 && tk !== 'FIREBALL') {
        // Rocket c√≥ ƒëu√¥i ri√™ng
        if (tk !== 'ROCKET') {
            const pts = this.trail;
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);

            let lw = Math.max(1.2, this.radius * 1.0);
            let alpha = 0.28;

            if (tk === 'PIERCING') { lw = Math.max(1.0, this.radius * 0.7); alpha = 0.65; }
            else if (tk === 'LIGHTNING') { lw = Math.max(1.4, this.radius * 0.95); alpha = 0.45; ctx.setLineDash([6, 10]); }
            else if (tk === 'STUN') { lw = Math.max(1.2, this.radius * 0.85); alpha = 0.35; ctx.setLineDash([2, 7]); }
            else if (tk === 'FIRE') { lw = Math.max(1.8, this.radius * 1.15); alpha = 0.25; }
            else if (tk === 'HOMING') { lw = Math.max(1.4, this.radius * 1.0); alpha = 0.30; }

            ctx.strokeStyle = baseColor;
            ctx.lineWidth = lw;
            ctx.lineCap = 'round';
            ctx.globalAlpha = alpha;
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.setLineDash([]);

            // FIRE: ember at tail head (r·∫•t nh·∫π)
            if (tk === 'FIRE') {
                const p = pts[pts.length - 1];
                const flick = 0.55 + Math.sin(Date.now() / 90 + this.x * 0.01) * 0.25;
                ctx.fillStyle = __colorWithAlpha('#FFEB3B', 0.35 * flick);
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.max(2, this.radius * 0.65), 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // ========== BODY ==========
    // ROCKET
    if (tk === 'ROCKET') {
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const flameLength = 18 + Math.random() * 8;
        const flameGrad = ctx.createLinearGradient(-flameLength, 0, -8, 0);
        flameGrad.addColorStop(0, 'transparent');
        flameGrad.addColorStop(0.25, 'rgba(255,235,59,0.75)');
        flameGrad.addColorStop(0.55, 'rgba(255,152,0,0.9)');
        flameGrad.addColorStop(1, 'rgba(255,87,34,1)');

        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.moveTo(-8, -4);
        ctx.lineTo(-flameLength, 0);
        ctx.lineTo(-8, 4);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#424242';
        ctx.fillRect(-10, -5, 20, 10);

        ctx.fillStyle = '#D50000';
        ctx.beginPath();
        ctx.moveTo(10, -5);
        ctx.lineTo(18, 0);
        ctx.lineTo(10, 5);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#616161';
        ctx.beginPath();
        ctx.moveTo(-10, -5);
        ctx.lineTo(-15, -10);
        ctx.lineTo(-6, -5);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-10, 5);
        ctx.lineTo(-15, 10);
        ctx.lineTo(-6, 5);
        ctx.closePath();
        ctx.fill();
    }
    // FIREBALL (gi·ªØ nguy√™n b·∫£n ƒë·∫πp)
    else if (tk === 'FIREBALL') {
        ctx.translate(this.x, this.y);
        const r = this.radius || 36;

        ctx.shadowBlur = 35;
        ctx.shadowColor = '#FF5722';

        for (let i = 3; i >= 0; i--) {
            const layerR = r * (1 + i * 0.15);
            const alpha = 0.28 - i * 0.05;
            ctx.fillStyle = `rgba(255, 87, 34, ${alpha})`;
            ctx.beginPath();
            for (let a = 0; a < Math.PI * 2; a += 0.25) {
                const wave = Math.sin(a * 5 + Date.now() / 110) * 5;
                const px = Math.cos(a) * (layerR + wave);
                const py = Math.sin(a) * (layerR + wave);
                if (a === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }

        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
        coreGrad.addColorStop(0, 'rgba(255,255,255,0.95)');
        coreGrad.addColorStop(0.2, 'rgba(255,235,59,0.9)');
        coreGrad.addColorStop(0.5, 'rgba(255,152,0,0.8)');
        coreGrad.addColorStop(0.8, 'rgba(255,87,34,0.6)');
        coreGrad.addColorStop(1, 'rgba(255,87,34,0)');

        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();
    }
    // Other bullet types: sprite-based
    else {
        const ang = (typeof this.angle === 'number' && !isNaN(this.angle)) ? this.angle :
                    Math.atan2((this.velocity && this.velocity.y) || 0, (this.velocity && this.velocity.x) || 1);

        const sprite = __getBulletSprite(tk, baseColor, this.radius, dpr);

        ctx.translate(this.x, this.y);

        // slight spin for magic bullets
        if (tk === 'HOMING') ctx.rotate(ang + (Date.now() / 220));
        else if (tk === 'STUN') ctx.rotate(ang + (Date.now() / 420));
        else ctx.rotate(ang);

        if (sprite && sprite.canvas) {
            ctx.drawImage(sprite.canvas, -sprite.w / 2, -sprite.h / 2, sprite.w, sprite.h);
        } else {
            ctx.fillStyle = baseColor;
            ctx.beginPath();
            ctx.arc(0, 0, Math.max(2, this.radius), 0, Math.PI * 2);
            ctx.fill();
        }

        // tiny dynamic flicker (r·∫•t nh·∫π)
        if (tk === 'LIGHTNING') {
            const flick = 0.4 + Math.random() * 0.35;
            ctx.strokeStyle = __colorWithAlpha('#FFFFFF', 0.55 * flick);
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(-this.radius * 1.2, 0);
            ctx.lineTo(this.radius * 1.8, 0);
            ctx.stroke();
        } else if (tk === 'FIRE') {
            const flick = 0.35 + Math.random() * 0.35;
            ctx.fillStyle = __colorWithAlpha('#FFEB3B', 0.20 * flick);
            ctx.beginPath();
            ctx.arc(0, 0, Math.max(2, this.radius * 1.1), 0, Math.PI * 2);
            ctx.fill();
        }
    }

    ctx.restore();
};


// ===== GHI ƒê√à PH∆Ø∆†NG TH·ª®C DRAW C·ª¶A CLONE =====
const _originalCloneDraw = CloneTank.prototype.draw;
CloneTank.prototype.draw = function() {
    const cfg = GFX.CLONE;
    
    ctx.save();
    ctx.translate(this.x, this.y);
    
    const __baseR = (this.baseRadius || 22);
    const __scale = (__baseR > 0) ? (this.radius / __baseR) : 1;
    if (!isNaN(__scale) && __scale !== 1) ctx.scale(__scale, __scale);
    
    // V√≤ng nƒÉng l∆∞·ª£ng
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = cfg.body[1];
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.globalAlpha = 1;
    
    // Glow
    ctx.shadowBlur = 15;
    ctx.shadowColor = cfg.glow;
    
    // X√≠ch
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-26, -24, 8, 48);
    ctx.fillRect(18, -24, 8, 48);
    
    // Th√¢n v·ªõi gradient
    const bodyGrad = createTankGradient(0, 0, 22, cfg.body);
    ctx.fillStyle = bodyGrad;
    ctx.beginPath();
    ctx.roundRect(-22, -22, 44, 44, 6);
    ctx.fill();
    
    // Th√°p ph√°o
    ctx.rotate(this.angle);
    
    const turretGrad = ctx.createRadialGradient(-3, -3, 0, 0, 0, 18);
    turretGrad.addColorStop(0, cfg.turret[1]);
    turretGrad.addColorStop(1, cfg.turret[0]);
    ctx.fillStyle = turretGrad;
    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.fill();
    
    // N√≤ng s√∫ng
    const barrelGrad = ctx.createLinearGradient(0, -6, 0, 6);
    barrelGrad.addColorStop(0, '#555');
    barrelGrad.addColorStop(0.5, '#777');
    barrelGrad.addColorStop(1, '#555');
    ctx.fillStyle = barrelGrad;
    ctx.fillRect(0, -6, 40, 12);
    
    // ƒê·∫ßu n√≤ng
    ctx.fillStyle = '#81D4FA';
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#81D4FA';
    ctx.fillRect(35, -7, 8, 14);
    
    ctx.restore();
};

// ===== GHI ƒê√à PH∆Ø∆†NG TH·ª®C DRAW C·ª¶A OBSTACLE =====
const _originalObstacleDraw = Obstacle.prototype.draw;
Obstacle.prototype.draw = function() {
    ctx.save();
    
    // B√≥ng ƒë·ªï (m·ªÅm h∆°n, c√≥ chi·ªÅu s√¢u)
    // 3 l·ªõp shadow nh·∫π ƒë·ªÉ gi·∫£ blur (r·∫ª h∆°n shadowBlur)
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(this.x + 10, this.y + 10, this.width, this.height);
    ctx.fillStyle = 'rgba(0,0,0,0.10)';
    ctx.fillRect(this.x + 14, this.y + 14, this.width, this.height);
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(this.x + 18, this.y + 18, this.width, this.height);

    // contact shadow s√°t ƒë·∫•t
    const cs = ctx.createLinearGradient(this.x, this.y + this.height, this.x, this.y + this.height + 14);
    cs.addColorStop(0, 'rgba(0,0,0,0.26)');
    cs.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = cs;
    ctx.fillRect(this.x + 2, this.y + this.height, this.width - 4, 14);
    
    // Gradient cho th√¢n
    const grad = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
    grad.addColorStop(0, '#546E7A');
    grad.addColorStop(0.5, '#607D8B');
    grad.addColorStop(1, '#455A64');
    
    ctx.fillStyle = grad;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    
    // Highlight tr√™n
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(this.x, this.y, this.width, 5);
    
    // Highlight b√™n
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    ctx.fillRect(this.x, this.y, 5, this.height);
    
    // Vi·ªÅn
    ctx.strokeStyle = '#37474F';
    ctx.lineWidth = 3;
    ctx.strokeRect(this.x, this.y, this.width, this.height);
    
    // V·∫øt n·ª©t
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(this.x + 10, this.y + 10);
    ctx.lineTo(this.x + this.width - 10, this.y + this.height - 10);
    ctx.stroke();
    
    ctx.restore();
};



// ===== N√ÇNG C·∫§P N·ªÄN MAP (WORLD): texture (kh√¥ng √°nh s√°ng gi·∫£) =====
// M·ª•c ti√™u: ƒë·∫πp h∆°n nh∆∞ng m∆∞·ª£t ‚Äî d√πng pattern tile cache + gradient overlay, ch·ªâ v·∫Ω theo viewport.
const __MAP_PRETTY = { tile: null, pattern: null, tileSize: 256, seed: (Math.random() * 1e9) | 0 };

function __buildMapPrettyTile() {
    try {
        const s = __MAP_PRETTY.tileSize || 256;
        const c = document.createElement('canvas');
        c.width = s; c.height = s;
        const g = c.getContext('2d');
        g.clearRect(0, 0, s, s);

        // base tone
        g.fillStyle = 'rgba(18, 20, 26, 1)';
        g.fillRect(0, 0, s, s);

        // subtle noise speckles
        for (let i = 0; i < 1100; i++) {
            const x = (Math.random() * s) | 0;
            const y = (Math.random() * s) | 0;
            const a = 0.02 + Math.random() * 0.05;
            g.fillStyle = `rgba(255,255,255,${a})`;
            g.fillRect(x, y, 1, 1);
        }

        // darker pits
        for (let i = 0; i < 420; i++) {
            const x = (Math.random() * s) | 0;
            const y = (Math.random() * s) | 0;
            const a = 0.03 + Math.random() * 0.06;
            g.fillStyle = `rgba(0,0,0,${a})`;
            g.fillRect(x, y, 1, 1);
        }

        // micro scratches
        g.strokeStyle = 'rgba(255,255,255,0.05)';
        g.lineWidth = 1;
        for (let i = 0; i < 24; i++) {
            const x1 = Math.random() * s;
            const y1 = Math.random() * s;
            const len = 18 + Math.random() * 38;
            const ang = Math.random() * Math.PI * 2;
            g.beginPath();
            g.moveTo(x1, y1);
            g.lineTo(x1 + Math.cos(ang) * len, y1 + Math.sin(ang) * len);
            g.stroke();
        }

        // soft tile grid (replaces expensive per-frame grid loops)
        g.strokeStyle = 'rgba(255,255,255,0.04)';
        g.lineWidth = 1;
        for (let i = 0; i <= s; i += 64) {
            g.beginPath(); g.moveTo(i + 0.5, 0); g.lineTo(i + 0.5, s); g.stroke();
            g.beginPath(); g.moveTo(0, i + 0.5); g.lineTo(s, i + 0.5); g.stroke();
        }

        __MAP_PRETTY.tile = c;
        try { __MAP_PRETTY.pattern = ctx.createPattern(__MAP_PRETTY.tile, 'repeat'); } catch (e) { __MAP_PRETTY.pattern = null; }
    } catch (e) {
        __MAP_PRETTY.tile = null;
        __MAP_PRETTY.pattern = null;
    }
}

function drawPrettyMapBackground() {
    try {
        if (!__MAP_PRETTY.tile || !__MAP_PRETTY.pattern) __buildMapPrettyTile();

        // viewport in world coords
        const camX = (Camera && !isNaN(Camera.x)) ? Camera.x : 0;
        const camY = (Camera && !isNaN(Camera.y)) ? Camera.y : 0;
        const pad = 90;
        const x0 = Math.max(0, camX - pad);
        const y0 = Math.max(0, camY - pad);
        const x1 = Math.min(WORLD_WIDTH, camX + canvas.width + pad);
        const y1 = Math.min(WORLD_HEIGHT, camY + canvas.height + pad);
        const w = Math.max(0, x1 - x0);
        const h = Math.max(0, y1 - y0);
        if (w <= 0 || h <= 0) return;

        // Base
        ctx.fillStyle = '#0f1116';
        ctx.fillRect(x0, y0, w, h);

        // Texture pattern
        if (__MAP_PRETTY.pattern) {
            ctx.save();
            ctx.globalAlpha = 0.55;
            ctx.fillStyle = __MAP_PRETTY.pattern;
            ctx.fillRect(x0, y0, w, h);
            ctx.restore();
        }

        // (Lighting disabled per user request)

        // World border (gi·ªØ nguy√™n ranh gi·ªõi)
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.55)';
        ctx.lineWidth = 4;
        ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        ctx.restore();
    } catch (e) {
        // fallback silent
    }
}

// ===== N√ÇNG C·∫§P H√ÄM V·∫º N·ªÄN =====
const _originalDrawMiniMap = typeof drawMiniMap === 'function' ? drawMiniMap : null;
drawMiniMap = function() {
    const mapSize = 150;
    const mapX = canvas.width - mapSize - 20;
    const mapY = canvas.height - mapSize - 20;
    
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    // N·ªÅn v·ªõi bo g√≥c
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.beginPath();
    ctx.roundRect(mapX - 5, mapY - 5, mapSize + 10, mapSize + 10, 10);
    ctx.fill();
    
    // V√πng map
    ctx.fillStyle = 'rgba(30, 30, 40, 0.9)';
    ctx.fillRect(mapX, mapY, mapSize, mapSize);
    
    // L∆∞·ªõi
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
        ctx.beginPath();
        ctx.moveTo(mapX + (mapSize/5) * i, mapY);
        ctx.lineTo(mapX + (mapSize/5) * i, mapY + mapSize);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(mapX, mapY + (mapSize/5) * i);
        ctx.lineTo(mapX + mapSize, mapY + (mapSize/5) * i);
        ctx.stroke();
    }
    
    const scaleX = mapSize / WORLD_WIDTH;
    const scaleY = mapSize / WORLD_HEIGHT;
    
    // V·∫≠t c·∫£n
    ctx.fillStyle = 'rgba(84, 110, 122, 0.6)';
    Game.obstacles.forEach(obs => {
        ctx.fillRect(mapX + obs.x * scaleX, mapY + obs.y * scaleY, obs.width * scaleX, obs.height * scaleY);
    });
    
    // K·∫ª ƒë·ªãch
    Game.enemies.forEach(e => {
        if (e.typeKey === 'BOSS') {
            ctx.fillStyle = '#FF1744';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#FF1744';
            ctx.beginPath();
            ctx.arc(mapX + e.x * scaleX, mapY + e.y * scaleY, 5, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillStyle = '#f44336';
            ctx.fillRect(mapX + e.x * scaleX - 2, mapY + e.y * scaleY - 2, 4, 4);
        }
    });
    ctx.shadowBlur = 0;
    
    // V·∫≠t ph·∫©m
    ctx.fillStyle = '#FFD700';
    Game.pickups.forEach(p => {
        ctx.fillRect(mapX + p.x * scaleX - 1, mapY + p.y * scaleY - 1, 3, 3);
    });
    
    // Ng∆∞·ªùi ch∆°i
    if (Game.player) {
        ctx.fillStyle = '#4CAF50';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#4CAF50';
        ctx.beginPath();
        ctx.arc(mapX + Game.player.x * scaleX, mapY + Game.player.y * scaleY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // H∆∞·ªõng nh√¨n
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(mapX + Game.player.x * scaleX, mapY + Game.player.y * scaleY);
        ctx.lineTo(
            mapX + Game.player.x * scaleX + Math.cos(Game.player.angle) * 8,
            mapX + Game.player.y * scaleY + Math.sin(Game.player.angle) * 8
        );
        ctx.stroke();
    }
    ctx.shadowBlur = 0;
    
    // Vi·ªÅn
    ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(mapX - 5, mapY - 5, mapSize + 10, mapSize + 10, 10);
    ctx.stroke();
    
    ctx.restore();
};

// ===== N√ÇNG C·∫§P HI·ªÜU ·ª®NG N·ªî =====
const _originalCreateComplexExplosion = createComplexExplosion;
createComplexExplosion = function(x, y, color, count) {
    if (isNaN(x) || isNaN(y)) return;
    const mult = count ? count / 10 : 1;

    if (typeof MAX !== 'undefined') MAX.Audio.boom();

    // Shockwave ƒë·∫πp h∆°n
    Game.particles.push(new Particle(x, y, {
        type: 'shockwave',
        color: color,
        size: 10,
        maxRadius: 60 * mult,
        life: 0.6,
        decay: 0.08
    }));
    
    // Inner shockwave
    Game.particles.push(new Particle(x, y, {
        type: 'shockwave',
        color: '#fff',
        size: 5,
        maxRadius: 40 * mult,
        life: 0.4,
        decay: 0.1
    }));

    // Debris
    const debrisCount = Math.round(8 * mult);
    for (let i = 0; i < debrisCount; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 3 + Math.random() * 6;
        Game.particles.push(new Particle(x, y, {
            type: 'debris',
            color: color,
            size: 4 + Math.random() * 4,
            life: 1.0,
            decay: 0.03,
            velocity: { x: Math.cos(ang) * spd, y: Math.sin(ang) * spd }
        }));
    }

    // Smoke
    const smokeCount = Math.round(5 * mult);
    for (let i = 0; i < smokeCount; i++) {
        Game.particles.push(new Particle(x + (Math.random() - 0.5) * 20, y + (Math.random() - 0.5) * 20, {
            type: 'smoke',
            color: '#555',
            size: 10 + Math.random() * 10,
            life: 1.5,
            decay: 0.015,
            velocity: { x: (Math.random() - 0.5) * 2, y: -1 - Math.random() * 2 }
        }));
    }

    // Sparks
    const sparkCount = Math.round(15 * mult);
    for (let i = 0; i < sparkCount; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 5 + Math.random() * 10;
        Game.particles.push(new Particle(x, y, {
            type: 'spark',
            color: '#FFEB3B',
            size: 2,
            life: 0.3,
            decay: 0.06,
            velocity: { x: Math.cos(ang) * spd, y: Math.sin(ang) * spd }
        }));
    }
};

// ===== N√ÇNG C·∫§P V·∫º COIN =====
const _originalCoinDraw = Coin.prototype.draw;
Coin.prototype.draw = function() {
    const time = Date.now();
    const bounce = Math.sin(time / 150 + this.x) * 3;
    const rotation = Math.sin(time / 200 + this.y);
    const t = (time - this.spawnTime) / this.maxLifeTime;
    const alpha = t > 0.85 ? Math.max(0, 1 - (t - 0.85) / 0.15) : 1;
    
    ctx.save();
    ctx.translate(this.x, this.y + bounce);
    ctx.globalAlpha = alpha;
    
    // Glow
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#FFD700';
    
    // 3D coin effect
    const width = 8 * Math.abs(rotation) + 2;
    
    // Edge
    ctx.fillStyle = '#FFA000';
    ctx.beginPath();
    ctx.ellipse(0, 0, width, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Face gradient
    const faceGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, 10);
    faceGrad.addColorStop(0, '#FFEB3B');
    faceGrad.addColorStop(0.5, '#FFD700');
    faceGrad.addColorStop(1, '#FFA000');
    
    ctx.fillStyle = faceGrad;
    ctx.beginPath();
    ctx.ellipse(0, 0, width * 0.9, 9, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.ellipse(-2, -3, width * 0.3, 3, -0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // $ symbol
    if (Math.abs(rotation) > 0.3) {
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('$', 0, 0);
    }
    
    ctx.restore();
};


// ===== ENGINEER: TURRET + EMP VISUAL UPGRADE (g·ªì gh·ªÅ, m·∫°nh m·∫Ω, xung EMP "l·ª±c" h∆°n) =====
(function(){
    const __TAU = Math.PI * 2;

    // --- Turret draw: industrial / rugged (nh·∫π, kh√¥ng shadowBlur n·∫∑ng) ---
    try {
        if (typeof Turret !== 'undefined' && Turret.prototype) {
            const _origTurretDraw = Turret.prototype.draw;

            Turret.prototype.draw = function() {
                const now = Date.now();
                const total = Math.max(1, (this.endTime - this.spawnTime));
                const remain = Math.max(0, this.endTime - now);
                const pct = Math.max(0, Math.min(1, remain / total));
                const baseR = (this.radius || 18);
                const pulse = 0.55 + 0.45 * Math.sin(now / 120);

                ctx.save();
                ctx.translate(this.x, this.y);

                // ground shadow
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.ellipse(6, 8, baseR * 1.25, baseR * 0.85, 0, 0, __TAU);
                ctx.fill();
                ctx.globalAlpha = 1;

                // lifetime ring (track)
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'rgba(0, 229, 255, 0.14)';
                ctx.beginPath();
                ctx.arc(0, 0, baseR + 16, 0, __TAU);
                ctx.stroke();

                // progress ring
                ctx.strokeStyle = 'rgba(0, 229, 255, 0.95)';
                ctx.beginPath();
                ctx.arc(0, 0, baseR + 16, -Math.PI / 2, -Math.PI / 2 + __TAU * pct);
                ctx.stroke();

                // subtle ticks
                ctx.globalAlpha = 0.25;
                ctx.strokeStyle = 'rgba(179, 229, 252, 0.85)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const a = i * (__TAU / 6) + now / 1400;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseR + 16, a, a + 0.12);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // base plate (octagon)
                const plateR = baseR + 8;
                ctx.fillStyle = 'rgba(12, 18, 22, 0.92)';
                ctx.strokeStyle = 'rgba(140, 255, 255, 0.18)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const ang = i * (__TAU / 8) - Math.PI / 8;
                    const rr = plateR * (i % 2 ? 0.96 : 1);
                    const px = Math.cos(ang) * rr;
                    const py = Math.sin(ang) * rr;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // bolts
                for (let i = 0; i < 4; i++) {
                    const ang = i * (Math.PI / 2) + Math.PI / 4;
                    const bx = Math.cos(ang) * (plateR * 0.78);
                    const by = Math.sin(ang) * (plateR * 0.78);
                    ctx.fillStyle = 'rgba(0,0,0,0.45)';
                    ctx.beginPath();
                    ctx.arc(bx + 1, by + 1, 3.2, 0, __TAU);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(180, 220, 230, 0.9)';
                    ctx.beginPath();
                    ctx.arc(bx, by, 3, 0, __TAU);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(bx - 2, by);
                    ctx.lineTo(bx + 2, by);
                    ctx.stroke();
                }

                // core glow (no heavy blur)
                const coreR = baseR * 0.55;
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = 'rgba(0, 229, 255, 0.10)';
                ctx.beginPath();
                ctx.arc(0, 0, coreR * 2.1, 0, __TAU);
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.beginPath();
                ctx.arc(0, 0, coreR * 1.1, 0, __TAU);
                ctx.fill();

                ctx.fillStyle = 'rgba(0, 229, 255, ' + (0.28 + 0.22 * pulse) + ')';
                ctx.beginPath();
                ctx.arc(0, 0, coreR * (0.85 + 0.08 * pulse), 0, __TAU);
                ctx.fill();

                // turret head
                const headW = baseR * 1.55;
                const headH = baseR * 1.15;
                ctx.fillStyle = 'rgba(28, 46, 54, 0.95)';
                ctx.strokeStyle = 'rgba(255,255,255,0.10)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(-headW / 2, -headH / 2, headW, headH, 6);
                ctx.fill();
                ctx.stroke();

                // top highlight plate
                ctx.globalAlpha = 0.28;
                ctx.fillStyle = 'rgba(255,255,255,0.55)';
                ctx.beginPath();
                ctx.roundRect(-headW / 2 + 4, -headH / 2 + 3, headW * 0.52, headH * 0.22, 4);
                ctx.fill();
                ctx.globalAlpha = 1;

                // hazard stripe band (subtle)
                ctx.save();
                ctx.globalAlpha = 0.22;
                ctx.translate(0, headH * 0.26);
                ctx.rotate(-0.2);
                ctx.fillStyle = 'rgba(255, 214, 0, 0.85)';
                for (let i = -40; i <= 40; i += 10) {
                    ctx.fillRect(i, -3, 6, 6);
                }
                ctx.restore();

                // barrel (heavy + segmented)
                ctx.rotate(this.angle || 0);
                const last = (this.lastShot || 0);
                const recoil = (now - last < 80) ? (1 - (now - last) / 80) : 0;
                const recoilOff = recoil * 5;

                ctx.fillStyle = '#1f2a2e';
                ctx.fillRect(-recoilOff, -7, 54, 14);
                ctx.fillStyle = '#37474F';
                ctx.fillRect(10 - recoilOff, -6, 30, 12);

                // segments / grooves
                ctx.globalAlpha = 0.55;
                ctx.fillStyle = '#111';
                for (let i = 12; i <= 42; i += 10) {
                    ctx.fillRect(i - recoilOff, -7, 2, 14);
                }
                ctx.globalAlpha = 1;

                // inner energy rail
                ctx.fillStyle = 'rgba(0, 229, 255, ' + (0.16 + 0.20 * pulse) + ')';
                ctx.fillRect(4 - recoilOff, -2, 44, 4);

                // muzzle tip
                const tipX = 46 - recoilOff;
                const tipColor = (this.bulletColor || '#66BB6A');
                ctx.fillStyle = tipColor;
                ctx.fillRect(tipX, -8, 10, 16);

                // muzzle highlight
                ctx.globalAlpha = 0.35 + 0.25 * pulse;
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.fillRect(tipX + 2, -3, 6, 2);
                ctx.globalAlpha = 1;

                ctx.restore();
            };

            // keep original accessible if needed
            Turret.prototype.__drawOriginal = _origTurretDraw;
        }
    } catch(e) {}

    // --- EMP visual: add extra pulse + arcs (kh√¥ng ƒë·ªïi logic) ---
    function __spawnEmpFx(x, y, radius) {
        if (!Game || !Game.particles) return;

        const spawnTime = Date.now();

        class EMPBurstFX {
            constructor(x, y, r) {
                this.x = x;
                this.y = y;
                this.r = r;
                this.spawn = spawnTime;
                this.life = 540; // ms
                this.markedForDeletion = false;

                // precompute bolt directions + jitter (kh√¥ng random m·ªói frame)
                this.angs = [];
                this.jit = [];
                const n = 7;
                for (let i = 0; i < n; i++) {
                    const a = (i / n) * __TAU + (Math.random() * 0.45);
                    this.angs.push(a);
                    const arr = [];
                    for (let k = 0; k < 6; k++) arr.push((Math.random() - 0.5) * 0.35);
                    this.jit.push(arr);
                }
            }

            update() {
                const t = (Date.now() - this.spawn) / this.life;
                if (t >= 1) this.markedForDeletion = true;
            }

            draw() {
                const t = Math.max(0, Math.min(1, (Date.now() - this.spawn) / this.life));
                const alpha = 1 - t;
                const r = this.r * (0.22 + 0.78 * t);

                ctx.save();
                ctx.translate(this.x, this.y);

                // base rings
                ctx.globalAlpha = 0.85 * alpha;
                ctx.lineWidth = 10 * alpha;
                ctx.strokeStyle = 'rgba(0, 229, 255, 0.55)';
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, __TAU);
                ctx.stroke();

                ctx.lineWidth = 4 * alpha;
                ctx.strokeStyle = 'rgba(179, 229, 252, 0.75)';
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.68, 0, __TAU);
                ctx.stroke();

                // hex outline
                ctx.globalAlpha = 0.55 * alpha;
                ctx.setLineDash([10, 10]);
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgba(0, 229, 255, 0.75)';
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const a = i * (__TAU / 6) - Math.PI / 2;
                    const px = Math.cos(a) * r * 0.92;
                    const py = Math.sin(a) * r * 0.92;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);

                // spokes
                ctx.globalAlpha = 0.35 * alpha;
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const a = i * (__TAU / 6) + t * 0.9;
                    ctx.moveTo(Math.cos(a) * r * 0.20, Math.sin(a) * r * 0.20);
                    ctx.lineTo(Math.cos(a) * r * 0.95, Math.sin(a) * r * 0.95);
                }
                ctx.stroke();

                // bolts (jagged)
                ctx.globalAlpha = 0.90 * alpha;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                for (let i = 0; i < this.angs.length; i++) {
                    const a = this.angs[i];
                    const j = this.jit[i];
                    const ux = Math.cos(a), uy = Math.sin(a);
                    const px = -uy, py = ux;

                    ctx.strokeStyle = 'rgba(0, 229, 255, 0.95)';
                    ctx.beginPath();
                    const seg = 5;
                    for (let s = 0; s <= seg; s++) {
                        const tt = s / seg;
                        const dist = r * (0.15 + 0.85 * tt);
                        const off = (j[s] || 0) * r * 0.08 * (1 - tt);
                        const xx = ux * dist + px * off;
                        const yy = uy * dist + py * off;
                        if (s === 0) ctx.moveTo(xx, yy);
                        else ctx.lineTo(xx, yy);
                    }
                    ctx.stroke();

                    // inner white core
                    ctx.globalAlpha = 0.55 * alpha;
                    ctx.lineWidth = 1.6;
                    ctx.strokeStyle = 'rgba(255,255,255,0.92)';
                    ctx.stroke();

                    // restore bolt style
                    ctx.globalAlpha = 0.90 * alpha;
                    ctx.lineWidth = 3;
                }

                // center burst
                ctx.globalAlpha = 0.65 * alpha;
                ctx.fillStyle = 'rgba(0, 229, 255, 0.35)';
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.18, 0, __TAU);
                ctx.fill();

                ctx.globalAlpha = 0.95 * alpha;
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.07, 0, __TAU);
                ctx.fill();

                ctx.restore();
            }
        }

        // main burst
        Game.particles.push(new EMPBurstFX(x, y, radius));

        // extra after-rings (cheap, no blur)
        try {
            Game.particles.push(new Particle(x, y, { type: 'shockwave', color: 'rgba(0,229,255,0.75)', size: 12, maxRadius: radius * 0.55, decay: 0.07 }));
            Game.particles.push(new Particle(x, y, { type: 'shockwave', color: 'rgba(179,229,252,0.65)', size: 12, maxRadius: radius * 0.35, decay: 0.10 }));
        } catch(e) {}
    }

    // Wrap useSkill: detect engineer EMP cast and add visuals (kh√¥ng ƒë·ªïi mechanics)
    try {
        if (typeof Player !== 'undefined' && Player.prototype && typeof Player.prototype.useSkill === 'function') {
            const _origUseSkill = Player.prototype.useSkill;
            Player.prototype.useSkill = function(skillName) {
                const pre = (this.skills && this.skills[skillName]) ? this.skills[skillName].lastUsed : null;
                const out = _origUseSkill.call(this, skillName);

                try {
                    if (this.systemId === 'engineer' && skillName === 'vampirism') {
                        const post = (this.skills && this.skills[skillName]) ? this.skills[skillName].lastUsed : null;
                        if (post && post !== pre && (Date.now() - post) < 60) {
                            const cfg = (typeof getSystemSkillDef === 'function') ? (getSystemSkillDef('engineer', 'vampirism') || {}) : {};
                            const radius = cfg.radius || 340;
                            __spawnEmpFx(this.x, this.y, radius);
                        }
                    }
                } catch(e) {}

                return out;
            };
        }
    } catch(e) {}
})();


// ============================================
// BOSS CINEMATIC FX PACK (Ultra) - m·∫°nh m·∫Ω nh∆∞ng t·ªëi ∆∞u
// ============================================
const BossFX = (() => {
    const TAU = Math.PI * 2;

    function _burst(x, y, color, count, shockR) {
        if (!Game || !Game.particles) return;
        const c = count || 16;
        for (let i = 0; i < c; i++) {
            const ang = Math.random() * TAU;
            const spd = 3 + Math.random() * 8;
            Game.particles.push(new Particle(x, y, {
                type: 'spark',
                color: color || '#FF1744',
                size: 2,
                life: 0.35,
                decay: 0.05,
                velocity: { x: Math.cos(ang) * spd, y: Math.sin(ang) * spd }
            }));
        }
        Game.particles.push(new Particle(x, y, {
            type: 'shockwave',
            color: color || '#FF1744',
            size: 10,
            maxRadius: shockR || 140,
            life: 0.6,
            decay: 0.07
        }));
    }

    function ensureIntro(boss) {
        if (!boss || boss.typeKey !== 'BOSS') return;
        if (boss._bossIntroStart) return;
        boss._bossIntroStart = Date.now();
        boss._chargeTrail = [];
        boss._lastTrailAt = 0;
        boss._lastChargeSparkAt = 0;

        try { Game.shake = Math.max(Game.shake || 0, 30); } catch(e) {}
        _burst(boss.x, boss.y, '#FF1744', 22, 190);
        try { createDamageText(boss.x, boss.y - (boss.radius + 38), 'MECHA BOSS', '#FFEB3B'); } catch(e) {}
    }

    function handleAfterUpdate(boss, snap) {
        if (!boss || boss.typeKey !== 'BOSS' || !boss.bossAI) return;
        const ai = boss.bossAI;
        const now = Date.now();
        const state = ai.state;

        // Enrage pop
        if (snap && snap.prevEnraged === false && ai.enraged === true) {
            _burst(boss.x, boss.y, '#FF1744', 26, 210);
            try { Game.shake = Math.max(Game.shake || 0, 22); } catch(e) {}
        }

        // State transition hits
        if (snap && snap.prevState !== state) {
            if (state === 'charge_windup') {
                _burst(boss.x, boss.y, '#FF1744', 10, 120);
            }
            if (state === 'charge') {
                boss._chargeTrail = [];
                boss._lastTrailAt = 0;
                boss._lastChargeSparkAt = 0;
                try { Game.shake = Math.max(Game.shake || 0, 18); } catch(e) {}
                _burst(boss.x, boss.y, '#FF1744', 10, 120);
            }
            if (state === 'radial_windup') {
                _burst(boss.x, boss.y, '#FFEB3B', 12, 150);
            }
            if (snap.prevState === 'radial_windup' && state === 'idle') {
                _burst(boss.x, boss.y, '#FF1744', 30, 240);
                try { Game.shake = Math.max(Game.shake || 0, 20); } catch(e) {}
            }
            if (state === 'summon_cast') {
                _burst(boss.x, boss.y, '#00E5FF', 16, 170);
                try { Game.shake = Math.max(Game.shake || 0, 10); } catch(e) {}
            }
        }

        // Charge trail (limited rate)
        if (state === 'charge') {
            const tNow = performance.now();
            if (!boss._lastTrailAt || (tNow - boss._lastTrailAt) > 32) {
                if (!boss._chargeTrail) boss._chargeTrail = [];
                boss._chargeTrail.push({ x: boss.x, y: boss.y });
                if (boss._chargeTrail.length > 10) boss._chargeTrail.shift();
                boss._lastTrailAt = tNow;
            }

            if (!boss._lastChargeSparkAt || (tNow - boss._lastChargeSparkAt) > 90) {
                const dir = (ai.chargeDir != null) ? ai.chargeDir : boss.angle;
                const sideAng = dir + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                const px = boss.x + Math.cos(sideAng) * (boss.radius * 0.85);
                const py = boss.y + Math.sin(sideAng) * (boss.radius * 0.85);
                try {
                    Game.particles.push(new Particle(px, py, {
                        type: 'spark',
                        color: '#FFEB3B',
                        size: 2,
                        life: 0.22,
                        decay: 0.08,
                        velocity: { x: (Math.random() - 0.5) * 6, y: (Math.random() - 0.5) * 6 }
                    }));
                } catch(e) {}
                boss._lastChargeSparkAt = tNow;
            }
        }

        // Leaving charge => impact
        if (snap && snap.prevState === 'charge' && state !== 'charge') {
            _burst(boss.x, boss.y, '#FF1744', 22, 240);
            try { Game.shake = Math.max(Game.shake || 0, 24); } catch(e) {}
        }

        // Mines placed detection (boss update call-local)
        if (snap && Game.bossMines && Game.bossMines.length > snap.minesLen) {
            const add = Game.bossMines.length - snap.minesLen;
            for (let i = 0; i < add; i++) {
                const m = Game.bossMines[Game.bossMines.length - 1 - i];
                if (!m) continue;
                m.fxStart = now;
                m._lastArcAt = 0;
                m._arcSeed = Math.random() * 1000;
                try {
                    Game.particles.push(new Particle(m.x, m.y, {
                        type: 'shockwave',
                        color: '#FF9800',
                        size: 6,
                        maxRadius: (m.radius || 80) * 0.9,
                        life: 0.35,
                        decay: 0.10
                    }));
                } catch(e) {}
            }
            try { Game.shake = Math.max(Game.shake || 0, 8); } catch(e) {}
        }

        // Summon adds detection (boss update call-local)
        if (snap && Game.enemies && Game.enemies.length > snap.enemiesLen) {
            const news = Game.enemies.slice(snap.enemiesLen);
            for (const e of news) {
                if (!e || e.typeKey === 'BOSS') continue;
                e._spawnPortal = now;
                try {
                    Game.particles.push(new Particle(e.x, e.y, {
                        type: 'shockwave',
                        color: '#00E5FF',
                        size: 6,
                        maxRadius: 55,
                        life: 0.35,
                        decay: 0.09
                    }));
                    for (let k = 0; k < 8; k++) {
                        const ang = Math.random() * TAU;
                        const spd = 2 + Math.random() * 5;
                        Game.particles.push(new Particle(e.x, e.y, {
                            type: 'spark',
                            color: '#00E5FF',
                            size: 2,
                            life: 0.22,
                            decay: 0.09,
                            velocity: { x: Math.cos(ang) * spd, y: Math.sin(ang) * spd }
                        }));
                    }
                } catch(e) {}
            }
        }
    }

    function drawIntroUnder(boss) {
        if (!boss || boss.typeKey !== 'BOSS') return;
        const now = Date.now();
        const st = boss._bossIntroStart || now;
        const t = (now - st) / 1800;
        if (t > 1.1) return;

        const p = Math.max(0, Math.min(1, t));
        const fade = 1 - p;
        const r = boss.radius * (1.4 + p * 2.2);

        ctx.save();
        ctx.translate(boss.x, boss.y);
        ctx.globalAlpha = 0.75 * fade;

        const g = ctx.createRadialGradient(0, 0, boss.radius * 0.2, 0, 0, r);
        g.addColorStop(0, 'rgba(255,235,59,0.18)');
        g.addColorStop(0.45, 'rgba(255,23,68,0.20)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, TAU);
        ctx.fill();

        // Rotating arcs
        ctx.globalAlpha = 0.90 * fade;
        ctx.strokeStyle = 'rgba(255,23,68,0.85)';
        ctx.lineWidth = 4;
        const rot = now / 180;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(0, 0, boss.radius * (1.15 + i * 0.35), rot + i * 1.8, rot + i * 1.8 + 1.25);
            ctx.stroke();
        }

        ctx.restore();
    }

    function drawOver(boss) {
        if (!boss || boss.typeKey !== 'BOSS' || !boss.bossAI) return;
        const ai = boss.bossAI;
        const now = Date.now();

        // Charge telegraph: thick line + animated chevrons
        if (ai.state === 'charge_windup' || ai.state === 'charge') {
            const dir = (ai.chargeDir != null) ? ai.chargeDir : boss.angle;
            const len = 320;

            ctx.save();
            ctx.strokeStyle = 'rgba(255,23,68,0.55)';
            ctx.lineWidth = 7;
            ctx.beginPath();
            ctx.moveTo(boss.x, boss.y);
            ctx.lineTo(boss.x + Math.cos(dir) * len, boss.y + Math.sin(dir) * len);
            ctx.stroke();

            // chevrons
            ctx.globalAlpha = 0.85;
            for (let i = 0; i < 9; i++) {
                const s = i / 9;
                const base = 70 + s * (len - 70);
                const flow = ((now / 80) + i) % 1;
                const shift = (flow * 34) - 17;
                const px = boss.x + Math.cos(dir) * (base + shift);
                const py = boss.y + Math.sin(dir) * (base + shift);

                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(dir);
                ctx.fillStyle = 'rgba(255,235,59,0.65)';
                ctx.beginPath();
                ctx.moveTo(-10, -10);
                ctx.lineTo(10, 0);
                ctx.lineTo(-10, 10);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            ctx.restore();
        }

        // Charge trail behind boss
        if (ai.state === 'charge' && boss._chargeTrail && boss._chargeTrail.length) {
            ctx.save();
            for (let i = boss._chargeTrail.length - 1; i >= 0; i--) {
                const p = boss._chargeTrail[i];
                const a = i / boss._chargeTrail.length;
                ctx.globalAlpha = 0.16 * a;
                ctx.fillStyle = 'rgba(255,23,68,0.9)';
                ctx.beginPath();
                ctx.arc(p.x, p.y, boss.radius * (0.45 + 0.55 * a), 0, TAU);
                ctx.fill();
            }
            ctx.restore();
        }

        // Radial windup: ring + spikes
        if (ai.state === 'radial_windup') {
            const t = Math.max(0, Math.min(1, (ai.stateEnd - now) / 550));
            const r = 110 + (1 - t) * 70;

            ctx.save();
            ctx.translate(boss.x, boss.y);

            ctx.strokeStyle = 'rgba(255,23,68,0.35)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 8]);
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, TAU);
            ctx.stroke();
            ctx.setLineDash([]);

            const spikes = 24;
            ctx.strokeStyle = 'rgba(255,235,59,0.55)';
            ctx.lineWidth = 2;
            for (let i = 0; i < spikes; i++) {
                const ang = (i / spikes) * TAU + (now / 500);
                const r1 = r * 0.72;
                const r2 = r * 0.98;
                ctx.beginPath();
                ctx.moveTo(Math.cos(ang) * r1, Math.sin(ang) * r1);
                ctx.lineTo(Math.cos(ang) * r2, Math.sin(ang) * r2);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Summon cast: portal ring
        if (ai.state === 'summon_cast') {
            const t = Math.max(0, Math.min(1, (ai.stateEnd - now) / 650));
            const r = 90 + (1 - t) * 90;

            ctx.save();
            ctx.translate(boss.x, boss.y);

            const g = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
            g.addColorStop(0, 'rgba(255,235,59,0.16)');
            g.addColorStop(0.55, 'rgba(0,229,255,0.14)');
            g.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.globalAlpha = 0.9;
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, TAU);
            ctx.fill();

            ctx.strokeStyle = 'rgba(0,229,255,0.65)';
            ctx.lineWidth = 3;
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.65, 0, TAU);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore();
        }

        // Enrage aura extra
        if (ai.enraged) {
            const pulse = 0.55 + Math.sin(now / 70) * 0.25;
            ctx.save();
            ctx.globalAlpha = 0.22 * pulse;
            ctx.strokeStyle = 'rgba(255,23,68,0.85)';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(boss.x, boss.y, boss.radius * 1.9, 0, TAU);
            ctx.stroke();
            ctx.restore();
        }

        // Spawn portals for summoned adds (tiny flourish)
        if (Game && Game.enemies && Game.enemies.length) {
            for (const e of Game.enemies) {
                if (!e || e.typeKey === 'BOSS' || !e._spawnPortal) continue;
                const tt = (now - e._spawnPortal) / 450;
                if (tt > 1) { e._spawnPortal = 0; continue; }
                const rr = 10 + tt * 32;
                ctx.save();
                ctx.globalAlpha = 0.35 * (1 - tt);
                ctx.strokeStyle = 'rgba(0,229,255,0.75)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(e.x, e.y, rr, 0, TAU);
                ctx.stroke();
                ctx.restore();
            }
        }
    }

    function drawMine(m, pct) {
        if (!m) return;
        const now = Date.now();
        const r = m.radius || 80;
        const pulse = 0.6 + Math.sin(now / 90 + (m.x || 0) * 0.01) * 0.4;

        ctx.save();
        ctx.translate(m.x, m.y);

        // Soft fill
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = 'rgba(255,152,0,0.08)';
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, TAU);
        ctx.fill();

        // Segmented warning ring
        ctx.strokeStyle = `rgba(255,152,0,${0.55 + 0.35 * pulse})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 8]);
        ctx.beginPath();
        ctx.arc(0, 0, r * (0.55 + 0.45 * pct), 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]);

        // Core glow
        const coreR = Math.max(6, r * 0.18);
        const g = ctx.createRadialGradient(-coreR * 0.3, -coreR * 0.3, 0, 0, 0, coreR * 2.4);
        g.addColorStop(0, `rgba(255,235,59,${0.85 * pulse})`);
        g.addColorStop(0.5, `rgba(255,152,0,${0.55 * pulse})`);
        g.addColorStop(1, 'rgba(255,87,34,0)');

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, 0, coreR * 2.2, 0, TAU);
        ctx.fill();

        // Hazard triangles
        ctx.rotate(now / 700);
        ctx.fillStyle = 'rgba(255,235,59,0.65)';
        for (let i = 0; i < 3; i++) {
            ctx.save();
            ctx.rotate((i / 3) * TAU);
            ctx.beginPath();
            ctx.moveTo(r * 0.62, 0);
            ctx.lineTo(r * 0.45, -6);
            ctx.lineTo(r * 0.45, 6);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Tiny arc flourish (cached-ish via seed)
        if (!m._lastArcAt || (now - m._lastArcAt) > 140) {
            m._arcSeed = (m._arcSeed || 0) + 0.7 + Math.random() * 1.7;
            m._lastArcAt = now;
        }
        const arcA = (m._arcSeed || 0) + now / 150;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.35, arcA, arcA + 0.7);
        ctx.stroke();

        ctx.restore();
    }

    function mineDetonateFX(x, y, r) {
        const rr = (r || 80);
        try { Game.shake = Math.max(Game.shake || 0, 12); } catch(e) {}
        try {
            Game.particles.push(new Particle(x, y, {
                type: 'shockwave',
                color: '#FF9800',
                size: 12,
                maxRadius: rr * 1.6,
                life: 0.55,
                decay: 0.07
            }));
            for (let i = 0; i < 18; i++) {
                const ang = Math.random() * TAU;
                const spd = 4 + Math.random() * 9;
                Game.particles.push(new Particle(x, y, {
                    type: 'spark',
                    color: '#FFEB3B',
                    size: 2,
                    life: 0.28,
                    decay: 0.07,
                    velocity: { x: Math.cos(ang) * spd, y: Math.sin(ang) * spd }
                }));
            }
        } catch(e) {}
    }

    return { ensureIntro, handleAfterUpdate, drawIntroUnder, drawOver, drawMine, mineDetonateFX };
})();

// Hook boss update (skill moments, mines placed, summons)
try {
    const __origEnemyUpdateBossFX = Enemy.prototype.update;
    Enemy.prototype.update = function(player, clones, obstacles) {
        const isBoss = (this && this.typeKey === 'BOSS');
        const snap = isBoss ? {
            prevState: this.bossAI ? this.bossAI.state : null,
            prevEnraged: this.bossAI ? !!this.bossAI.enraged : false,
            minesLen: (Game && Game.bossMines) ? Game.bossMines.length : 0,
            enemiesLen: (Game && Game.enemies) ? Game.enemies.length : 0
        } : null;

        __origEnemyUpdateBossFX.call(this, player, clones, obstacles);

        if (isBoss && this.bossAI) {
            BossFX.ensureIntro(this);
            BossFX.handleAfterUpdate(this, snap);
        }
    };
} catch(e) {}

// Hook boss draw (intro + telegraphs + trail)
try {
    const __origDrawBossBossFX = Enemy.prototype.drawBoss;
    Enemy.prototype.drawBoss = function() {
        if (this && this.typeKey === 'BOSS') BossFX.drawIntroUnder(this);
        __origDrawBossBossFX.call(this);
        if (this && this.typeKey === 'BOSS') BossFX.drawOver(this);
    };
} catch(e) {}

// ============================================
// END BOSS CINEMATIC FX PACK
// ============================================

console.log('‚úÖ Ultra Graphics loaded successfully!');

// ============================================
// UI POLISH PACK (Fonts + HP Bars + Shop Cards)
// ============================================
(() => {
  // --- Inject CSS overrides (safe: uses !important where it matters) ---
  try {
    const css = `
:root{
  --ui-font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  --ui-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
html, body{
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
body, button, input{ font-family: var(--ui-font); }
.hud-text{ letter-spacing: 0.3px; font-variant-numeric: tabular-nums; }

#hud-top-left, #hud-top-right{
  background: rgba(10,10,16,0.58) !important;
  border: 1px solid rgba(255,255,255,0.10) !important;
  border-radius: 16px !important;
  padding: 12px 14px !important;
  backdrop-filter: blur(8px);
  box-shadow: 0 12px 34px rgba(0,0,0,0.38);
}
#hud-top-left .highlight{ text-shadow: 0 2px 0 rgba(0,0,0,0.8), 0 0 12px rgba(255,215,0,0.18); }

/* Player HP bar (chip bar) */
#healthBarContainer, #healthBarContainer2{
  position: relative !important;
  height: 22px !important;
  border-radius: 14px !important;
  border: 1px solid rgba(255,255,255,0.18) !important;
  background: rgba(0,0,0,0.58) !important;
  box-shadow: 0 10px 30px rgba(0,0,0,0.45), inset 0 0 0 1px rgba(0,0,0,0.35);
  overflow: hidden;
}
#healthBarChip, #healthBarChip2, #healthBar, #shieldOverlay, #healthBar2, #shieldOverlay2{
  position:absolute;
  top:0; left:0;
  height:100%;
  border-radius: inherit;
}
#healthBarChip, #healthBarChip2{
  background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06));
  opacity: 0.55;
  filter: saturate(0.9);
  transition: width 0.55s cubic-bezier(.2,.9,.1,1);
}
#healthBar{
  transition: width 0.12s linear;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.14), 0 0 18px rgba(76,175,80,0.18);
}
#shieldOverlay, #shieldOverlay2{
  background: linear-gradient(90deg, rgba(0,229,255,0.10), rgba(0,229,255,0.55), rgba(0,229,255,0.10));
  mix-blend-mode: screen;
}
#healthBarContainer #hpText, #healthBarContainer2 #hpText2{ font-family: var(--ui-mono); letter-spacing: 0.4px; }

/* Boss HP bar (chip bar) */
#bossHealthContainer{
  position: absolute;
  height: 34px !important;
  border-radius: 16px !important;
  border: 1px solid rgba(255,23,68,0.55) !important;
  background: rgba(0,0,0,0.58) !important;
  box-shadow: 0 16px 50px rgba(0,0,0,0.55), 0 0 28px rgba(255,23,68,0.14);
  backdrop-filter: blur(6px);
  overflow: hidden;
}
#bossHealthContainer::before{
  content:"";
  position:absolute;
  inset:0;
  background: radial-gradient(circle at 20% 30%, rgba(255,255,255,0.10), transparent 60%);
  pointer-events:none;
}
#bossHealthBarChip, #bossHealthBar{
  position:absolute;
  top:0; left:0;
  height:100%;
  border-radius: inherit;
}
#bossHealthBarChip{
  background: linear-gradient(90deg, rgba(255,255,255,0.16), rgba(255,255,255,0.06));
  opacity: 0.55;
  transition: width 0.7s cubic-bezier(.2,.9,.1,1);
}
#bossHealthBar{ box-shadow: inset 0 0 0 1px rgba(255,255,255,0.10), 0 0 18px rgba(255,23,68,0.18); }
#bossName{ font-family: var(--ui-mono); letter-spacing: 1.2px; text-shadow: 0 2px 0 rgba(0,0,0,0.9), 0 0 14px rgba(255,23,68,0.22); }

/* Shop polish */
#shopModal{ backdrop-filter: blur(6px); }
#shopModal > div{
  background: linear-gradient(180deg, rgba(16,16,18,0.96), rgba(8,8,10,0.96)) !important;
  border: 1px solid rgba(255,215,0,0.55) !important;
  box-shadow: 0 20px 70px rgba(0,0,0,0.65), 0 0 0 1px rgba(255,215,0,0.12) inset !important;
}
.shopCard{
  --accent: rgba(255,255,255,0.45);
  position: relative;
  overflow: hidden;
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03)) !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  border-left: 3px solid var(--accent) !important;
  border-radius: 16px !important;
  padding: 14px !important;
  box-shadow: 0 12px 26px rgba(0,0,0,0.35);
  transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
}
.shopCard::before{
  content:"";
  position:absolute;
  inset:-40px;
  background: radial-gradient(circle at 18% 12%, rgba(255,255,255,0.13), transparent 55%);
  transform: rotate(-10deg);
  pointer-events:none;
}
.shopCard:hover{ transform: translateY(-2px); box-shadow: 0 18px 40px rgba(0,0,0,0.45); }
.shopCard.is-locked{ filter: grayscale(0.15) saturate(0.85); }
.shopCard .shopIcon{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width: 28px;
  height: 28px;
  border-radius: 10px;
  background: rgba(0,0,0,0.34);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
}
.shopCard .shopTitleRow{ display:flex; align-items:center; gap: 10px; }
.shopCard .shopTitleText{ font-weight: 900 !important; color: #fff !important; letter-spacing: 0.4px; }
.shopCard .btn{
  border-radius: 14px !important;
  border: 1px solid rgba(255,255,255,0.18) !important;
  background: linear-gradient(180deg, rgba(255,215,0,0.92), rgba(255,160,0,0.92)) !important;
  box-shadow: 0 14px 26px rgba(0,0,0,0.35);
  color: #1b1200 !important;
  font-weight: 900 !important;
  letter-spacing: 0.6px;
}
.shopCard .btn:hover{ filter: brightness(1.06); }
.shopCard .btn:disabled{
  background: linear-gradient(180deg, rgba(140,140,140,0.45), rgba(80,80,80,0.45)) !important;
  color: rgba(255,255,255,0.75) !important;
  border-color: rgba(255,255,255,0.12) !important;
  box-shadow: none !important;
}

/* General buttons */
.btn{ border-radius: 14px; transition: transform 0.08s ease, filter 0.12s ease; }
.btn:active{ transform: translateY(1px) scale(0.99); }
`;
    const st = document.createElement('style');
    st.id = 'ui-polish-pack';
    st.textContent = css;
    document.head.appendChild(st);
  } catch(e) {}

  // --- Helpers ---
  function clamp01(v){ v = +v; if (!isFinite(v)) return 0; return Math.max(0, Math.min(1, v)); }

  function ensureChip(containerId, barId, chipId){
    const cont = document.getElementById(containerId);
    const bar  = document.getElementById(barId);
    if (!cont || !bar) return null;
    let chip = document.getElementById(chipId);
    if (!chip){
      chip = document.createElement('div');
      chip.id = chipId;
      chip.style.width = bar.style.width || '100%';
      cont.insertBefore(chip, bar);
    }
    return chip;
  }

  function setChipWidth(chipEl, pct, isDamage){
    if (!chipEl) return;
    pct = Math.max(0, Math.min(100, pct));
    const prev = (chipEl.__pct == null) ? pct : chipEl.__pct;

    // Healing: snap chip to new value quickly
    if (!isDamage || pct >= prev){
      chipEl.style.transitionDuration = '0.18s';
      chipEl.style.width = pct + '%';
      chipEl.__pct = pct;
      return;
    }

    // Damage: keep chip at prev briefly, then animate down
    if (chipEl.__timer) clearTimeout(chipEl.__timer);
    chipEl.style.width = prev + '%';
    chipEl.__timer = setTimeout(() => {
      chipEl.style.transitionDuration = '0.7s';
      chipEl.style.width = pct + '%';
      chipEl.__pct = pct;
    }, 120);
  }

  // --- Install chip bars (DOM) ---
  const healthChip = ensureChip('healthBarContainer', 'healthBar', 'healthBarChip');
  const healthChip2 = ensureChip('healthBarContainer2', 'healthBar2', 'healthBarChip2');
  const bossChip   = ensureChip('bossHealthContainer', 'bossHealthBar', 'bossHealthBarChip');

  // --- Patch player health UI update (P1/P2 aware) ---
try {
  if (Game && Game.ui && typeof Game.ui.updateHealth === 'function') {
    const __origUpdateHealth = Game.ui.updateHealth.bind(Game.ui);
    Game.ui.updateHealth = function(curr, max){
      const pid = (typeof Game !== 'undefined' && Game.__uiPid === 2) ? 2 : 1;
      const lastHpKey  = (pid === 2) ? '__lastHp2'  : '__lastHp';
      const lastMaxKey = (pid === 2) ? '__lastMax2' : '__lastMax';
      const prevPct = clamp01((this[lastHpKey] || 0) / (this[lastMaxKey] || (max || 1))) * 100;
      __origUpdateHealth(curr, max);
      const pct = clamp01((curr || 0) / (max || 1)) * 100;
      const isDamage = (pct < prevPct);
      const chip = (pid === 2) ? healthChip2 : healthChip;
      if (chip) setChipWidth(chip, pct, isDamage);
      this[lastHpKey] = curr;
      this[lastMaxKey] = max;
    };
  }
} catch(e) {}


  // --- Patch boss health bar update (wrap Enemy.update safely) ---
  try {
    if (Enemy && Enemy.prototype && typeof Enemy.prototype.update === 'function') {
      const __origEnemyUpdate_UI = Enemy.prototype.update;
      Enemy.prototype.update = function(player, clones, obstacles){
        __origEnemyUpdate_UI.call(this, player, clones, obstacles);
        if (this && this.typeKey === 'BOSS') {
          const pct = clamp01((this.hp || 0) / (this.maxHp || 1)) * 100;
          const prev = (bossChip && bossChip.__pct != null) ? bossChip.__pct : pct;
          setChipWidth(bossChip, pct, pct < prev);
        }
      };
    }
  } catch(e) {}

  // --- Shop card polish (icons + accent colors + state classes) ---
  function decorateShopCards(){
    const cards = document.querySelectorAll('.shopCard');
    if (!cards || !cards.length) return;

    const MAP = {
      btnBuyMaxHp:   { icon: '‚ù§',  accent: '#66BB6A' },
      btnBuyDmg:     { icon: '‚ú¶',  accent: '#EF5350' },
      btnBuyFireRate:{ icon: '‚ö°',  accent: '#29B6F6' },
      btnBuySpeed:   { icon: '‚û§',  accent: '#7C4DFF' },
      btnBuyMagnet:  { icon: '‚õ≠',  accent: '#FFD54F' },
      btnBuyArmor:   { icon: '‚õ®',  accent: '#B0BEC5' },
    };

    for (const card of cards){
      const btn = card.querySelector('button');
      if (!btn || !btn.id) continue;
      const info = MAP[btn.id] || { icon: '‚¨°', accent: 'rgba(255,255,255,0.45)' };
      card.style.setProperty('--accent', info.accent);

      // Title row: inject icon once
      let titleDiv = card.querySelector('div');
      if (titleDiv && !titleDiv.dataset.__decorated){
        titleDiv.dataset.__decorated = '1';
        titleDiv.classList.add('shopTitleRow');
        const txt = titleDiv.textContent;
        titleDiv.textContent = '';

        const ic = document.createElement('span');
        ic.className = 'shopIcon';
        ic.textContent = info.icon;
        ic.style.boxShadow = `0 0 0 1px rgba(0,0,0,0.35) inset, 0 0 18px ${info.accent}22`;

        const t = document.createElement('span');
        t.className = 'shopTitleText';
        t.textContent = txt;

        titleDiv.appendChild(ic);
        titleDiv.appendChild(t);
      }

      // State classes
      const isLocked = !!btn.disabled;
      card.classList.toggle('is-locked', isLocked);

      // MAX marker from any "MAX" level labels
      const maxText = card.querySelector('span') ? (card.innerText || '') : '';
      const isMax = (maxText.indexOf('MAX') !== -1);
      card.classList.toggle('is-max', isMax);
    }
  }

  // Wrap Shop.refresh so the classes update live
  try {
    if (typeof Shop !== 'undefined' && Shop && typeof Shop.refresh === 'function') {
      const __origShopRefresh_UI = Shop.refresh;
      Shop.refresh = function(){
        __origShopRefresh_UI.call(this);
        decorateShopCards();
      };
    }
  } catch(e) {}

  // First pass (in case shop already visible)
  try { decorateShopCards(); } catch(e) {}
})();


// ============================================
// WEAPON ICONS + RARITY BORDERS PACK
// (UI only: weapon inventory slots)
// ============================================
(() => {
  // Map weaponId -> { icon, rarity }
  const WEAPON_UI_META = {
    NORMAL:    { icon: '‚óè', rarity: 'common' },
    STUN:      { icon: '‚ú∑', rarity: 'uncommon' },
    FIRE:      { icon: '‚úπ', rarity: 'uncommon' },
    LIGHTNING: { icon: '‚ö°', rarity: 'rare' },
    HOMING:    { icon: '‚åñ', rarity: 'rare' },
    PIERCING:  { icon: '‚û§', rarity: 'epic' },
    ROCKET:    { icon: '‚òÑ', rarity: 'legendary' }
  };

  // Inject CSS once
  try {
    if (!document.getElementById('weapon-rarity-css')) {
      const st = document.createElement('style');
      st.id = 'weapon-rarity-css';
      st.textContent = `
/* Weapon icons + rarity borders */
#weaponBar .weapon-slot{ border-width: 1.5px !important; }
#weaponBar .weapon-slot .icon{
  font-size: 20px !important;
  line-height: 1 !important;
  letter-spacing: 0 !important;
  transform: translateY(1px);
}
#weaponBar .weapon-slot .rarity-gem{
  position:absolute; top:7px; right:7px;
  width:9px; height:9px; border-radius:50%;
  background: var(--rarity-color, rgba(255,255,255,0.65));
  box-shadow: 0 0 0 1px rgba(0,0,0,0.45) inset, 0 0 12px var(--rarity-color, rgba(255,255,255,0.18));
  opacity: 0.95;
}
#weaponBar .weapon-slot.empty{
  border-color: rgba(255,255,255,0.10) !important;
}
#weaponBar .weapon-slot.empty .icon{ opacity: 0.35; font-size: 16px !important; }

#weaponBar .weapon-slot.rarity-common{
  --rarity-color: rgba(200,200,200,0.92);
  border-color: rgba(200,200,200,0.42) !important;
  box-shadow: 0 10px 26px rgba(0,0,0,0.45), 0 0 14px rgba(200,200,200,0.06);
}
#weaponBar .weapon-slot.rarity-uncommon{
  --rarity-color: rgba(102,187,106,0.98);
  border-color: rgba(102,187,106,0.55) !important;
  box-shadow: 0 10px 26px rgba(0,0,0,0.45), 0 0 18px rgba(102,187,106,0.12);
}
#weaponBar .weapon-slot.rarity-rare{
  --rarity-color: rgba(79,195,247,0.98);
  border-color: rgba(79,195,247,0.62) !important;
  box-shadow: 0 10px 26px rgba(0,0,0,0.45), 0 0 18px rgba(79,195,247,0.14);
}
#weaponBar .weapon-slot.rarity-epic{
  --rarity-color: rgba(171,71,188,0.99);
  border-color: rgba(171,71,188,0.66) !important;
  box-shadow: 0 10px 26px rgba(0,0,0,0.45), 0 0 18px rgba(171,71,188,0.14);
}
#weaponBar .weapon-slot.rarity-legendary{
  --rarity-color: rgba(255,213,79,1);
  border-color: rgba(255,213,79,0.78) !important;
  box-shadow: 0 12px 30px rgba(0,0,0,0.48), 0 0 24px rgba(255,213,79,0.20);
}
#weaponBar .weapon-slot.rarity-legendary::after{
  content:'';
  position:absolute; inset:0;
  border-radius: inherit;
  pointer-events:none;
  background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.10) 18%, transparent 36%);
  opacity: 0.65;
  mix-blend-mode: screen;
  transform: translateX(-30%);
  animation: weaponLegendShine 1.9s linear infinite;
}
@keyframes weaponLegendShine{
  0%{ transform: translateX(-55%); }
  100%{ transform: translateX(55%); }
}
      `;
      document.head.appendChild(st);
    }
  } catch(e) {}

  // Patch weapon UI builder (symbols + rarity)
  try {
    if (typeof Game !== 'undefined' && Game.ui && typeof Game.ui.updateWeaponInventory === 'function') {
      const __origUpdateWeaponInventory = Game.ui.updateWeaponInventory.bind(Game.ui);

      Game.ui.updateWeaponInventory = function(inventory, currentIndex) {
        try {
                    const pid = (typeof Game !== 'undefined' && Game.__uiPid === 2) ? 2 : 1;
                    const __bar = (pid === 2 && this.weaponBar2) ? this.weaponBar2 : this.weaponBar;
                    if (!__bar) return;
                    __bar.innerHTML = '';
          for (let i = 0; i < 6; i++) {
            const slot = document.createElement('div');
            slot.className = 'weapon-slot';

            const keyNum = document.createElement('div');
            keyNum.className = 'key-number';
            keyNum.innerText = (i + 1);
            slot.appendChild(keyNum);

            const icon = document.createElement('div');
            icon.className = 'icon';

            if (inventory && inventory[i]) {
              const id = inventory[i].id;
              const weapon = (typeof BULLET_TYPES !== 'undefined' && BULLET_TYPES && BULLET_TYPES[id]) ? BULLET_TYPES[id] : { id, name: id, color: '#fff' };
              const meta = WEAPON_UI_META[weapon.id] || { icon: (weapon.name || '?').slice(0, 1), rarity: 'common' };

              slot.classList.add(`rarity-${meta.rarity}`);
              slot.style.color = __safeColor(weapon.color, '#fff');
              slot.title = `${weapon.name || weapon.id}`;

              // Icon symbol
              icon.textContent = meta.icon;
              slot.appendChild(icon);

              // Level badge
              const lvl = document.createElement('div');
              lvl.className = 'level-indicator';
              lvl.innerText = `Lv.${inventory[i].level}`;
              slot.appendChild(lvl);

              // Rarity gem
              const gem = document.createElement('div');
              gem.className = 'rarity-gem';
              slot.appendChild(gem);

              // Active highlight keeps weapon color vibe
              if (i === currentIndex) {
                slot.classList.add('active');
                const wc = __safeColor(weapon.color, '#ffffff');
                try {
                  slot.style.background = `rgba(${hexToRgb(wc)}, 0.22)`;
                } catch(e) {}
              }
            } else {
              slot.classList.add('empty');
              icon.textContent = '‚Äî';
              slot.appendChild(icon);
            }

            __bar.appendChild(slot);
          }
        } catch(err) {
          // fallback to original if anything goes wrong
          try { __origUpdateWeaponInventory(inventory, currentIndex); } catch(e) {}
        }
      };
    }
  } catch(e) {}
})();

MAX.UI.init();

        Shop.init();

        
        
        // ===== PHASE 1: Mode selector wiring (Hard/Easy, 1P/2P) =====
        (function(){
            const STORAGE_KEY = 'tankStartMode_v1';
            const $ = (id)=>document.getElementById(id);

            function getRadioValue(name, fallback){
                const el = document.querySelector('input[name="'+name+'"]:checked');
                return el ? el.value : fallback;
            }
            function setRadioValue(name, value){
                const els = document.querySelectorAll('input[name="'+name+'"]');
                els && els.forEach(r=>{ r.checked = (r.value === value); });
            }

            function readCfg(){
                const difficulty = getRadioValue('modeDifficulty','hard');
                const players = parseInt(getRadioValue('modePlayers','1'),10) || 1;
                const p2System = ($('p2SystemSelect') && $('p2SystemSelect').value) ? $('p2SystemSelect').value : 'default';
                return { difficulty, players, p2System };
            }

            function refreshUI(){
                const cfg = readCfg();
                const p2Row = $('p2SystemRow');
                if (p2Row) p2Row.classList.toggle('hidden', cfg.players !== 2);

                const note = $('modeNote');
                if (note){
                    if (cfg.players === 1 && cfg.difficulty === 'hard'){
                        note.textContent = 'Hard 1P: chu·ªôt ng·∫Øm + click b·∫Øn (Phase 1 ch·ªâ l∆∞u mode, ch∆∞a ƒë·ªïi gameplay).';
                    } else if (cfg.players === 1 && cfg.difficulty === 'easy'){
                        note.textContent = 'Easy 1P: auto-aim + auto-shoot (s·∫Ω k√≠ch ho·∫°t t·ª´ Phase 3).';
                    } else {
                        note.textContent = '2P local: auto-aim + auto-shoot (s·∫Ω k√≠ch ho·∫°t t·ª´ Phase 4‚Äì5).';
                    }
                }
            }

            function save(){
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(readCfg())); } catch(e){}
            }
            function load(){
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (raw){
                        const cfg = JSON.parse(raw);
                        if (cfg && typeof cfg === 'object'){
                            if (cfg.difficulty) setRadioValue('modeDifficulty', String(cfg.difficulty));
                            if (cfg.players) setRadioValue('modePlayers', String(cfg.players));
                            const p2Sel = $('p2SystemSelect');
                            if (p2Sel && cfg.p2System) p2Sel.value = String(cfg.p2System);
                        }
                    }
                } catch(e){}
                refreshUI();
            }

            // Hook listeners
            const radios = document.querySelectorAll('input[name="modeDifficulty"], input[name="modePlayers"]');
            radios && radios.forEach(r=>{
                r.addEventListener('change', ()=>{ refreshUI(); save(); try{ window.__updateStartSaveUI && window.__updateStartSaveUI(); }catch(e){} });
            });
            const p2Sel = $('p2SystemSelect');
            p2Sel && p2Sel.addEventListener('change', ()=>{ save(); try{ window.__updateStartSaveUI && window.__updateStartSaveUI(); }catch(e){} });

            load();

            // Expose for startGame to read
            window.__readStartModeCfg = readCfg;
        })();

const startGame = () => {

            try {
                const selected = document.querySelector('input[name="tankSystem"]:checked');
                const sysId = selected ? selected.value : 'default';
                Game.selectedSystemId = sysId || 'default';
                try { localStorage.setItem('tankSystem', Game.selectedSystemId); } catch(e){}
            
            // Phase 1: store selected mode (Hard/Easy, 1P/2P) for later phases
            try {
                const cfg = (window.__readStartModeCfg ? window.__readStartModeCfg() : {difficulty:'hard', players:1, p2System:'default'});
                const players = Math.max(1, Math.min(2, parseInt(cfg.players,10) || 1));
                Game.startMode = {
                    difficulty: (cfg.difficulty === 'easy') ? 'easy' : 'hard',
                    players: players,
                    p1System: Game.selectedSystemId || 'default',
                    p2System: (players === 2 ? (cfg.p2System || 'default') : null)
                };
                try { localStorage.setItem('tankStartMode_v1', JSON.stringify(Game.startMode)); } catch(e){}
            } catch(e) {}

            } catch(e) {}

            try { if (typeof MAX !== 'undefined') { MAX.Audio.init(); } } catch(e){}
            try{ window.BGM && window.BGM.onUserGesture && window.BGM.onUserGesture('game'); }catch(e){}
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');
            try { if (document.activeElement && document.activeElement.blur) document.activeElement.blur(); } catch(e) {}
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            Game.init();
        
        };

        const openVietkeyConfirm = () => {
            const m = document.getElementById('vietkeyModal');
            if (!m) return startGame();
            m.classList.remove('hidden');

            const yes = document.getElementById('vkYes');
            const no = document.getElementById('vkNo');

            const close = () => m.classList.add('hidden');

            const onYes = () => { cleanup(); close(); startGame(); };
            const onNo  = () => { cleanup(); close(); /* stay on start screen */ };

            const onKey = (e) => {
                if (e.key === 'Enter') { e.preventDefault(); onYes(); }
                if (e.key === 'Escape') { e.preventDefault(); onNo(); }
            };

            const cleanup = () => {
                try {
                    yes && yes.removeEventListener('click', onYes);
                    no && no.removeEventListener('click', onNo);
                    window.removeEventListener('keydown', onKey, true);
                } catch(e) {}
            };

            yes && yes.addEventListener('click', onYes);
            no  && no.addEventListener('click', onNo);
            window.addEventListener('keydown', onKey, true);
        };

        document.getElementById('startBtn').addEventListener('click', () => {
            openVietkeyConfirm();
        });

        const hideEndScreens = () => {
            try { document.getElementById('gameOverScreen').classList.add('hidden'); } catch(e){}
            try { document.getElementById('victoryScreen').classList.add('hidden'); } catch(e){}
        };

        const returnToMenu = () => {
            hideEndScreens();
            try { const bh = document.getElementById('bossHealthContainer'); if (bh) bh.style.display = 'none'; } catch(e){}
            try { const shop = document.getElementById('shopModal'); if (shop) shop.classList.add('hidden'); } catch(e){}
            try { document.getElementById('gameUI').classList.add('hidden'); } catch(e){}
            try { document.getElementById('startScreen').classList.remove('hidden'); } catch(e){}
            try{ window.BGM && window.BGM.setContext && window.BGM.setContext('menu'); }catch(e){}
            try { Game.active = false; Game.paused = false; } catch(e){}
            try { WaveManager.active = false; } catch(e){}
        };

        const restartRun = () => {
            try { Game.paused = false; } catch(e){}

            hideEndScreens();
            try { document.getElementById('startScreen').classList.add('hidden'); } catch(e){}
            try { document.getElementById('gameUI').classList.remove('hidden'); } catch(e){}
            try { Game.init(); } catch(e){}
        };
        
        const continueEndless = () => {
            // Close victory screen and keep playing from next wave
            hideEndScreens();

            // Victory() stops the RAF loop by setting Game.active = false (loop() returns early and doesn't schedule next frame).
            // So when continuing to Endless we must both unpause AND kick the main loop again.
            try { Game.endlessMode = true; Game.active = true; Game.paused = false; } catch(e){}
            try { if (typeof MAX !== 'undefined' && MAX.State) { MAX.State.paused = false; } } catch(e){}

            try { WaveManager.wave = (WaveManager.wave || 1) + 1; WaveManager.startWave(); } catch(e){}

            // Restart loop if it was stopped
            try { Game._fpsCapLast = 0; } catch(e){}
            try { requestAnimationFrame(loop); } catch(e){}
        };
// End screens buttons
        document.getElementById('restartBtn').addEventListener('click', restartRun);
        document.getElementById('menuBtnGO').addEventListener('click', returnToMenu);
        document.getElementById('victoryRestartBtn').addEventListener('click', restartRun);
        document.getElementById('victoryMenuBtn').addEventListener('click', returnToMenu);

        
        document.getElementById('victoryEndlessBtn').addEventListener('click', continueEndless);
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

    
})();
</script>

    <!-- Hidden Admin Code Modal -->
    <div id="adminCodeModal" class="hidden">
        <div id="adminCodePanel">
            <h3>ADMIN</h3>
            <input id="adminCodeInput" type="password" autocomplete="off" spellcheck="false" placeholder="Nh·∫≠p code..." />
            <div id="adminCodeMsg"></div>
        </div>
    </div>


    <div id="copyrightBadge">B·∫£n quy·ªÅn: Cuongdz ¬© 2026</div>


    <!-- VietKey confirmation (pre-game) -->
    <div id="vietkeyModal" class="hidden">
        <div id="vietkeyPanel">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                <div style="font-weight:900; color:#18ff6a; letter-spacing:2px;">L∆ØU √ù</div>
                <div style="opacity:0.8; font-size:12px;">(Enter = R·ªìi, Esc = Ch∆∞a)</div>
            </div>
            <div style="margin-top:10px; color:#ddd; line-height:1.4;">
                VietKey/b·ªô g√µ ti·∫øng Vi·ªát c√≥ th·ªÉ l√†m <b>lag ph√≠m</b>. B·∫°n ƒë√£ t·∫Øt VietKey (chuy·ªÉn EN) ch∆∞a?
            </div>
            <div style="margin-top:14px; display:flex; gap:10px; justify-content:flex-end;">
                <button class="btn" id="vkNo" style="background:#333;">Ch∆∞a</button>
                <button class="btn" id="vkYes" style="background:#18ff6a; color:#041a0c;">R·ªìi</button>
            </div>
        </div>
    </div>

</body>
</html>