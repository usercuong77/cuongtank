<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Battle 2D - Final Fix V4</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: 'Consolas', 'Courier New', monospace;
            color: white;
            user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        /* --- UI LAYER --- */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD: Góc trái trên */
        #hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
        }
        .hud-text {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
        }
        .highlight { color: #4CAF50; }
        .wave-text { color: #FFD700; font-size: 1.5rem; }

        /* HUD: Góc phải trên - Buffs */
        #hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .buff-icon {
            display: inline-block;
            padding: 5px 10px;
            margin-top: 5px;
            border-radius: 4px;
            font-size: 0.9rem;
            background: rgba(0,0,0,0.6);
            border: 1px solid white;
        }

        /* WEAPON & SKILL BAR */
        #bottomBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }

        #weaponBar, #skillBar {
            display: flex;
            gap: 10px;
        }

        .slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 8px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #777;
            transition: all 0.2s;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .slot.active {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,255,255,0.4);
            background: rgba(60, 60, 60, 0.9);
        }

        .slot .key-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.7rem;
            color: #aaa;
        }

        .slot .icon {
            font-size: 0.9rem;
            text-align: center;
            line-height: 1.1;
            margin-bottom: 2px;
        }

        .slot .level-indicator {
            font-size: 0.7rem;
            color: #FFD700;
            margin-top: 2px;
        }

        /* ULTIMATE BAR */
        #ultiContainer {
            width: 400px;
            height: 10px;
            background: #333;
            border: 1px solid #FFD700;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 5px;
            position: relative;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        #ultiBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFAB00);
            transition: width 0.2s;
            box-shadow: 0 0 10px #FFD700;
        }
        #ultiText {
            position: absolute;
            top: -20px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 5px black;
        }

        /* Cooldown Overlay */
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            transition: height 0.1s linear;
            background: rgba(0, 0, 0, 0.78);
            background-image: linear-gradient(135deg,
                rgba(255,255,255,0.14) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255,255,255,0.14) 50%,
                rgba(255,255,255,0.14) 75%,
                transparent 75%,
                transparent);
            background-size: 14px 14px;
        }

        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.85rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 2px 0 #000, 0 0 8px rgba(0,0,0,0.8);
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(0,0,0,0.25);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.08s linear;
        }

/* HUD: Thanh máu */
        #healthBarContainer {
            position: relative;
            width: 400px;
            height: 20px;
            background: #222;
            border: 2px solid #555;
            border-radius: 4px;
            overflow: hidden;
        }
        #healthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.2s;
        }
        #shieldOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 191, 255, 0.5);
            display: none;
        }

        /* BOSS HP BAR */
        #bossHealthContainer {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 30px;
            background: #222;
            border: 3px solid #d32f2f;
            border-radius: 4px;
            overflow: hidden;
            display: none; 
            z-index: 10;
        }
        #bossHealthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #d32f2f, #b71c1c);
            transition: width 0.2s;
        }
        #bossName {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        /* SCREENS */
        #startScreen, #gameOverScreen, #victoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            padding: 50px;
            border-radius: 15px;
            border: 2px solid #4CAF50;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 400px;
            z-index: 100;
        }

        h1 { margin: 0 0 20px; font-size: 3rem; color: #4CAF50; text-transform: uppercase; letter-spacing: 3px; }
        h2 { margin: 0 0 15px; color: #ff4444; font-size: 2.5rem; }
        p { color: #ccc; margin-bottom: 10px; font-size: 1.1rem; }
        
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 30px;
            transition: all 0.2s;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
        }
        .btn:hover { background: #45a049; transform: scale(1.05); box-shadow: 0 0 20px #4CAF50; }
        .hidden { display: none !important; }

        .key-guide {
            display: grid;
            grid-template-columns: auto auto;
            gap: 10px;
            text-align: left;
            margin-top: 20px;
            font-size: 0.9rem;
            color: #888;
        }
        .key { color: white; font-weight: bold; background: #333; padding: 2px 6px; border-radius: 4px; }
        
        #world-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 0.8rem;
            color: #555;
        }

    
        /* --- MAX EDITION UX TWEAKS --- */
        #weaponBar .weapon-slot, .weapon-slot, #weaponBar .slot { width: 60px; height: 60px; }
        #settingsModal input[type="range"] { width: 100%; }
        #settingsModal input[type="checkbox"] { transform: scale(1.2); }
        #maxTopBar .btn:hover { transform: scale(1.03); box-shadow: 0 0 12px rgba(255,255,255,0.15); }


        /* --- Admin code modal (hidden) --- */
        #adminCodeModal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:99999}
        #adminCodeModal.hidden{display:none}
        #adminCodePanel{pointer-events:auto;width:min(520px,92vw);background:#0b0f0c;border:2px solid rgba(24,255,106,.9);border-radius:14px;box-shadow:0 0 30px rgba(24,255,106,.25);padding:18px}
        #adminCodePanel h3{margin:0 0 10px;color:#18ff6a;letter-spacing:2px}
        #adminCodeInput{pointer-events:auto;width:100%;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#090b0a;color:#fff;font-size:16px;outline:none}
        #adminCodeMsg{margin-top:10px;font-size:13px;min-height:18px;color:rgba(255,255,255,.8)}


        /* --- Copyright badge --- */
        #copyrightBadge{
            position:fixed;
            top:14px;
            right:14px;
            z-index:100000;
            padding:6px 8px;
            border-radius:10px;
            border:1px solid rgba(24,255,106,.22);
            background:rgba(0,0,0,.18);
            color:rgba(24,255,106,.70);
            font-size:11px;
            letter-spacing:0.6px;
            user-select:none;
            pointer-events:none;
            backdrop-filter: blur(6px);
        }


        /* VietKey confirm modal */
        #vietkeyModal{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.55); z-index:100001;}
        #vietkeyModal.hidden{display:none;}
        #vietkeyPanel{width:min(560px,92vw); background:#0b0f0c; border:2px solid rgba(24,255,106,.55); border-radius:14px;
                      box-shadow:0 0 30px rgba(24,255,106,.22); padding:16px 18px;}
        .vietkeyTip{margin-top:14px; font-size:12px; color:rgba(255,255,255,.78); text-align:center;}
        .vietkeyTip b{color:#18ff6a;}

</style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div id="gameUI" class="ui-layer hidden">
        <div id="hud-top-left">
            <div class="hud-text wave-text">WAVE <span id="waveVal">1</span></div>
            <div class="hud-text">Điểm: <span id="scoreVal" class="highlight">0</span></div>
            <div class="hud-text">Vàng: <span id="goldVal" class="highlight" style="color:#FFD700;">0</span></div>
            <div class="hud-text" style="font-size: 0.9rem; color: #aaa;">Kẻ địch: <span id="enemyCount">0</span></div>
        </div>

        <div id="hud-top-right">
            <div id="buffsContainer"></div>
        </div>

        <!-- BOSS HP BAR -->
        <div id="bossHealthContainer">
            <div id="bossHealthBar"></div>
            <div id="bossName">MECHA BOSS</div>
        </div>

        <!-- WEAPON & SKILL UI -->
        <div id="bottomBar">
            <div id="ultiContainer">
                <div id="ultiText">BÃO LỬA (Space)</div>
                <div id="ultiBar"></div>
            </div>

            <div id="healthBarContainer">
                <div id="shieldOverlay"></div>
                <div id="healthBar"></div>
                <div style="position: absolute; top: 0; left: 0; width: 100%; text-align: center; line-height: 20px; font-size: 0.7rem; font-weight: bold; text-shadow: 1px 1px 0 #000;">
                    <span id="hpText">100/100</span>
                </div>
            </div>

            <div id="skillBar">
                <div class="slot" id="skill-clone" style="border-color: #29B6F6; color: #29B6F6;">
                    <div class="key-number">Q</div>
                    <div class="icon">Phân<br>Thân</div>
                    <div class="cooldown-overlay" id="cd-clone"></div>
                    <div class="cooldown-text" id="cdt-clone"></div>
                </div>
                <div class="slot" id="skill-stealth" style="border-color: #AB47BC; color: #AB47BC;">
                    <div class="key-number">E</div>
                    <div class="icon">Tàng<br>Hình</div>
                    <div class="cooldown-overlay" id="cd-stealth"></div>
                    <div class="cooldown-text" id="cdt-stealth"></div>
                </div>
                <div class="slot" id="skill-vampirism" style="border-color: #FF5252; color: #FF5252;">
                    <div class="key-number">R</div>
                    <div class="icon">Hút<br>Máu</div>
                    <div class="cooldown-overlay" id="cd-vampirism"></div>
                    <div class="cooldown-text" id="cdt-vampirism"></div>
                </div>
            </div>
            
            <div id="weaponBar"></div>
        </div>
        
        <div id="world-info">Map Size: 3x | Bug Fixed | Cleaned</div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Tank Battle 2D</h1>
        <p style="color: #4CAF50; font-weight: bold;">HỆ THỐNG NÂNG CẤP</p>
        <p>Nhặt 2 súng giống nhau để NÂNG CẤP (Tối đa Lv.5).</p>
        <p style="color: #ff4444;">Đạn thường không bao giờ mất, chỉ bị hạ cấp.</p>
        <p style="color: #E91E63; font-size: 0.9rem;">CẢNH BÁO: Boss sẽ phá hủy mọi vật cản!</p>
        
        

        <div id="systemPicker" style="margin:14px auto 10px; width:min(520px, 92vw); text-align:left; background:rgba(0,0,0,0.35); border:1px solid #333; border-radius:12px; padding:12px 14px;">
            <div style="font-weight:800; color:#FFD700; letter-spacing:0.5px; margin-bottom:8px;">CHỌN HỆ XE TĂNG</div>

            <label style="display:flex; gap:10px; align-items:flex-start; margin:6px 0; cursor:pointer;">
                <input type="radio" name="tankSystem" value="default" checked />
                <div>
                    <div style="font-weight:700;">Hệ Chiến Binh</div>
                    <div style="font-size:0.85rem; color:#aaa;">Phân thân chiến đấu • Tàng hình • Hút máu</div>
                </div>
            </label>

            <label style="display:flex; gap:10px; align-items:flex-start; margin:6px 0; cursor:pointer;">
                <input type="radio" name="tankSystem" value="speed" />
                <div>
                    <div style="font-weight:700; color:#b3e5fc;">Hệ Tốc Độ</div>
                    <div style="font-size:0.85rem; color:#aaa;">Lướt • Miễn thương • Cuồng tốc</div>
                </div>
            </label>

            <label style="display:flex; gap:10px; align-items:flex-start; margin:6px 0; cursor:pointer;">
                <input type="radio" name="tankSystem" value="engineer" />
                <div>
                    <div style="font-weight:700; color:#c8e6c9;">Hệ Kỹ Sư</div>
                    <div style="font-size:0.85rem; color:#aaa;">Tháp pháo • Sửa chữa • Xung EMP</div>
                </div>
            </label>

            <div style="font-size:0.8rem; color:#666; margin-top:6px;">(2 hệ mới đã có kỹ năng thật. Q/E/R để dùng.)</div>
        </div>
<div class="key-guide">
            <div><span class="key">WASD</span></div><div>Di chuyển</div>
            <div><span class="key">Chuột</span></div><div>Ngắm & Bắn</div>
            <div><span class="key">Space</span></div><div>Tuyệt chiêu</div>
            <div><span class="key">1-6</span></div><div>Chọn súng</div>
            <div><span class="key">Q/E/R</span></div><div>Kỹ năng</div>
        </div>

        
        <div class="vietkeyTip">
            Khuyến nghị: <b>tắt VietKey/bộ gõ tiếng Việt</b> (chuyển sang EN) để di chuyển mượt mà.
        </div>

        <button class="btn" id="startBtn">TRIỂN KHAI</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden">
        <h2>THẤT BẠI</h2>
        <p>Bạn đã dừng bước tại Wave <span id="finalWave" style="color: yellow">0</span></p>
        <p>Tổng điểm: <span id="finalScore" style="color: white; font-weight: bold; font-size: 2rem;">0</span></p>
        <button class="btn" id="restartBtn" style="background: #d32f2f;">CHƠI LẠI</button>
        <button class="btn" id="menuBtnGO" style="background:#333; margin-top:12px;">VỀ MENU</button>
    </div>


    <!-- Victory Screen -->
    <div id="victoryScreen" class="hidden">
        <h2 style="color:#4CAF50;">CHIẾN THẮNG</h2>
        <p>Bạn đã hạ Boss tại Wave <span id="victoryWave" style="color: yellow">0</span></p>
        <p>Tổng điểm: <span id="victoryScore" style="color: white; font-weight: bold; font-size: 2rem;">0</span></p>
        <p style="margin-top:8px; color:#aaa; font-size:0.95rem;">
            Kỷ lục: Score <span id="victoryBestScore" style="color:#4CAF50; font-weight:800;">0</span> —
            Wave <span id="victoryBestWave" style="color:#4CAF50; font-weight:800;">0</span>
        </p>
        <button class="btn" id="victoryRestartBtn" style="background:#18ff6a; color:#041a0c;">CHƠI LẠI</button>
        <button class="btn" id="victoryEndlessBtn" style="background:#FFD54F; color:#1b1300; margin-top:12px;">CHƠI TIẾP (ENDLESS)</button>
        <button class="btn" id="victoryMenuBtn" style="background:#333; margin-top:12px;">VỀ MENU</button>
    </div>


    
    <!-- MAX UI: Settings + Stats -->
    <div id="maxTopBar" class="hidden" style="position:absolute; top:20px; left:50%; transform:translateX(-50%); display:flex; gap:10px; align-items:center; z-index:200; pointer-events:auto;">
        <button class="btn" id="btnPause" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#333; border:1px solid #555;">PAUSE (P)</button>
        <button class="btn" id="btnSettings" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#333; border:1px solid #555;">SETTINGS (Esc)</button>
    </div>

    <div id="settingsModal" class="hidden" style="position:absolute; inset:0; background:rgba(0,0,0,0.75); z-index:300; display:flex; align-items:center; justify-content:center; pointer-events:auto;">
        <div style="width:min(620px,92vw); background:rgba(10,10,10,0.95); border:2px solid #4CAF50; border-radius:14px; padding:22px; box-shadow:0 0 30px rgba(76,175,80,0.25);">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                <div style="font-size:1.4rem; font-weight:800; color:#4CAF50; letter-spacing:1px;">SETTINGS</div>
                <button class="btn" id="btnCloseSettings" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#d32f2f;">CLOSE</button>
            </div>

            <div style="margin-top:16px; display:grid; grid-template-columns: 1fr; gap:14px; color:#ddd;">
                <div style="display:grid; grid-template-columns: 160px 1fr 70px; gap:10px; align-items:center;">
                    <div>Âm lượng</div>
                    <input id="setVolume" type="range" min="0" max="1" step="0.01" />
                    <div id="setVolumeVal" style="text-align:right; color:#FFD700; font-weight:700;">100%</div>
                </div>

                <div style="display:grid; grid-template-columns: 160px 1fr 70px; gap:10px; align-items:center;">
                    <div>FPS cap</div>
                    <input id="setFpsCap" type="range" min="30" max="120" step="1" />
                    <div id="setFpsCapVal" style="text-align:right; color:#FFD700; font-weight:700;">60</div>
                </div>

                <div style="display:flex; gap:16px; flex-wrap:wrap;">
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setShake" type="checkbox" /> Screen shake</label>
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setMinimap" type="checkbox" /> Minimap</label>
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setFps" type="checkbox" /> FPS Counter</label>
                    <label style="display:flex; gap:8px; align-items:center;"><input id="setAutoSave" type="checkbox" /> Auto Save</label>
                </div>

                <div style="padding:10px 12px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.12); border-radius:10px;">
                    <div style="font-weight:800; margin-bottom:6px; color:#FFD700;">PROGRESS</div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                        <div>Best Score: <span id="bestScore" style="color:#4CAF50; font-weight:800;">0</span></div>
                        <div>Best Wave: <span id="bestWave" style="color:#4CAF50; font-weight:800;">0</span></div>
                    </div>
                    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                        <button class="btn" id="btnSaveNow" style="margin-top:0; padding:10px 14px; font-size:0.9rem;">SAVE</button>
                        <button class="btn" id="btnResetSave" style="margin-top:0; padding:10px 14px; font-size:0.9rem; background:#444; border:1px solid #666;">RESET SAVE</button>
                    </div>
                    </div>

                <div style="font-size:0.9rem; color:#888; line-height:1.4;">
                    Hotkeys: <span class="key">P</span> Pause/Resume, <span class="key">Esc</span> Settings, <span class="key">M</span> Minimap, <span class="key">F</span> FPS.
                </div>
            </div>
        </div>
    </div>

    <!-- SHOP (Wave Complete) -->
    <div id="shopModal" class="hidden" style="position:absolute; inset:0; background:rgba(0,0,0,0.78); z-index:320; display:flex; align-items:center; justify-content:center; pointer-events:auto;">
        <div style="width:min(760px,94vw); background:rgba(10,10,10,0.96); border:2px solid #FFD700; border-radius:16px; padding:22px; box-shadow:0 0 30px rgba(255,215,0,0.18);">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                <div style="font-size:1.35rem; font-weight:900; color:#FFD700; letter-spacing:1px;">SHOP</div>
                <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
                    <div style="font-weight:900; color:#FFD700;">GOLD: <span id="shopGold">0</span></div>
                    <div style="color:#aaa; font-weight:700;">Next wave: <span id="shopNextWave" style="color:#4CAF50;">2</span></div>
                </div>
            </div>

            <div style="margin-top:14px; color:#cfcfcf; font-size:0.95rem; line-height:1.35;">
                Chọn nâng cấp bằng vàng (Bước 2E/2F: Magnet Range +10px và Armor -5% đã mua được).
            </div>

            <div id="shopCards" style="margin-top:16px; display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:12px;">
                <div class="shopCard" style="background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Max HP</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">+20 Max HP</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upMaxHpLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyMaxHp" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upMaxHpCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Damage %</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">+10% Damage</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upDmgLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyDmg" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upDmgCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Fire Rate</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">-5% Cooldown</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upFireRateLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyFireRate" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upFireRateCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Pickup Range</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">+10px Magnet</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upMagnetLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyMagnet" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upMagnetCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>
                <div class="shopCard" style="background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px;">
                    <div style="font-weight:900; color:#fff;">Armor</div>
                    <div style="margin-top:6px; color:#999; font-size:0.9rem;">-5% Damage Taken</div>
                    <div style="margin-top:8px; color:#bbb; font-size:0.85rem;">Level: <span id="upArmorLevel" style="color:#FFD700; font-weight:900;">0</span></div>
                    <button class="btn" id="btnBuyArmor" style="margin-top:10px; width:100%; padding:10px 12px; font-size:0.95rem;">BUY <span style="opacity:0.9;">(</span><span id="upArmorCost">50</span><span style="opacity:0.9;">G)</span></button>
                </div>

            </div>

            <div style="margin-top:16px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
                <div style="font-size:0.9rem; color:#888;">Nhấn <span class="key">Enter</span> để tiếp tục.</div>
                <button class="btn" id="btnShopContinue" style="margin-top:0; padding:12px 16px;">CONTINUE</button>
            </div>
        </div>
    </div>


    <div id="fpsCounter" class="hidden" style="position:absolute; top:20px; right:20px; z-index:250; font-weight:800; color:#FFD700; text-shadow:2px 2px 0 #000;">
        FPS: <span id="fpsVal">0</span>
    </div>



    <script>
const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        

        // --- MAX EDITION: Settings / Save / Audio / Pause / FPS ---
        const MAX = (() => {
            const SAVE_KEY = "tank_battle_max_save_v1";

            const defaultSave = {
                bestScore: 0,
                bestWave: 0,
                settings: {
                    volume: 0.8,
                    fpsCap: 60,
                    shake: true,
                    minimap: true,
                    fps: false,
                    autoSave: true
                }
            };

            const Storage = {
                load() {
                    try {
                        const raw = localStorage.getItem(SAVE_KEY);
                        if (!raw) return structuredClone(defaultSave);
                        const data = JSON.parse(raw);
                        return {
                            ...structuredClone(defaultSave),
                            ...data,
                            settings: { ...structuredClone(defaultSave.settings), ...(data.settings || {}) }
                        };
                    } catch (e) {
                        console.warn("Save load failed:", e);
                        return structuredClone(defaultSave);
                    }
                },
                save(saveObj) {
                    try { localStorage.setItem(SAVE_KEY, JSON.stringify(saveObj)); }
                    catch (e) { console.warn("Save write failed:", e); }
                },
                reset() { localStorage.removeItem(SAVE_KEY); }
            };

            // Tiny WebAudio synth (no external files)
            const Audio = {
                ctx: null,
                master: null,
                enabled: true,
                init() {
                this.paused = false;
                    if (this.ctx) return;
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                        this.master = this.ctx.createGain();
                        this.master.gain.value = 0.8;
                        this.master.connect(this.ctx.destination);
                    } catch (e) {
                        console.warn("Audio disabled:", e);
                        this.enabled = false;
                    }
                },
                setVolume(v) {
                    if (!this.master) return;
                    this.master.gain.value = Math.max(0, Math.min(1, v));
                },
                ping(freq, dur, type="sine", gain=0.08) {
                    if (!this.enabled) return;
                    this.init();
                    if (!this.ctx) return;
                    const t0 = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.type = type;
                    osc.frequency.value = freq;
                    g.gain.value = gain;
                    osc.connect(g);
                    g.connect(this.master);
                    g.gain.setValueAtTime(gain, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                    osc.start(t0);
                    osc.stop(t0 + dur);
                },
                shoot() { this.ping(520, 0.06, "square", 0.05); this.ping(260, 0.05, "sine", 0.03); },
                hit()   { this.ping(180, 0.08, "sawtooth", 0.05); },
                boom()  { this.ping(90, 0.18, "sawtooth", 0.08); this.ping(60, 0.22, "square", 0.05); },
                ulti()  { this.ping(140, 0.35, "sawtooth", 0.10); this.ping(70, 0.45, "square", 0.08); },
                ting() { this.ping(1040, 0.08, "sine", 0.06); this.ping(1560, 0.10, "triangle", 0.045); }
            };

            const State = {
                save: Storage.load(),
                paused: false,
                fps: { last: performance.now(), frames: 0, value: 0 },
                applySettings() {
                    const s = this.save.settings;
                    Audio.setVolume(s.volume);
                    const fpsEl = document.getElementById("fpsCounter");
                    if (fpsEl) fpsEl.classList.toggle("hidden", !s.fps);
                },
                updateBest(score, wave) {
                    let changed = false;
                    if (score > this.save.bestScore) { this.save.bestScore = score; changed = true; }
                    if (wave > this.save.bestWave) { this.save.bestWave = wave; changed = true; }
                    if (changed && this.save.settings.autoSave) Storage.save(this.save);
                    this.syncSettingsUI();
                },
                syncSettingsUI() {
                    const bs = document.getElementById("bestScore");
                    const bw = document.getElementById("bestWave");
                    if (bs) bs.textContent = this.save.bestScore;
                    if (bw) bw.textContent = this.save.bestWave;

                    const s = this.save.settings;
                    const vol = document.getElementById("setVolume");
                    const volVal = document.getElementById("setVolumeVal");
                    const cap = document.getElementById("setFpsCap");
                    const capVal = document.getElementById("setFpsCapVal");
                    const sh = document.getElementById("setShake");
                    const mm = document.getElementById("setMinimap");
                    const fp = document.getElementById("setFps");
                    const as = document.getElementById("setAutoSave");

                    if (vol) vol.value = s.volume;
                    if (volVal) volVal.textContent = Math.round(s.volume * 100) + "%";
                    if (cap) cap.value = s.fpsCap;
                    if (capVal) capVal.textContent = String(s.fpsCap);
                    if (sh) sh.checked = !!s.shake;
                    if (mm) mm.checked = !!s.minimap;
                    if (fp) fp.checked = !!s.fps;
                    if (as) as.checked = !!s.autoSave;
                }
            };

            const UI = {
                init() {
                    // Buttons
                    const topBar = document.getElementById("maxTopBar");
                    const btnSettings = document.getElementById("btnSettings");
                    const btnClose = document.getElementById("btnCloseSettings");
                    const btnPause = document.getElementById("btnPause");
                    const modal = document.getElementById("settingsModal");

                    const open = () => { if (modal) modal.classList.remove("hidden"); };
                    const close = () => { if (modal) modal.classList.add("hidden"); };

                    if (btnSettings) btnSettings.addEventListener("click", open);
                    if (btnClose) btnClose.addEventListener("click", close);
                    if (btnPause) btnPause.addEventListener("click", () => Toggle.pause());

                    // Settings controls
                    const vol = document.getElementById("setVolume");
                    const cap = document.getElementById("setFpsCap");
                    const sh  = document.getElementById("setShake");
                    const mm  = document.getElementById("setMinimap");
                    const fp  = document.getElementById("setFps");
                    const as  = document.getElementById("setAutoSave");

                    const saveNow = document.getElementById("btnSaveNow");
                    const resetSave = document.getElementById("btnResetSave");

                    if (vol) vol.addEventListener("input", () => {
                        State.save.settings.volume = parseFloat(vol.value);
                        State.applySettings();
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (cap) cap.addEventListener("input", () => {
                        const v = parseInt(cap.value, 10);
                        State.save.settings.fpsCap = Math.max(30, Math.min(120, isNaN(v) ? 60 : v));
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
if (sh) sh.addEventListener("change", () => {
                        State.save.settings.shake = !!sh.checked;
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (mm) mm.addEventListener("change", () => {
                        State.save.settings.minimap = !!mm.checked;
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (fp) fp.addEventListener("change", () => {
                        State.save.settings.fps = !!fp.checked;
                        State.applySettings();
                        State.syncSettingsUI();
                        if (State.save.settings.autoSave) Storage.save(State.save);
                    });
                    if (as) as.addEventListener("change", () => {
                        State.save.settings.autoSave = !!as.checked;
                        State.syncSettingsUI();
                        Storage.save(State.save);
                    });

                    if (saveNow) saveNow.addEventListener("click", () => Storage.save(State.save));
                    if (resetSave) resetSave.addEventListener("click", () => { Storage.reset(); State.save = Storage.load(); State.applySettings(); State.syncSettingsUI(); });

                    // Hotkeys (works alongside your Input system)
                    window.addEventListener("keydown", (e) => {
                        if (e.key === "Escape") {
                            e.preventDefault();
                            if (modal && !modal.classList.contains("hidden")) close(); else open();
                        }
                        const k = e.key.toLowerCase();
                        if (k === "p") Toggle.pause();
                        if (k === "m") { State.save.settings.minimap = !State.save.settings.minimap; State.syncSettingsUI(); if (State.save.settings.autoSave) Storage.save(State.save); }
                        if (k === "f") { State.save.settings.fps = !State.save.settings.fps; State.applySettings(); State.syncSettingsUI(); if (State.save.settings.autoSave) Storage.save(State.save); }
                    });

                    // Show best on start screen too
                    const start = document.getElementById("startScreen");
                    if (start) {
                        const div = document.createElement("div");
                        div.style.marginTop = "14px";
                        div.style.color = "#aaa";
                        div.style.fontSize = "0.95rem";
                        div.innerHTML = `Best Score: <span style="color:#4CAF50;font-weight:800">${State.save.bestScore}</span> | Best Wave: <span style="color:#4CAF50;font-weight:800">${State.save.bestWave}</span>`;
                        start.appendChild(div);
                    }

                    // keep top bar visible only in game
                    const uiLayer = document.getElementById("gameUI");
                    const updateTop = () => {
                        const inGame = uiLayer && !uiLayer.classList.contains("hidden");
                        if (topBar) topBar.classList.toggle("hidden", !inGame);
                    };
                    setInterval(updateTop, 250);

                    State.applySettings();
                    State.syncSettingsUI();
                }
            };

            const Toggle = {
                pause() {
                    State.paused = !State.paused;
                    if (State.paused) {
                        if (typeof Game !== "undefined") Game.paused = true;
                    } else {
                        if (typeof Game !== "undefined") { Game.paused = false; requestAnimationFrame(loop); }
                    }
                }
            };

            return { State, Storage, Audio, UI, Toggle };
        })();

// --- 1. CONFIGURATION ---
        
        let WORLD_WIDTH = window.innerWidth * 3;
        let WORLD_HEIGHT = window.innerHeight * 3;
        const MINIMAP_SIZE = 150;
        const MINIMAP_MARGIN = 20;

        const COLORS = {
            player: '#4CAF50',
            playerTurret: '#2E7D32',
            clone: '#29B6F6', 
            cloneTurret: '#0288D1',
            shield: 'rgba(0, 191, 255, 0.4)',
            text: '#fff',
            obstacle: '#546E7A',
            obstacleBorder: '#37474F'
        };

        const ENEMY_TYPES = {
            RED: { id: 'RED', name: 'Lính thường', color: '#e53935', hp: 45, maxHp: 45, speed: 2.5, damage: 10, score: 10, radius: 18, behavior: 'CHASE', fireRate: 3000, bulletSpeed: 5.5, bulletDmg: 8 , gold: 6 },
            BLACK: { id: 'BLACK', name: 'Hạng nặng', color: '#212121', hp: 200, maxHp: 200, speed: 1.0, damage: 30, score: 50, radius: 28, behavior: 'CHASE_SLOW', outline: '#757575', fireRate: 4000, bulletSpeed: 4, bulletDmg: 20 , gold: 25 },
            YELLOW: { id: 'YELLOW', name: 'Trinh sát', color: '#FFD700', hp: 25, maxHp: 25, speed: 4.5, damage: 5, score: 25, radius: 14, behavior: 'ORBIT', fireRate: 1200, bulletSpeed: 7.5, bulletDmg: 5 , gold: 12 },
            PURPLE: { id: 'PURPLE', name: 'Bắn tỉa', color: '#9C27B0', hp: 40, maxHp: 40, speed: 1.8, damage: 15, score: 40, radius: 20, behavior: 'SNIPER', fireRate: 3500, bulletSpeed: 11, bulletDmg: 25 , gold: 40 },
            BOSS: { id: 'BOSS', name: 'MECHA BOSS', color: '#D50000', hp: 2000, maxHp: 2000, speed: 1.5, damage: 50, score: 1000, radius: 60, behavior: 'BOSS', fireRate: 2000, bulletSpeed: 8, bulletDmg: 20 , gold: 300 }
        };

        const BULLET_TYPES = {
            NORMAL: { id: 'NORMAL', name: 'Thường', color: '#FFF', damage: 20, speed: 12, cooldown: 350, radius: 4 },
            STUN: { id: 'STUN', name: 'Choáng', color: '#00BCD4', damage: 15, speed: 14, cooldown: 450, radius: 5, effect: { type: 'STUN', duration: 1500 } },
            LIGHTNING: { id: 'LIGHTNING', name: 'Sấm Sét', color: '#FFEB3B', damage: 45, speed: 18, cooldown: 600, radius: 4, special: 'CHAIN', chainRange: 300, chainCount: 3, chainDmgFactor: 0.7 },
            FIRE: { id: 'FIRE', name: 'Đạn Lửa', color: '#FF5722', damage: 20, speed: 13, cooldown: 250, radius: 6, effect: { type: 'BURN', duration: 3000, tickInterval: 500, tickDamage: 8 } },
            PIERCING: { id: 'PIERCING', name: 'Xuyên', color: '#E91E63', damage: 60, speed: 22, cooldown: 700, radius: 6, special: 'PIERCE', pierceCount: 4 },
            HOMING: { id: 'HOMING', name: 'Đuổi', color: '#7C4DFF', damage: 25, speed: 11, cooldown: 450, radius: 5, special: 'HOMING', homingRange: 500, turnSpeed: 0.2 }
        };

        // --- Global cap: Fire Rate upgrade max level (based on NORMAL gun) ---
        function getFireRateMaxLv() {
            const baseCd = (BULLET_TYPES && BULLET_TYPES.NORMAL && BULLET_TYPES.NORMAL.cooldown) ? BULLET_TYPES.NORMAL.cooldown : 700;
            const target = 80;      // ms (same as clamp in Player.shoot)
            const mult = 0.95;      // -5% cooldown per level
            if (baseCd <= target) return 0;
            const lv = Math.ceil(Math.log(target / baseCd) / Math.log(mult));
            return Math.max(0, lv);
        }



        const ITEM_TYPES = {
            HP_PACK: { id: 'HP_PACK', color: '#4CAF50', label: '+HP', type: 'HEAL', value: 30, duration: 8000 },
            SHIELD: { id: 'SHIELD', color: '#2196F3', label: 'SHIELD', type: 'BUFF', buffType: 'shield', buffDuration: 8000, duration: 8000 },
            RAPID_FIRE: { id: 'RAPID_FIRE', color: '#FF9800', label: 'RAPID', type: 'BUFF', buffType: 'rapid', buffDuration: 8000, value: 0.5, duration: 8000 },
            AMMO_NORMAL: { id: 'AMMO_NORMAL', color: '#FFF', label: 'NORMAL', type: 'WEAPON', weaponId: 'NORMAL', duration: 15000 },
            AMMO_STUN: { id: 'AMMO_STUN', color: '#00BCD4', label: 'STUN', type: 'WEAPON', weaponId: 'STUN', duration: 15000 },
            AMMO_LIGHTNING: { id: 'AMMO_LIGHTNING', color: '#FFEB3B', label: 'LIGHT', type: 'WEAPON', weaponId: 'LIGHTNING', duration: 15000 },
            AMMO_FIRE: { id: 'AMMO_FIRE', color: '#FF5722', label: 'FIRE', type: 'WEAPON', weaponId: 'FIRE', duration: 15000 },
            AMMO_PIERCE: { id: 'AMMO_PIERCE', color: '#E91E63', label: 'PIERCE', type: 'WEAPON', weaponId: 'PIERCING', duration: 15000 },
            AMMO_HOMING: { id: 'AMMO_HOMING', color: '#7C4DFF', label: 'HOMING', type: 'WEAPON', weaponId: 'HOMING', duration: 15000 }
        };

        const SKILL_CONFIG = {
            // Hệ Chiến Binh (default)
            CLONE: { cooldown: 14000, duration: 8000, hp: 150 },
            STEALTH: { cooldown: 11000, duration: 3000 },
            VAMPIRISM: { cooldown: 18000, duration: 4000, leechPercent: 0.2, capPerSecond: 20 }
        };

        // --- S0: Tank System (3 systems) + Skill Framework ---
        // Note: Internal skill keys remain 'clone/stealth/vampirism' as 3 fixed slots (Q/E/R)
        // to keep the existing UI overlay ids (cd-clone/cd-stealth/cd-vampirism) stable.
        const TANK_SYSTEMS = {
            default: {
                id: 'default',
                name: 'Hệ Chiến Binh',
                skills: {
                    clone:     { key: 'Q', labelHTML: 'Phân<br>Thân',   color: '#29B6F6', cooldown: SKILL_CONFIG.CLONE.cooldown,     duration: SKILL_CONFIG.CLONE.duration },
                    stealth:   { key: 'E', labelHTML: 'Tàng<br>Hình',   color: '#AB47BC', cooldown: SKILL_CONFIG.STEALTH.cooldown,   duration: SKILL_CONFIG.STEALTH.duration },
                    vampirism: { key: 'R', labelHTML: 'Hút<br>Máu',     color: '#FF5252', cooldown: SKILL_CONFIG.VAMPIRISM.cooldown, duration: SKILL_CONFIG.VAMPIRISM.duration }
                }
            },
            speed: {
                id: 'speed',
                name: 'Hệ Tốc Độ',
                skills: {
                    // Q / E / R slots giữ nguyên (clone/stealth/vampirism) để UI không đổi
                    // Q: Dash
                    clone:     { key: 'Q', labelHTML: 'Lướt',          color: '#4FC3F7', cooldown: 3000,  duration: 250, dashSpeedMult: 3.2 },
                    // E: Phase (miễn thương ngắn)
                    stealth:   { key: 'E', labelHTML: 'Miễn<br>Thương',         color: '#81D4FA', cooldown: 10000, duration: 1000 },
                    // R: Adrenaline (buff)
                    vampirism: { key: 'R', labelHTML: 'Cuồng<br>Tốc',         color: '#29B6F6', cooldown: 14000, duration: 4000, speedMult: 1.25, fireMult: 0.85, damageMult: 1.3 }
                }
            },
            engineer: {
                id: 'engineer',
                name: 'Hệ Kỹ Sư',
                skills: {
                    // Q: Turret đặt tháp tự bắn
                    clone:     { key: 'Q', labelHTML: 'Tháp<br>Pháo',        color: '#81C784', cooldown: 12000, duration: 10000, maxTurrets: 1, range: 650, fireRate: 320, bulletColor: '#66BB6A', bulletDmgMult: 0.65 },
                    // E: Repair hồi máu tức thì
                    stealth:   { key: 'E', labelHTML: 'Sửa<br>Chữa',        color: '#A5D6A7', cooldown: 16000, heal: 30 },
                    // R: EMP choáng diện rộng (Boss miễn nhiễm theo Enemy.applyEffect)
                    vampirism: { key: 'R', labelHTML: 'Xung<br>EMP',           color: '#00E5FF', cooldown: 18000, radius: 340, stunDuration: 1200 }
                }
            }
        };

        function getTankSystem(id) {
            return TANK_SYSTEMS[id] || TANK_SYSTEMS.default;
        }

        function getSystemSkillDef(systemId, skillKey) {
            const sys = getTankSystem(systemId);
            return (sys && sys.skills && sys.skills[skillKey]) ? sys.skills[skillKey] : getTankSystem('default').skills[skillKey];
        }


        // --- 2. CAMERA SYSTEM ---
        const Camera = {
            x: 0, y: 0,
            update(player) {
                if (!player || isNaN(player.x) || isNaN(player.y)) return;
                this.x = player.x - canvas.width / 2;
                this.y = player.y - canvas.height / 2;
                this.x = Math.max(0, Math.min(this.x, WORLD_WIDTH - canvas.width));
                this.y = Math.max(0, Math.min(this.y, WORLD_HEIGHT - canvas.height));
                if (isNaN(this.x)) this.x = 0;
                if (isNaN(this.y)) this.y = 0;
            }
        };

        // --- 3. CLASSES ---
        class GameObject {
            constructor(x, y, radius) {
                this.x = x || 0; this.y = y || 0; this.radius = radius; this.markedForDeletion = false;
            }
            validatePosition() { if (isNaN(this.x)) this.x = 0; if (isNaN(this.y)) this.y = 0; }
        }

        // --- IMPROVED PARTICLE CLASS (New Types) ---
        class Particle extends GameObject {
            constructor(x, y, options) {
                super(x, y, options.size || Math.random() * 3 + 1);
                this.velocity = options.velocity || { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 };
                this.color = options.color || 'white';
                this.alpha = 1;
                this.life = options.life || 1.0;
                this.decay = options.decay || 0.02;
                this.type = options.type || 'circle'; // circle, spark, shockwave, smoke, debris
                this.maxRadius = options.maxRadius || 0; // For shockwave
            }
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                
                // Friction depends on type
                if (this.type === 'debris') {
                    this.velocity.x *= 0.95; this.velocity.y *= 0.95;
                } else if (this.type === 'smoke') {
                    this.velocity.x *= 0.98; this.velocity.y *= 0.98;
                    this.radius += 0.2; // Smoke expands
                } else {
                    this.velocity.x *= 0.9; this.velocity.y *= 0.9;
                }

                this.alpha -= this.decay;
                if (this.alpha <= 0) this.markedForDeletion = true;
                this.validatePosition();
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.alpha);
                
                if(this.type === 'shockwave') {
                    // Expanding ring
                    const progress = 1 - this.alpha;
                    const currentRad = this.radius + (this.maxRadius - this.radius) * progress;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentRad, 0, Math.PI*2);
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3 * this.alpha;
                    ctx.stroke();
                } else if (this.type === 'spark') {
                    // Thin line/spark
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, 2, 2);
                } else if (this.type === 'debris') {
                    // Irregular shape
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.alpha * 10);
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.radius/2, -this.radius/2, this.radius, this.radius);
                } else if (this.type === 'smoke') {
                    // Soft circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                } else {
                    // Standard circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x; this.y = y; this.width = width; this.height = height;
            }
            draw() {
                ctx.save();
                ctx.fillStyle = COLORS.obstacle;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#263238'; // Shadow
                ctx.fillRect(this.x + 5, this.y + this.height, this.width - 5, 10); 
                ctx.fillRect(this.x + this.width, this.y + 5, 10, this.height - 5); 
                ctx.strokeStyle = COLORS.obstacleBorder;
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.stroke();
                ctx.restore();
            }
        }

        class Pickup extends GameObject {
            constructor(x, y, config) {
                super(x, y, 15);
                this.config = config;
                this.spawnTime = Date.now();
                this.maxLifeTime = config.duration;
                this.floatOffset = 0;
            }
            update() {
                this.floatOffset = Math.sin(Date.now() / 200) * 3;
                if (Date.now() - this.spawnTime > this.maxLifeTime) this.markedForDeletion = true;
                this.validatePosition();
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y + this.floatOffset);
                ctx.shadowBlur = 15; ctx.shadowColor = this.config.color;
                ctx.fillStyle = this.config.color;
                ctx.fillRect(-12, -12, 24, 24);
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
                ctx.strokeRect(-12, -12, 24, 24);
                ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center';
                ctx.fillText(this.config.label, 0, 4);
                const lifePercent = 1 - (Date.now() - this.spawnTime) / this.maxLifeTime;
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(-12, 14, 24 * lifePercent, 3);
                ctx.restore();
            }
        }


        // --- COIN / GOLD DROP ---
        class Coin extends GameObject {
            constructor(x, y, value) {
                super(x, y, 10);
                this.value = value || 1;
                this.spawnTime = Date.now();
                this.maxLifeTime = 12000; // 12s rồi tự biến mất (tối ưu)
                const ang = Math.random() * Math.PI * 2;
                const sp = 2.2 + Math.random() * 1.8;
                this.vx = Math.cos(ang) * sp;
                this.vy = Math.sin(ang) * sp - 1.2;
                this.rot = Math.random() * Math.PI * 2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.92;
                this.vy *= 0.92;
                this.rot += 0.2;
                if (Date.now() - this.spawnTime > this.maxLifeTime) this.markedForDeletion = true;
                this.validatePosition();
            }
            draw() {
                const t = (Date.now() - this.spawnTime) / this.maxLifeTime;
                const alpha = t > 0.85 ? Math.max(0, 1 - (t - 0.85) / 0.15) : 1;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = alpha;
                ctx.shadowBlur = 16; ctx.shadowColor = '#FFD700';
                const squish = 0.25 + Math.abs(Math.sin(this.rot)) * 0.75;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8 * squish, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFF4C2'; ctx.lineWidth = 2;
                ctx.stroke();
                ctx.globalAlpha = alpha * 0.35;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(-2, -2, 2.2 * squish, 3.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // --- IMPROVED BULLET CLASS (Trail & Glow) ---
        class Bullet extends GameObject {
            constructor(x, y, angle, typeKey, config, owner = 'PLAYER') {
                super(x, y, config.radius);
                this.angle = angle;
                this.typeKey = typeKey;
                this.config = config; 
                this.owner = owner; 
                this.velocity = { x: Math.cos(angle) * config.speed, y: Math.sin(angle) * config.speed };
                if(isNaN(this.velocity.x)) this.velocity.x = 0;
                if(isNaN(this.velocity.y)) this.velocity.y = 0;
                this.hitList = [];
                this.pierceCount = config.special === 'PIERCE' ? config.pierceCount : 0;
                
                // Trail system
                this.trail = []; 
                this.maxTrailLength = 8;
            }

            update() {
                // Add position to trail
                this.trail.push({x: this.x, y: this.y});
                if(this.trail.length > this.maxTrailLength) this.trail.shift();

                // Homing Logic
                if (this.config.special === 'HOMING' && this.owner === 'PLAYER') {
                    let nearest = null; let minDst = this.config.homingRange;
                    Game.enemies.forEach(e => {
                        if(isNaN(e.x) || isNaN(e.y)) return;
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDst) { minDst = d; nearest = e; }
                    });
                    if (nearest) {
                        const desiredAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        if(!isNaN(desiredAngle)) {
                            const desiredVx = Math.cos(desiredAngle) * this.config.speed;
                            const desiredVy = Math.sin(desiredAngle) * this.config.speed;
                            const turnSpeed = this.config.turnSpeed;
                            this.velocity.x = this.velocity.x * (1 - turnSpeed) + desiredVx * turnSpeed;
                            this.velocity.y = this.velocity.y * (1 - turnSpeed) + desiredVy * turnSpeed;
                            const currentSpeed = Math.hypot(this.velocity.x, this.velocity.y);
                            if (currentSpeed > 0 && !isNaN(currentSpeed)) {
                                this.velocity.x = (this.velocity.x / currentSpeed) * this.config.speed;
                                this.velocity.y = (this.velocity.y / currentSpeed) * this.config.speed;
                            }
                        }
                    }
                }

                this.x += this.velocity.x;
                this.y += this.velocity.y;
                if (this.x < 0 || this.x > WORLD_WIDTH || this.y < 0 || this.y > WORLD_HEIGHT) {
                    this.markedForDeletion = true;
                }
                this.validatePosition();
            }

            draw() {
                ctx.save();
                
                // Draw Trail
                if(this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for(let i=1; i<this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.lineCap = 'round';
                    ctx.lineWidth = this.radius;
                    ctx.strokeStyle = this.config.color;
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                }

                // Draw Head with Glow
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.config.color;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff'; // Core is white/bright
                ctx.fill();
                
                // Outer ring
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 1, 0, Math.PI * 2);
                ctx.strokeStyle = this.config.color;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();
            }
        }

        // --- CLONE CLASS ---
        class CloneTank extends GameObject {
            constructor(x, y) {
                super(x, y, 22);
                this.hp = SKILL_CONFIG.CLONE.hp; this.maxHp = SKILL_CONFIG.CLONE.hp;
                this.spawnTime = Date.now(); this.duration = SKILL_CONFIG.CLONE.duration;
                this.speed = 4; this.angle = 0; this.lastShot = 0; this.moveAngle = Math.random() * Math.PI * 2;
            }
            update(enemies, obstacles, bullets) {
                if (this.duration !== Infinity && Date.now() - this.spawnTime > this.duration) {
                    this.markedForDeletion = true; createComplexExplosion(this.x, this.y, COLORS.clone); return;
                }
                let nearest = null; let minDst = 1000;
                enemies.forEach(e => { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minDst) { minDst = d; nearest = e; } });
                
                let dodgeX = 0, dodgeY = 0;
                bullets.forEach(b => {
                    if (b.owner === 'ENEMY') {
                        const d = Math.hypot(b.x - this.x, b.y - this.y);
                        if (d < 100) { 
                            const angleToBullet = Math.atan2(b.y - this.y, b.x - this.x);
                            dodgeX -= Math.cos(angleToBullet) * 2; dodgeY -= Math.sin(angleToBullet) * 2;
                        }
                    }
                });

                let desiredAngle = this.angle; let shouldMove = false;
                if (nearest) {
                    const dx = nearest.x - this.x; const dy = nearest.y - this.y; const dist = Math.hypot(dx, dy); desiredAngle = Math.atan2(dy, dx);
                    if (dist > 300) { shouldMove = true; } else if (dist < 150) { desiredAngle += Math.PI; shouldMove = true; } else { desiredAngle += Math.PI / 2; shouldMove = true; }
                    const now = Date.now(); const aimAngle = Math.atan2(dy, dx); this.angle = aimAngle;
                    if (now - this.lastShot > 600) { this.shoot(aimAngle); this.lastShot = now; }
                } else {
                    shouldMove = true; desiredAngle = this.moveAngle; if(Math.random() < 0.05) this.moveAngle += (Math.random()-0.5); this.angle = desiredAngle;
                }
                if (dodgeX !== 0 || dodgeY !== 0) { desiredAngle = Math.atan2(dodgeY, dodgeX); shouldMove = true; }

                let bestAngle = desiredAngle; let foundPath = false;
                const checkAngles = [0, 20, -20, 45, -45, 70, -70, 90, -90, 110, -110, 135, -135, 160, -160, 180];
                for (let offset of checkAngles) {
                    const checkRad = (offset * Math.PI) / 180; const testAngle = desiredAngle + checkRad; if(isNaN(testAngle)) continue;
                    const lookAhead = Math.max(this.radius * 1.5, this.speed * 5); const nextX = this.x + Math.cos(testAngle) * lookAhead; const nextY = this.y + Math.sin(testAngle) * lookAhead;
                    let collided = false;
                    if (nextX < this.radius || nextX > WORLD_WIDTH - this.radius || nextY < this.radius || nextY > WORLD_HEIGHT - this.radius) { collided = true; }
                    if (!collided) { for (let obs of obstacles) { if (checkCircleRect({x: nextX, y: nextY, radius: this.radius + 2}, obs)) { collided = true; break; } } }
                    if (!collided) { bestAngle = testAngle; foundPath = true; break; }
                }
                if (shouldMove && foundPath && !isNaN(bestAngle)) { this.x += Math.cos(bestAngle) * this.speed; this.y += Math.sin(bestAngle) * this.speed; }
                for (let obs of obstacles) {
                    if (checkCircleRect({x: this.x, y: this.y, radius: this.radius}, obs)) {
                        const anglePush = Math.atan2(this.y - (obs.y + obs.height/2), this.x - (obs.x + obs.width/2));
                        if(!isNaN(anglePush)) { this.x += Math.cos(anglePush) * 2; this.y += Math.sin(anglePush) * 2; }
                    }
                }
                this.x = Math.max(0, Math.min(WORLD_WIDTH, this.x)); this.y = Math.max(0, Math.min(WORLD_HEIGHT, this.y)); this.validatePosition();
            }
            shoot(angle) {
                if(isNaN(angle)) return;
                const bullet = new Bullet(this.x, this.y, angle, 'NORMAL', BULLET_TYPES.NORMAL, 'PLAYER');
                bullet.config = { ...BULLET_TYPES.NORMAL, color: '#81D4FA' }; 
                Game.projectiles.push(bullet);
                createMuzzleFlash(this.x, this.y, this.angle, '#81D4FA');
            }
            takeDamage(amount) {
                const alv = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv|0) : 0;
                const reduction = Math.min(0.60, alv * 0.05); // cap 60% để không quá OP
                const finalAmount = Math.max(1, Math.round(amount * (1 - reduction)));

                this.hp -= finalAmount;
                Game.ui.updateHealth(this.hp, this.maxHp);
                createDamageText(this.x, this.y - 20, `-${finalAmount}`, COLORS.clone);

                if (this.hp <= 0) { this.markedForDeletion = true; createComplexExplosion(this.x, this.y, COLORS.clone); }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.globalAlpha = 0.7; ctx.strokeStyle = COLORS.clone; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = '#222'; ctx.fillRect(-22, -22, 44, 44); ctx.fillStyle = COLORS.clone; ctx.fillRect(-22, -22, 44, 44);
                ctx.rotate(this.angle); ctx.fillStyle = COLORS.cloneTurret; ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.fill(); ctx.fillRect(0, -6, 40, 12); ctx.restore();
            }
        }


        class Turret extends GameObject {
            constructor(x, y, cfg = {}) {
                super(x, y, 18);
                const now = Date.now();
                this.spawnTime = now;
                this.endTime = now + (cfg.duration || 10000);
                this.range = cfg.range || 650;
                this.fireInterval = cfg.fireRate || 320;
                this.lastShot = 0;
                this.color = cfg.color || '#81C784';
                this.bulletColor = cfg.bulletColor || '#66BB6A';
                this.bulletDmgMult = (typeof cfg.bulletDmgMult === 'number') ? cfg.bulletDmgMult : 0.65;
                this.angle = 0;
            }

            update(obstacles) {
                const now = Date.now();
                if (now > this.endTime) {
                    this.markedForDeletion = true;
                    return;
                }

                // Aim nearest enemy in range (line-of-sight preferred)
                let target = null;
                let minDst = this.range;
                const obs = obstacles || Game.obstacles;

                for (const e of Game.enemies) {
                    if (!e || e.markedForDeletion || e.hp <= 0) continue;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDst) {
                        if (!isLineBlocked(this.x, this.y, e.x, e.y, obs)) {
                            minDst = d;
                            target = e;
                        }
                    }
                }

                if (target) {
                    const ang = Math.atan2(target.y - this.y, target.x - this.x);
                    if (!isNaN(ang)) this.angle = ang;

                    if (now - this.lastShot >= this.fireInterval) {
                        this.shoot(this.angle);
                        this.lastShot = now;
                    }
                }
            }

            shoot(angle) {
                if (isNaN(angle)) return;
                const base = (BULLET_TYPES && BULLET_TYPES.NORMAL) ? BULLET_TYPES.NORMAL : { damage: 10, speed: 12, radius: 5, color: '#fff' };
                const cfg = { ...base, color: this.bulletColor };
                cfg.damage = Math.max(1, Math.round((cfg.damage || 10) * this.bulletDmgMult));

                const bullet = new Bullet(this.x, this.y, angle, 'NORMAL', cfg, 'PLAYER');
                Game.projectiles.push(bullet);
                createMuzzleFlash(this.x, this.y, angle, this.bulletColor);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // lifetime ring
                const now = Date.now();
                const total = Math.max(1, (this.endTime - this.spawnTime));
                const remain = Math.max(0, this.endTime - now);
                const pct = Math.max(0, Math.min(1, remain / total));
                ctx.strokeStyle = 'rgba(102, 187, 106, 0.95)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 14, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * pct);
                ctx.stroke();

                // base
                ctx.fillStyle = 'rgba(0,0,0,0.65)';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 3, 0, Math.PI * 2);
                ctx.fill();

                // barrel
                ctx.rotate(this.angle);
                ctx.fillStyle = '#263238';
                ctx.fillRect(0, -6, 42, 12);
                ctx.fillStyle = this.bulletColor;
                ctx.fillRect(0, -4, 34, 8);

                ctx.restore();
            }
        }

        class Enemy extends GameObject {
            constructor(x, y, typeKey, hpMultiplier = 1, dmgMultiplier = 1, speedMultiplier = 1, fireRateMultiplier = 1) {
                const config = ENEMY_TYPES[typeKey]; let radius = config.radius; if(typeKey === 'BOSS') radius = 70;
                super(x, y, radius); this.id = Math.random().toString(36).substr(2, 9); this.typeKey = typeKey; this.config = config; this.dmgMult = dmgMultiplier; this.speedMult = speedMultiplier; this.fireRateMult = fireRateMultiplier; this.contactDamage = Math.min(25, Math.round(5 * this.dmgMult)); this.maxHp = config.maxHp * hpMultiplier; this.hp = this.maxHp; this.angle = 0; this.effects = { stun: { active: false, endTime: 0 }, burn: { active: false, endTime: 0, nextTick: 0, damage: 0 } }; this.lastShot = 0; this.bossState = 0; this.bossTimer = 0;
            }
            applyEffect(effectConfig) {
                if (this.typeKey === 'BOSS' && effectConfig.type === 'STUN') return; 
                const now = Date.now();
                if (effectConfig.type === 'STUN') { this.effects.stun.active = true; this.effects.stun.endTime = now + effectConfig.duration; } 
                else if (effectConfig.type === 'BURN') { this.effects.burn.active = true; this.effects.burn.endTime = now + effectConfig.duration; this.effects.burn.nextTick = now + effectConfig.tickInterval; this.effects.burn.damage = effectConfig.tickDamage; }
            }
            update(player, clones, obstacles) {
                const now = Date.now();
                if (this.effects.stun.active && now <= this.effects.stun.endTime) return;
                if (this.effects.burn.active) {
                    if (now > this.effects.burn.endTime) this.effects.burn.active = false;
                    else if (now >= this.effects.burn.nextTick) { this.hp -= this.effects.burn.damage; this.effects.burn.nextTick = now + 500; createDamageText(this.x, this.y - 10, this.effects.burn.damage, '#FF5722'); }
                }

                let targets = []; if (player && !player.isStealth) targets.push(player); targets = targets.concat(clones);
                let target = null; if (targets.length > 0) { let minDst = Infinity; targets.forEach(t => { const d = Math.hypot(t.x - this.x, t.y - this.y); if(d < minDst) { minDst = d; target = t; } }); }
                if (!target) { this.x += Math.cos(now/1000) * 1; this.y += Math.sin(now/1000) * 1; this.validatePosition(); return; }

                const dx = target.x - this.x; const dy = target.y - this.y; const dist = Math.hypot(dx, dy); let desiredAngle = Math.atan2(dy, dx); let moveSpeed = this.config.speed * this.speedMult;
                if (this.typeKey === 'BOSS') {
                    const hpBar = document.getElementById('bossHealthBar'); const hpContainer = document.getElementById('bossHealthContainer'); if (hpContainer.style.display !== 'block') hpContainer.style.display = 'block'; hpBar.style.width = `${(this.hp / this.maxHp) * 100}%`;
                    // --- BOSS SKILLS (Húc / Bắn vòng tròn / Mìn / Gọi lính) ---
                    if (!this.bossAI) {
                        this.bossAI = {
                            state: 'idle',
                            stateEnd: 0,
                            chargeDir: 0,
                            chargeVx: 0,
                            chargeVy: 0,
                            nextCharge: now + 2600,
                            nextRadial: now + 3400,
                            nextMines: now + 5200,
                            nextSummon: now + 7800
                        };
                        this._lastBossUpdate = now;
                    }
                    const ai = this.bossAI;

                    const dtBoss = Math.max(0.5, Math.min(2.0, (now - (this._lastBossUpdate || now)) / 16.666));
                    this._lastBossUpdate = now;

                    const hpPct = this.maxHp > 0 ? (this.hp / this.maxHp) : 1;

                    // Boss phase: dưới 25% máu sẽ CUỒNG NỘ. Mức cuồng nộ tăng theo màn (wave).
                    const waveNow = (typeof WaveManager !== 'undefined' && WaveManager.wave) ? (WaveManager.wave | 0) : 1;
                    const enrageLvl = Math.max(0, Math.min(1, (waveNow - 1) / 15)); // 0..1 (màn càng cao càng điên)
                    const shouldEnrage = (hpPct <= 0.25);
                    if (shouldEnrage && !ai.enraged) {
                        ai.enraged = true;
                        createComplexExplosion(this.x, this.y, "#FF1744");
                        createDamageText(this.x, this.y - 80, "CUỒNG NỘ!", "#FF1744");
                    }
                    if (!shouldEnrage) ai.enraged = false;

                    const enrageCdMult = ai.enraged ? Math.max(0.55, 0.85 - 0.25 * enrageLvl) : 1;   // giảm hồi chiêu
                    const enrageShootMult = ai.enraged ? (1.15 + 0.45 * enrageLvl) : 1;                // bắn nhanh hơn
                    const enrageMoveMult = ai.enraged ? (1.10 + 0.20 * enrageLvl) : 1;                 // chạy nhanh hơn


                    // Tuning di chuyển boss (để không dính người chơi quá gắt)
                    moveSpeed = (dist > 320 ? 1.35 : 0.55) * this.speedMult * enrageMoveMult;

                    // --- Resolve casting / state ---
                    if (ai.state === 'charge_windup') {
                        moveSpeed = 0;
                        this.angle = ai.chargeDir;
                        if (now >= ai.stateEnd) {
                            ai.state = 'charge';
                            ai.stateEnd = now + 900;
                            const spd = (10.5 + (hpPct < 0.5 ? 1.5 : 0) + (ai.enraged ? (1.8 + 2.2 * enrageLvl) : 0)) * this.speedMult;
                            ai.chargeVx = Math.cos(ai.chargeDir) * spd;
                            ai.chargeVy = Math.sin(ai.chargeDir) * spd;
                            this.contactDamage = Math.round(18 * this.dmgMult * (ai.enraged ? (1.15 + 0.35 * enrageLvl) : 1));
                        }
                    } else if (ai.state === 'charge') {
                        // Dash theo thời gian (ổn định 60/120fps)
                        this.x += ai.chargeVx * dtBoss;
                        this.y += ai.chargeVy * dtBoss;
                        moveSpeed = 0;
                        this.angle = ai.chargeDir;
                        this.contactDamage = Math.round(18 * this.dmgMult * (ai.enraged ? (1.15 + 0.35 * enrageLvl) : 1));
                        if (now >= ai.stateEnd) {
                            ai.state = 'idle';
                            this.contactDamage = Math.round(10 * this.dmgMult * (ai.enraged ? (1.10 + 0.30 * enrageLvl) : 1));
                        }
                    } else if (ai.state === 'radial_windup') {
                        moveSpeed *= 0.35;
                        if (now >= ai.stateEnd) {
                            const count = (hpPct < 0.5 ? 26 : 20) + (ai.enraged ? (4 + Math.round(4 * enrageLvl)) : 0);
                            for (let i = 0; i < count; i++) {
                                const ang = (i / count) * Math.PI * 2;
                                this.shoot(ang, 'FAST');
                            }
                            createDamageText(this.x, this.y - 70, "BẮN VÒNG TRÒN!", "#FF1744");
                            ai.state = 'idle';
                        }
                    } else if (ai.state === 'summon_cast') {
                        moveSpeed *= 0.25;
                        if (now >= ai.stateEnd) {
                            const cnt = (hpPct < 0.5 ? 5 : 4) + (ai.enraged ? (2 + Math.round(1 * enrageLvl)) : 0);
                            const types = ['RED','RED','RED','BLACK','YELLOW','PURPLE'];
                            const sc = (typeof WaveManager !== 'undefined' && WaveManager.scaling) ? WaveManager.scaling
                                      : ((typeof WaveManager !== 'undefined' && typeof WaveManager.computeScaling === 'function') ? WaveManager.computeScaling() : null);

                            for (let i = 0; i < cnt; i++) {
                                const ang = Math.random() * Math.PI * 2;
                                const r = 120 + Math.random() * 80;
                                let sx = this.x + Math.cos(ang) * r;
                                let sy = this.y + Math.sin(ang) * r;
                                sx = Math.max(80, Math.min(WORLD_WIDTH - 80, sx));
                                sy = Math.max(80, Math.min(WORLD_HEIGHT - 80, sy));
                                const tk = types[Math.floor(Math.random() * types.length)];

                                const hpM = sc ? sc.hpMult : 1;
                                const dmgM = sc ? sc.dmgMult : 1;
                                const spdM = sc ? sc.speedMult : 1;
                                const frM  = sc ? sc.fireRateMult : 1;

                                Game.enemies.push(new Enemy(sx, sy, tk, hpM, dmgM, spdM, frM));
                            }
                            createComplexExplosion(this.x, this.y, "#FF1744");
                            createDamageText(this.x, this.y - 70, "GỌI LÍNH!", "#FF1744");
                            ai.state = 'idle';
                        }
                    }

                    // --- Trigger new abilities (idle only) ---
                    if (ai.state === 'idle') {
                        this.contactDamage = Math.round(10 * this.dmgMult);

                        const options = [];
                        if (now >= ai.nextCharge && dist < 520) options.push('charge');
                        if (now >= ai.nextRadial) options.push('radial');
                        if (now >= ai.nextMines) options.push('mines');
                        if (now >= ai.nextSummon) options.push('summon');

                        if (options.length > 0) {
                            const pick = options[Math.floor(Math.random() * options.length)];

                            if (pick === 'charge') {
                                ai.state = 'charge_windup';
                                ai.chargeDir = desiredAngle;
                                ai.stateEnd = now + 600;
                                ai.nextCharge = now + (hpPct < 0.5 ? 6500 : 7800) * enrageCdMult;
                                createDamageText(this.x, this.y - 70, "CHUẨN BỊ HÚC!", "#FF1744");
                            } else if (pick === 'radial') {
                                ai.state = 'radial_windup';
                                ai.stateEnd = now + 550;
                                ai.nextRadial = now + (hpPct < 0.5 ? 6000 : 7200) * enrageCdMult;
                            } else if (pick === 'mines') {
                                const mineCount = (hpPct < 0.5 ? 10 : 8) + (ai.enraged ? (3 + Math.round(3 * enrageLvl)) : 0);
                                const mineRadius = 80;
                                const delay = ai.enraged ? Math.max(900, 1300 - Math.round(250 * enrageLvl)) : 1500;
                                const dmgBase = (18 + (hpPct < 0.5 ? 4 : 0));
                                const dmg = Math.round(dmgBase * this.dmgMult * (ai.enraged ? (1.2 + 0.3 * enrageLvl) : 1));

                                if (!Game.bossMines) Game.bossMines = [];
                                for (let i = 0; i < mineCount; i++) {
                                    const ang = (i / mineCount) * Math.PI * 2 + Math.random() * 0.25;
                                    const r = 110 + Math.random() * 90;
                                    let mx = this.x + Math.cos(ang) * r;
                                    let my = this.y + Math.sin(ang) * r;
                                    mx = Math.max(60, Math.min(WORLD_WIDTH - 60, mx));
                                    my = Math.max(60, Math.min(WORLD_HEIGHT - 60, my));
                                    Game.bossMines.push({ x: mx, y: my, radius: mineRadius, spawnAt: now, detonateAt: now + delay, delay: delay, damage: dmg });
                                }
                                createDamageText(this.x, this.y - 70, "THẢ MÌN!", "#FF9800");
                                ai.nextMines = now + (hpPct < 0.5 ? 8000 : 9800) * enrageCdMult;
                            } else if (pick === 'summon') {
                                ai.state = 'summon_cast';
                                ai.stateEnd = now + 650;
                                ai.nextSummon = now + (hpPct < 0.5 ? 11000 : 13500) * enrageCdMult;
                                createDamageText(this.x, this.y - 70, "GỌI LÍNH!", "#FF1744");
                            }
                        }
                    }

                    // --- Baseline shooting (disable while charging/windup casts) ---
                    const canShoot = (ai.state === 'idle');
                    if (canShoot && now - this.lastShot > (this.config.fireRate / (this.fireRateMult * enrageShootMult))) { 
                        this.shoot(desiredAngle, 'FAST');
                        this.lastShot = now;
                    }
                } else {
                    if (this.config.behavior === 'ORBIT' && dist < 250) desiredAngle += Math.PI / 2;
                    else if (this.config.behavior === 'SNIPER') { if (dist < 400) desiredAngle += Math.PI; else if (dist < 450) moveSpeed = 0; }
                    const fr = (this.config.fireRate / this.fireRateMult); if (this.config.fireRate && now - this.lastShot > fr) { if (dist < 800 && !isLineBlocked(this.x, this.y, target.x, target.y, obstacles)) { this.shoot(desiredAngle, 'NORMAL'); this.lastShot = now; } }
                }

                let bestAngle = desiredAngle; let foundPath = false;
                const checkAngles = [0, 20, -20, 45, -45, 65, -65, 90, -90, 110, -110, 135, -135, 160, -160, 180];
                for (let offset of checkAngles) {
                    const testAngle = desiredAngle + (offset * Math.PI) / 180; if(isNaN(testAngle)) continue;
                    const lookAhead = Math.max(this.radius * 1.5, (this.config.speed * this.speedMult) * 5); const nextX = this.x + Math.cos(testAngle) * lookAhead; const nextY = this.y + Math.sin(testAngle) * lookAhead;
                    let collided = false;
                    if (nextX < this.radius || nextX > WORLD_WIDTH - this.radius || nextY < this.radius || nextY > WORLD_HEIGHT - this.radius) collided = true;
                    if (!collided) { if (this.typeKey !== 'BOSS') { for (let obs of obstacles) { if (checkCircleRect({x: nextX, y: nextY, radius: this.radius + 5}, obs)) { collided = true; break; } } } }
                    if (!collided) { bestAngle = testAngle; foundPath = true; break; }
                }

                if (moveSpeed > 0 && (foundPath || this.typeKey === 'BOSS') && !isNaN(bestAngle)) { this.x += Math.cos(bestAngle) * moveSpeed; this.y += Math.sin(bestAngle) * moveSpeed; this.angle = bestAngle; } else { this.angle = Math.atan2(dy, dx); }

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let obs = obstacles[i];
                    if (checkCircleRect({x: this.x, y: this.y, radius: this.radius}, obs)) {
                        if (this.typeKey === 'BOSS') { obstacles.splice(i, 1); createComplexExplosion(obs.x + obs.width/2, obs.y + obs.height/2, '#546E7A'); createDamageText(this.x, this.y - 50, "CRUSH!", "#D50000"); } 
                        else { const anglePush = Math.atan2(this.y - (obs.y + obs.height/2), this.x - (obs.x + obs.width/2)); if(!isNaN(anglePush)) { this.x += Math.cos(anglePush) * 2; this.y += Math.sin(anglePush) * 2; } }
                    }
                }
                this.x = Math.max(0, Math.min(WORLD_WIDTH, this.x)); this.y = Math.max(0, Math.min(WORLD_HEIGHT, this.y)); this.validatePosition();
            }
            shoot(angle, mode) {
                if(isNaN(angle)) return;
                let speed = this.config.bulletSpeed; let dmg = this.config.bulletDmg; let color = this.typeKey === 'YELLOW' ? '#FFF59D' : '#E040FB';
                if (this.typeKey === 'BOSS') { color = '#FF1744'; if (mode === 'HEAVY') { dmg = 40; } if (mode === 'FAST') { speed = 12; } } dmg = Math.round(dmg * this.dmgMult);
                const bulletConfig = { damage: dmg, speed: speed, color: color, radius: 6 };
                const bullet = new Bullet(this.x, this.y, angle, 'NORMAL', bulletConfig, 'ENEMY');
                if (mode === 'HEAVY') bullet.radius = 10;
                Game.projectiles.push(bullet);
                createMuzzleFlash(this.x, this.y, angle, color);
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); if (this.effects.stun.active) { ctx.strokeStyle = '#00BCD4'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, Math.PI*2); ctx.stroke(); }
                ctx.rotate(this.angle);
                ctx.fillStyle = this.config.color; if (this.config.outline) { ctx.strokeStyle = this.config.outline; ctx.lineWidth = 3; ctx.strokeRect(-this.radius, -this.radius, this.radius*2, this.radius*2); }
                ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                if (this.typeKey === 'BOSS') { ctx.fillStyle = '#B71C1C'; ctx.fillRect(-20, -20, 40, 40); ctx.strokeStyle = '#FFEB3B'; ctx.strokeRect(-this.radius, -this.radius, this.radius*2, this.radius*2); }
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, -5, this.radius + 5, 10); ctx.restore();
                // Boss telegraphs (dễ né - dễ đọc)
                if (this.typeKey === 'BOSS' && this.bossAI) {
                    const now2 = Date.now();
                    const ai = this.bossAI;

                    if (ai.enraged) {
                        // Aura cuồng nộ (nhìn phát biết ngay)
                        const pulse = 0.5 + 0.5 * Math.sin(now2 / 80);
                        ctx.save();
                        ctx.strokeStyle = 'rgba(255,23,68,0.65)';
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 10 + pulse * 6, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }


                    if (ai.state === 'charge_windup') {
                        ctx.save();
                        ctx.strokeStyle = 'rgba(255,23,68,0.9)';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x + Math.cos(ai.chargeDir) * 280, this.y + Math.sin(ai.chargeDir) * 280);
                        ctx.stroke();
                        ctx.restore();
                    }

                    if (ai.state === 'radial_windup') {
                        ctx.save();
                        const t = Math.max(0, Math.min(1, (ai.stateEnd - now2) / 550));
                        const r = 110 + (1 - t) * 50;
                        ctx.strokeStyle = 'rgba(255,23,68,0.75)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    if (ai.state === 'summon_cast') {
                        ctx.save();
                        const t = Math.max(0, Math.min(1, (ai.stateEnd - now2) / 650));
                        const r = 90 + (1 - t) * 70;
                        ctx.strokeStyle = 'rgba(255,235,59,0.75)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([8, 8]);
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                }
                if (this.typeKey !== 'BOSS') { const hpPercent = this.hp / this.maxHp; ctx.fillStyle = 'red'; ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30, 4); ctx.fillStyle = '#0f0'; ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30 * hpPercent, 4); }
            }
        }

        class Player extends GameObject {
            constructor(systemId = 'default') {
                super(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, 22);
                this.systemId = systemId || 'default';
                this.maxHp = 100; this.hp = this.maxHp; this.baseSpeed = 6.5; this.speed = this.baseSpeed; this.angle = 0; this.inventory = [{ id: 'NORMAL', level: 1 }]; this.currentWeaponIndex = 0; this.ultiCharge = 0; 
                this.buffs = { shield: { active: false, endTime: 0 }, rapid: { active: false, endTime: 0 }, phase: { active: false, endTime: 0 }, adrenaline: { active: false, endTime: 0, speedMult: 1.25, fireMult: 0.85, damageMult: 1.3 } };
                this.skills = { clone: { lastUsed: 0, active: false }, stealth: { lastUsed: 0, active: false, endTime: 0 }, vampirism: { lastUsed: 0, active: false, endTime: 0 } };
                this.vampHeal = { windowStart: 0, healed: 0 };
                this.dash = { active: false, endTime: 0, vx: 0, vy: 0 };
                this.isStealth = false; this.lastShot = 0;
            }
            activateCheat() { this.inventory = [{ id: 'NORMAL', level: 5 }, { id: 'STUN', level: 5 }, { id: 'LIGHTNING', level: 5 }, { id: 'FIRE', level: 5 }, { id: 'PIERCING', level: 5 }, { id: 'HOMING', level: 5 }]; if (this.currentWeaponIndex >= this.inventory.length) { this.currentWeaponIndex = 0; } this.ultiCharge = 100; createDamageText(this.x, this.y - 60, "CHEAT ACTIVATED!", "#FFD700"); Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex); }
            addWeapon(weaponId) {
                const existingIndex = this.inventory.findIndex(w => w.id === weaponId);
                if (existingIndex !== -1) { if (this.inventory[existingIndex].level < 5) { this.inventory[existingIndex].level++; createDamageText(this.x, this.y - 40, `UPGRADE! LVL ${this.inventory[existingIndex].level}`, "#FFD700"); if (this.currentWeaponIndex === existingIndex) { Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex); } } else { createDamageText(this.x, this.y - 40, "MAX LEVEL!", "#fff"); } } 
                else { if (this.inventory.length >= 6) { createDamageText(this.x, this.y - 40, "FULL!", "#ff4444"); } else { this.inventory.push({ id: weaponId, level: 1 }); createDamageText(this.x, this.y - 40, "NEW WEAPON!", "#fff"); this.selectWeapon(this.inventory.length - 1); } }
                Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
            }
            selectWeapon(index) { if (index >= 0 && index < this.inventory.length) this.currentWeaponIndex = index; else this.currentWeaponIndex = 0; Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex); }
            loseCurrentWeapon() {
                // Hit penalty (easier + logical):
                // - NORMAL: giảm 1 cấp (min = 1, không thể 'mất' hẳn)
                // - Special: nếu Lv>1 => giảm 1 cấp; nếu Lv=1 => mất vũ khí đó và CHUYỂN QUA NORMAL (giữ level NORMAL hiện tại)

                if (!this.inventory || this.inventory.length === 0) {
                    this.inventory = [{ id: 'NORMAL', level: 1 }];
                    this.currentWeaponIndex = 0;
                    Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
                    return;
                }

                // đảm bảo NORMAL luôn tồn tại ở slot 0
                if (!this.inventory[0] || this.inventory[0].id !== 'NORMAL') {
                    this.inventory.unshift({ id: 'NORMAL', level: 1 });
                    if (typeof this.currentWeaponIndex === 'number') this.currentWeaponIndex += 1;
                }

                if (this.currentWeaponIndex == null || this.currentWeaponIndex < 0 || this.currentWeaponIndex >= this.inventory.length) {
                    this.currentWeaponIndex = 0;
                }

                const currentWep = this.inventory[this.currentWeaponIndex];
                if (!currentWep) {
                    this.currentWeaponIndex = 0;
                    Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
                    return;
                }

                // NORMAL: vẫn bị giảm cấp khi trúng đạn, nhưng không xuống dưới 1
                if (currentWep.id === 'NORMAL') {
                    const lv = (currentWep.level | 0) || 1;
                    if (lv > 1) {
                        currentWep.level = lv - 1;
                        createDamageText(this.x, this.y - 60, "GIẢM 1 CẤP!", "#ff4444");
                    } else {
                        currentWep.level = 1;
                    }
                    Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
                    return;
                }

                // Special weapons
                const lv = (currentWep.level | 0) || 1;
                if (lv > 1) {
                    currentWep.level = lv - 1;
                    createDamageText(this.x, this.y - 60, "GIẢM 1 CẤP!", "#ff4444");
                } else {
                    // Lv 1: mất vũ khí đặc biệt và CHUYỂN QUA NORMAL (slot 0 giữ nguyên level)
                    this.inventory.splice(this.currentWeaponIndex, 1);
                    this.currentWeaponIndex = 0;
                    createDamageText(this.x, this.y - 60, "MẤT VŨ KHÍ!", "#ff4444");
                }

                Game.ui.updateWeaponInventory(this.inventory, this.currentWeaponIndex);
            }
            getCurrentWeaponObj() { if (this.currentWeaponIndex === -1 || !this.inventory[this.currentWeaponIndex]) return { id: 'NORMAL', level: 1 }; return this.inventory[this.currentWeaponIndex]; }
            useSkill(skillName) {
                const now = Date.now();
                const config = getSystemSkillDef(this.systemId, skillName);
                const skillState = this.skills[skillName];
                if (!skillState || !config) return;

                // Cooldown gate
                if (now - skillState.lastUsed < (config.cooldown || 0)) return;

                // Speed system: 3 skills thật
                if (this.systemId === 'speed') {
                    skillState.lastUsed = now;

                    if (skillName === 'clone') {
                        // DASH: lướt nhanh theo hướng đang di chuyển (hoặc hướng nòng súng nếu đứng yên)
                        let dx = 0, dy = 0;
                        if (Input.keys.w) dy -= 1; if (Input.keys.s) dy += 1; if (Input.keys.a) dx -= 1; if (Input.keys.d) dx += 1;
                        if (dx === 0 && dy === 0) { dx = Math.cos(this.angle); dy = Math.sin(this.angle); }
                        const len = Math.hypot(dx, dy) || 1;
                        dx /= len; dy /= len;

                        const dur = config.duration || 250;
                        const dashSpeed = (this.baseSpeed || this.speed || 6.5) * (config.dashSpeedMult || 3.2);

                        this.dash.active = true;
                        this.dash.endTime = now + dur;
                        this.dash.vx = dx * dashSpeed;
                        this.dash.vy = dy * dashSpeed;

                        createDamageText(this.x, this.y - 40, 'DASH!', config.color || '#4FC3F7');
                        return;
                    }

                    if (skillName === 'stealth') {
                        // PHASE: miễn thương ngắn
                        const dur = config.duration || 800;
                        this.buffs.phase.active = true;
                        this.buffs.phase.endTime = now + dur;
                        Game.ui.removeBuff('Phase');
                        Game.ui.addBuff('Phase', config.color || '#81D4FA');
                        createDamageText(this.x, this.y - 40, 'PHASE!', config.color || '#81D4FA');
                        return;
                    }

                    if (skillName === 'vampirism') {
                        // ADRENALINE: tăng tốc chạy + tăng tốc bắn tạm thời
                        const dur = config.duration || 4000;
                        this.buffs.adrenaline.active = true;
                        this.buffs.adrenaline.endTime = now + dur;
                        this.buffs.adrenaline.speedMult = config.speedMult || 1.25;
                        this.buffs.adrenaline.fireMult = config.fireMult || 0.85;
                        this.buffs.adrenaline.damageMult = config.damageMult || 1.3;
                        Game.ui.removeBuff('Adren');
                        Game.ui.addBuff('Adren', config.color || '#29B6F6');
                        createDamageText(this.x, this.y - 40, 'ADREN!', config.color || '#29B6F6');
                        return;
                    }
                }

                // Engineer system: 3 skills thật
                if (this.systemId === 'engineer') {
                    skillState.lastUsed = now;

                    if (skillName === 'clone') {
                        // TURRET: đặt tháp tự bắn
                        if (!Game.turrets) Game.turrets = [];
                        const maxT = config.maxTurrets || 1;

                        // Nếu đã đủ số lượng -> thay thế turret cũ nhất
                        if (Game.turrets.length >= maxT) {
                            const old = Game.turrets.shift();
                            if (old) { old.markedForDeletion = true; createComplexExplosion(old.x, old.y, config.color || '#81C784'); }
                            createDamageText(this.x, this.y - 60, 'THAY THẾ!', '#ccc');
                        }

                        // Tìm vị trí đặt không kẹt vật cản
                        const off = 55;
                        const candidates = [
                            { x: this.x + Math.cos(this.angle) * off, y: this.y + Math.sin(this.angle) * off },
                            { x: this.x - Math.cos(this.angle) * off, y: this.y - Math.sin(this.angle) * off },
                            { x: this.x + off, y: this.y },
                            { x: this.x - off, y: this.y },
                            { x: this.x, y: this.y + off },
                            { x: this.x, y: this.y - off }
                        ];
                        let pos = candidates[0];
                        outer: for (const c of candidates) {
                            for (const obs of Game.obstacles) {
                                if (checkCircleRect({ x: c.x, y: c.y, radius: 22 }, obs)) continue outer;
                            }
                            pos = c;
                            break;
                        }

                        const turret = new Turret(pos.x, pos.y, {
                            duration: config.duration || 10000,
                            range: config.range || 650,
                            fireRate: config.fireRate || 320,
                            color: config.color || '#81C784',
                            bulletColor: config.bulletColor || '#66BB6A',
                            bulletDmgMult: (typeof config.bulletDmgMult === 'number') ? config.bulletDmgMult : 0.65
                        });
                        Game.turrets.push(turret);
                        createDamageText(this.x, this.y - 40, 'TURRET!', config.color || '#81C784');
                        return;
                    }

                    if (skillName === 'stealth') {
                        // REPAIR: hồi máu
                        const healAmt = config.heal || 30;
                        if (typeof this.heal === 'function') this.heal(healAmt);
                        else {
                            this.hp = Math.min(this.maxHp, this.hp + healAmt);
                            Game.ui.updateHealth(this.hp, this.maxHp);
                        }
                        createDamageText(this.x, this.y - 40, 'REPAIR!', config.color || '#A5D6A7');
                        createComplexExplosion(this.x, this.y, '#4CAF50', 10);
                        return;
                    }

                                        if (skillName === 'vampirism') {
                        // EMP: choáng diện rộng + làm tan đạn địch + đóng băng Boss (kèm sát thương nhẹ)
                        const radius = config.radius || 340;
                        const dur = config.stunDuration || 1200;
                        const now2 = Date.now();
                        let hit = 0;
                        let bulletsCleared = 0;
                        let bossFrozen = 0;

                        // 1) Làm tan đạn địch đang bay tới trong phạm vi xung
                        if (Game.projectiles && Game.projectiles.length) {
                            for (const b of Game.projectiles) {
                                if (!b || b.markedForDeletion) continue;
                                if (b.owner !== 'ENEMY') continue;
                                const dB = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dB <= radius) { b.markedForDeletion = true; bulletsCleared++; }
                            }
                        }

                        // 2) Choáng lính thường, riêng Boss bị 'đóng băng' + nhận sát thương nhẹ
                        for (const e of Game.enemies) {
                            if (!e || e.markedForDeletion || e.hp <= 0) continue;
                            const d = Math.hypot(e.x - this.x, e.y - this.y);
                            if (d > radius) continue;
                            if (e.typeKey === 'BOSS') {
                                // Bypass miễn nhiễm STUN: đóng băng bằng cách khóa update tạm thời
                                if (e.effects && e.effects.stun) { e.effects.stun.active = true; e.effects.stun.endTime = now2 + Math.min(dur, 900); }
                                const base = (typeof e.maxHp === 'number' && e.maxHp > 0) ? e.maxHp : e.hp;
                                const bossDmg = Math.max(30, Math.round(base * 0.015)); // ~1.5% HP (nhẹ)
                                e.hp -= bossDmg;
                                createDamageText(e.x, e.y - 10, '-' + bossDmg, '#B3E5FC');
                                createDamageText(e.x, e.y - 32, 'ĐÓNG BĂNG!', '#00E5FF');
                                createComplexExplosion(e.x, e.y, '#00E5FF', 10);
                                bossFrozen++;
                            } else {
                                e.applyEffect({ type: 'STUN', duration: dur });
                                hit++;
                            }
                        }

                        // shockwave visual
                        Game.particles.push(new Particle(this.x, this.y, { type: 'shockwave', color: '#00E5FF', size: 12, maxRadius: radius, decay: 0.03 }));
                        createDamageText(this.x, this.y - 40, 'EMP! (' + hit + ')', '#00E5FF');
                        if (bulletsCleared > 0) createDamageText(this.x, this.y - 62, 'TAN ĐẠN: ' + bulletsCleared, '#B3E5FC');
                        if (bossFrozen > 0) createDamageText(this.x, this.y - 84, 'BOSS ĐÓNG BĂNG!', '#00E5FF');
                        Game.shake = Math.max(Game.shake, 14);
                        return;
                    }
                }

                // Non-default systems: placeholder (fallback)
                if (this.systemId !== 'default') {
                    skillState.lastUsed = now;
                    createDamageText(this.x, this.y - 40, config.castText || 'COMING SOON', config.color || '#FFD700');
                    return;
                }


                // Default system: keep existing skills
                skillState.lastUsed = now;
                if (skillName === 'clone') {
                    if (Game.clones.length > 0) {
                        Game.clones.forEach(c => { c.markedForDeletion = true; createComplexExplosion(c.x, c.y, COLORS.clone); });
                        Game.clones = [];
                        createDamageText(this.x, this.y - 60, 'THAY THẾ!', '#ccc');
                    }
                    createDamageText(this.x, this.y - 40, 'PHÂN THÂN CHIẾN ĐẤU!', COLORS.clone);
                    Game.clones.push(new CloneTank(this.x + 50, this.y));
                }
                else if (skillName === 'stealth') {
                    createDamageText(this.x, this.y - 40, 'TÀNG HÌNH!', '#AB47BC');
                    this.isStealth = true;
                    skillState.active = true;
                    skillState.endTime = now + (config.duration || 0);
                }
                else if (skillName === 'vampirism') {
                    createDamageText(this.x, this.y - 40, 'HÚT MÁU!', '#FF5252');
                    skillState.active = true;
                    skillState.endTime = now + (config.duration || 0);
                }
            }
            addBuff(type, duration) { const now = Date.now(); if (type === 'shield') { this.buffs.shield.active = true; this.buffs.shield.endTime = now + duration; document.getElementById('shieldOverlay').style.display = 'block'; Game.ui.addBuff('Shield', '#2196F3'); } else if (type === 'rapid') { this.buffs.rapid.active = true; this.buffs.rapid.endTime = now + duration; Game.ui.addBuff('Rapid', '#FF9800'); } }
            useUltimate() {
                if (this.ultiCharge < 100) return; this.ultiCharge = 0; Game.ui.updateUltiBar(0); createDamageText(this.x, this.y - 80, "FIRESTORM!!!", "#FFD700"); Game.shake = 30;
                if (typeof MAX !== 'undefined') MAX.Audio.ulti(); createComplexExplosion(this.x, this.y, '#FF5722', 50); 
                Game.enemies.forEach(e => { if (e.typeKey === 'BOSS') { e.hp -= 250; createDamageText(e.x, e.y, "-250", "#FFD700"); createComplexExplosion(e.x, e.y, '#FF5722', 20); } else { const dmg = 150; e.hp -= dmg; createDamageText(e.x, e.y, `-${dmg}`, "#FF5722"); createComplexExplosion(e.x, e.y, '#FF5722', 10); } });
            }
            gainUltiCharge(amount) { this.ultiCharge = Math.min(100, this.ultiCharge + amount); Game.ui.updateUltiBar(this.ultiCharge); }
            update(obstacles) {
                if (Input.keys['1']) this.selectWeapon(0); if (Input.keys['2']) this.selectWeapon(1); if (Input.keys['3']) this.selectWeapon(2); if (Input.keys['4']) this.selectWeapon(3); if (Input.keys['5']) this.selectWeapon(4); if (Input.keys['6']) this.selectWeapon(5);
                if (Input.keys['q']) this.useSkill('clone'); if (Input.keys['e']) this.useSkill('stealth'); if (Input.keys['r']) this.useSkill('vampirism'); if (Input.keys[' ']) this.useUltimate();

                const now = Date.now();

                // Default system skill expirations
                if (this.systemId === 'default') {
                    if (this.isStealth && now > this.skills.stealth.endTime) {
                        this.isStealth = false;
                        this.skills.stealth.active = false;
                        createDamageText(this.x, this.y - 40, "HẾT TÀNG HÌNH", "#fff");
                    }
                    if (this.skills.vampirism.active && now > this.skills.vampirism.endTime) {
                        this.skills.vampirism.active = false;
                        createDamageText(this.x, this.y - 40, "HẾT HÚT MÁU", "#fff");
                    }
                }

                // Speed system expirations
                if (this.systemId === 'speed') {
                    if (this.dash && this.dash.active && now > this.dash.endTime) {
                        this.dash.active = false;
                    }
                    if (this.buffs.phase && this.buffs.phase.active && now > this.buffs.phase.endTime) {
                        this.buffs.phase.active = false;
                        Game.ui.removeBuff('Phase');
                        createDamageText(this.x, this.y - 40, "HẾT PHASE", "#fff");
                    }
                    if (this.buffs.adrenaline && this.buffs.adrenaline.active && now > this.buffs.adrenaline.endTime) {
                        this.buffs.adrenaline.active = false;
                        Game.ui.removeBuff('Adren');
                        createDamageText(this.x, this.y - 40, "HẾT ADREN", "#fff");
                    }
                }

                // Effective speed (Adrenaline)
                let effSpeed = (this.baseSpeed || this.speed || 6.5);
                if (this.systemId === 'speed' && this.buffs.adrenaline && this.buffs.adrenaline.active) {
                    effSpeed *= (this.buffs.adrenaline.speedMult || 1.25);
                }
                this.speed = effSpeed;

                // Movement (Dash overrides)
                let dx = 0, dy = 0;
                if (this.dash && this.dash.active && now <= this.dash.endTime) {
                    dx = this.dash.vx;
                    dy = this.dash.vy;
                } else {
                    if (this.dash) this.dash.active = false;
                    if (Input.keys.w) dy -= 1; if (Input.keys.s) dy += 1; if (Input.keys.a) dx -= 1; if (Input.keys.d) dx += 1;
                    if (dx !== 0 || dy !== 0) {
                        const length = Math.hypot(dx, dy) || 1;
                        dx = (dx / length) * effSpeed;
                        dy = (dy / length) * effSpeed;
                    }
                }

                if(isNaN(dx)) dx = 0; if(isNaN(dy)) dy = 0;
                let nextX = this.x + dx; let nextY = this.y + dy;

                let collided = false;
                for (let obs of obstacles) {
                    if (checkCircleRect({x: nextX, y: nextY, radius: this.radius}, obs)) {
                        collided = true;
                        if (!checkCircleRect({x: nextX, y: this.y, radius: this.radius}, obs)) this.x = nextX;
                        else if (!checkCircleRect({x: this.x, y: nextY, radius: this.radius}, obs)) this.y = nextY;
                        break;
                    }
                }
                if (!collided) { this.x = nextX; this.y = nextY; }

                for (let obs of obstacles) {
                    if (checkCircleRect({x: this.x, y: this.y, radius: this.radius}, obs)) {
                        const obsCX = obs.x + obs.width/2;
                        const obsCY = obs.y + obs.height/2;
                        const anglePush = Math.atan2(this.y - obsCY, this.x - obsCX);
                        this.x += Math.cos(anglePush) * 4;
                        this.y += Math.sin(anglePush) * 4;
                    }
                }

                this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y));

                const worldMouseX = Input.mouse.x + Camera.x;
                const worldMouseY = Input.mouse.y + Camera.y;
                this.angle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x);

                // Expire item buffs
                if (this.buffs.shield.active && now > this.buffs.shield.endTime) {
                    this.buffs.shield.active = false;
                    document.getElementById('shieldOverlay').style.display = 'none';
                    Game.ui.removeBuff('Shield');
                }
                if (this.buffs.rapid.active && now > this.buffs.rapid.endTime) {
                    this.buffs.rapid.active = false;
                    Game.ui.removeBuff('Rapid');
                }

                if (Input.mouse.down) this.shoot(obstacles);

                Game.ui.updateSkillCooldown('clone', this.skills.clone.lastUsed, getSystemSkillDef(this.systemId, 'clone').cooldown);
                Game.ui.updateSkillCooldown('stealth', this.skills.stealth.lastUsed, getSystemSkillDef(this.systemId, 'stealth').cooldown);
                Game.ui.updateSkillCooldown('vampirism', this.skills.vampirism.lastUsed, getSystemSkillDef(this.systemId, 'vampirism').cooldown);
                this.validatePosition();
            }
            shoot(obstacles) {
                const now = Date.now();
                // Speed system: cannot shoot while dashing (feels cleaner + less buggy)
                if (this.systemId === 'speed' && this.dash && this.dash.active && now <= this.dash.endTime) return; const weaponObj = this.getCurrentWeaponObj(); const baseConfig = BULLET_TYPES[weaponObj.id];
                let level = weaponObj.level || 1; let damage = baseConfig.damage; let cooldown = baseConfig.cooldown; let speed = baseConfig.speed;
                if (weaponObj.id === 'NORMAL') { cooldown = Math.max(100, baseConfig.cooldown - (level - 1) * 30); damage += (level - 1) * 3; }
                else if (weaponObj.id === 'FIRE') { cooldown = Math.max(80, baseConfig.cooldown - (level - 1) * 30); damage += (level - 1) * 2; }
                else if (weaponObj.id === 'LIGHTNING') { damage += (level - 1) * 5; } else if (weaponObj.id === 'PIERCING') { damage += (level - 1) * 10; }
                else if (weaponObj.id === 'HOMING') { damage += (level - 1) * 4; if(level >= 5) damage += 15; } else if (weaponObj.id === 'STUN') { cooldown = Math.max(200, baseConfig.cooldown - (level - 1) * 50); }
                if (this.buffs.rapid.active) cooldown *= ITEM_TYPES.RAPID_FIRE.value;

                // Speed system: Adrenaline reduces cooldown
                if (this.systemId === 'speed' && this.buffs.adrenaline && this.buffs.adrenaline.active) {
                    cooldown *= (this.buffs.adrenaline.fireMult || 0.85);
                }

                

                // Speed system: Adrenaline increases damage
                if (this.systemId === 'speed' && this.buffs.adrenaline && this.buffs.adrenaline.active) {
                    damage *= (this.buffs.adrenaline.damageMult || 1.3);
                }
                // Shop upgrade: Fire Rate (-5% cooldown per level)
                if (Game.upgrades && Game.upgrades.fireRateLv) {
                    const flv = Game.upgrades.fireRateLv | 0;
                    const frMax = getFireRateMaxLv();
                    const flvC = Math.min(flv, frMax);
                    const mult = Math.pow(0.95, flvC);
                    cooldown *= mult;
                    cooldown = Math.max(80, cooldown); // clamp: tối thiểu 80ms để không "vỡ" game
                }
if (now - this.lastShot > cooldown) {
                    let finalConfig = { ...baseConfig, damage: damage, speed: speed };
                    if (weaponObj.id === 'LIGHTNING') { finalConfig.chainCount = baseConfig.chainCount + (level - 1); finalConfig.chainRange = baseConfig.chainRange + (level - 1) * 50; }
                    else if (weaponObj.id === 'PIERCING') { finalConfig.pierceCount = baseConfig.pierceCount + (level - 1); if (level >= 5) finalConfig.radius = 10; }
                    else if (weaponObj.id === 'FIRE') { finalConfig.effect = { ...baseConfig.effect, tickDamage: (baseConfig.effect.tickDamage + (level - 1) * 2) * ((this.systemId === 'speed' && this.buffs.adrenaline && this.buffs.adrenaline.active) ? (this.buffs.adrenaline.damageMult || 1.3) : 1) }; }
                    else if (weaponObj.id === 'HOMING') { finalConfig.turnSpeed = Math.min(0.5, baseConfig.turnSpeed + (level - 1) * 0.05); }
                    else if (weaponObj.id === 'STUN') { finalConfig.effect = { ...baseConfig.effect, duration: baseConfig.effect.duration + (level - 1) * 200 }; }

                    const tipX = this.x + Math.cos(this.angle) * 35; const tipY = this.y + Math.sin(this.angle) * 35;
                    const spawnBullet = (ang) => { 
                        Game.projectiles.push(new Bullet(tipX, tipY, ang, weaponObj.id, finalConfig, 'PLAYER'));
                        createMuzzleFlash(tipX, tipY, ang, finalConfig.color);
                    };

                    if (weaponObj.id === 'NORMAL' && level >= 5) { spawnBullet(this.angle); spawnBullet(this.angle - 0.2); spawnBullet(this.angle + 0.2); }
                    else if (weaponObj.id === 'NORMAL' && level >= 3) { spawnBullet(this.angle - 0.1); spawnBullet(this.angle + 0.1); }
                    else if (weaponObj.id === 'HOMING' && level >= 5) { spawnBullet(this.angle); spawnBullet(this.angle - 0.3); spawnBullet(this.angle + 0.3); }
                    else { spawnBullet(this.angle); }

                    const recoilX = Math.cos(this.angle) * 2; const recoilY = Math.sin(this.angle) * 2; const nextX = this.x - recoilX; const nextY = this.y - recoilY;
                    let canRecoil = true; if (obstacles) { for (let obs of obstacles) { if (checkCircleRect({x: nextX, y: nextY, radius: this.radius}, obs)) { canRecoil = false; break; } } }
                    if (canRecoil) { this.x = nextX; this.y = nextY; }
                    this.lastShot = now;
                }
            }
            takeDamage(amount) {
                // Speed system: Phase = miễn thương
                if (this.buffs.phase && this.buffs.phase.active && Date.now() <= this.buffs.phase.endTime) {
                    // Phase (Speed): miễn thương, và chuyển 50% sát thương nhận vào thành máu
                    let a = amount;
                    // tính giảm sát thương như bình thường (Shield + Armor) để giữ cân bằng
                    if (this.buffs.shield.active) a *= 0.3;

                    const alvP = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv | 0) : 0;
                    const reductionP = Math.min(0.60, alvP * 0.05);
                    const finalAmountP = (a > 0) ? Math.max(1, Math.round(a * (1 - reductionP))) : a;

                    const healAmt = (finalAmountP > 0) ? (finalAmountP * 0.5) : 0;
                    if (healAmt > 0) {
                        this.heal(healAmt);
                        createDamageText(this.x, this.y - 60, `+${Math.round(healAmt)}`, "#00ff88");
                    }
                    return;
                }

                if (this.buffs.shield.active) amount *= 0.3;
                else if (amount > 0) this.loseCurrentWeapon();

                // Armor upgrade: -5% damage taken per level (cap 60%)
                const alv = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv | 0) : 0;
                const reduction = Math.min(0.60, alv * 0.05);
                const finalAmount = (amount > 0) ? Math.max(1, Math.round(amount * (1 - reduction))) : amount;

                this.hp -= finalAmount;
                if (this.hp < 0) this.hp = 0;
                Game.ui.updateHealth(this.hp, this.maxHp);
                Game.shake = 10;
            }

            heal(amount) {
                this.hp = Math.min(this.hp + amount, this.maxHp);
                Game.ui.updateHealth(this.hp, this.maxHp);
                createDamageText(this.x, this.y - 20, `+${Math.floor(amount)}`, '#4CAF50');
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Alpha for Stealth / Phase
                let alpha = 1;
                if (this.isStealth) alpha = 0.4;
                if (this.buffs.phase && this.buffs.phase.active) alpha = 0.35;
                ctx.globalAlpha = alpha;

                // Default system: Vamp aura
                if (this.skills.vampirism.active) {
                    ctx.strokeStyle = '#FF5252';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 82, 82, 0.1)';
                    ctx.fill();
                }

                // Speed system visuals
                if (this.buffs.phase && this.buffs.phase.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 16, 0, Math.PI * 2);
                    ctx.strokeStyle = '#81D4FA';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(129, 212, 250, 0.08)';
                    ctx.fill();
                }
                if (this.buffs.adrenaline && this.buffs.adrenaline.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 12, 0, Math.PI * 2);
                    ctx.strokeStyle = '#29B6F6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(41, 182, 246, 0.06)';
                    ctx.fill();
                }
                if (this.dash && this.dash.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 18, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(79, 195, 247, 0.55)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Item buff: Shield
                if (this.buffs.shield.active) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
                    ctx.strokeStyle = COLORS.shield;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 191, 255, 0.1)';
                    ctx.fill();
                }

                // Body
                ctx.fillStyle = '#333';
                ctx.fillRect(-22, -22, 44, 44);
                ctx.fillStyle = '#111';
                ctx.fillRect(-26, -24, 8, 48);
                ctx.fillRect(18, -24, 8, 48);

                // Turret
                ctx.rotate(this.angle);
                const wObj = this.getCurrentWeaponObj();
                const wConfig = BULLET_TYPES[wObj.id];
                ctx.fillStyle = wConfig.color;
                ctx.beginPath();
                ctx.arc(0, 0, 18, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = COLORS.playerTurret;
                ctx.fillRect(0, -6, 40, 12);
                ctx.restore();
            }
        }

        // --- 4. GAME MANAGERS ---
        
        // --- ADMIN CODE INPUT (hidden) ---
        const Admin = {
            modal: null, panel: null, input: null, msg: null,
            prevPaused: false,
            init() {
                this.modal = document.getElementById('adminCodeModal');
                this.panel = document.getElementById('adminCodePanel');
                this.input = document.getElementById('adminCodeInput');
                this.msg = document.getElementById('adminCodeMsg');
                if (!this.modal || !this.input) return;

                // Click outside to close
                this.modal.addEventListener('mousedown', (e) => {
                    if (e.target === this.modal) this.close();
                });

                // Enter to submit
                this.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.run(this.input.value);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.close();
                    }
                });
            },
            isOpen() {
                return this.modal && !this.modal.classList.contains('hidden');
            },
            open() {
                if (!this.modal) return;
                this.prevPaused = !!Game.paused;
                Game.paused = true;
                this.msg.textContent = '';
                this.input.value = '';
                this.modal.classList.remove('hidden');
                setTimeout(() => this.input.focus(), 0);
            },
            close() {
                if (!this.modal) return;
                this.modal.classList.add('hidden');
                Game.paused = this.prevPaused;
            },
            run(codeRaw) {
                const code = String(codeRaw || '').trim().toLowerCase();
                if (!code) { this.msg.textContent = 'Nhập code...'; return; }

                try {
                    if (code === 'cuongdan') {
                        // Full ammo upgrade to Lv.5 (replaces old C)
                        if (Game.player && typeof Game.player.activateCheat === 'function') {
                            Game.player.activateCheat();
                            this.msg.textContent = 'OK';
                        } else {
                            this.msg.textContent = 'Chưa vào game.';
                            return;
                        }
                        this.close();
                        return;
                    }

                    if (code === 'cuongvang') {
                        // +100.000 gold (replaces old V)
                        Game.gold = (Game.gold || 0) + 100000;
                        if (Game.player) createDamageText(Game.player.x, Game.player.y - 45, "+100000G", "#FFD700");
                        this.msg.textContent = 'OK';
                        this.close();
                        return;
                    }

                    this.msg.textContent = 'Sai code.';
                } catch (err) {
                    this.msg.textContent = 'Lỗi.';
                }
            },
            // Capture keys so typing doesn't control the tank
            captureKey(e) {
                // Open combo (hidden): Ctrl + Shift + X
                if (!this.isOpen() && e.ctrlKey && e.shiftKey && (e.code === 'KeyX' || e.key === 'X' || e.key === 'x')) {
                    e.preventDefault();
                    this.open();
                    return true;
                }
                // If modal is open: block game controls BUT allow typing into input.
                if (this.isOpen()) {
                    // Safety: allow Esc to close even if focus isn't on input
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.close();
                        return true;
                    }
                    // Do NOT preventDefault here, otherwise the input cannot receive characters.
                    return true;
                }
                return false;
            }
        };

        const Input = {
            keys: {}, mouse: { x: 0, y: 0, down: false },
            init() {
                window.addEventListener('keydown', e => { if (typeof Admin !== 'undefined' && Admin.captureKey && Admin.captureKey(e)) return;  const k = e.key.toLowerCase(); if(['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(k)) e.preventDefault(); this.keys[k] = true; if(['1','2','3','4','5','6'].includes(e.key)) this.keys[e.key] = true;
                    if(e.key === ' ') this.keys[' '] = true; });
                window.addEventListener('keyup', e => { this.keys[e.key.toLowerCase()] = false; if(['1','2','3','4','5','6'].includes(e.key)) this.keys[e.key] = false; if (e.key === ' ') this.keys[' '] = false; });
                window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
                window.addEventListener('mousedown', () => this.mouse.down = true); window.addEventListener('mouseup', () => this.mouse.down = false);
                window.addEventListener('blur', () => { this.keys = {}; this.mouse.down = false; }); window.addEventListener('focus', () => { this.keys = {}; });
            }
        };

        const WaveManager = {
            wave: 1, finalWave: 20, enemiesRemainingToSpawn: 0, spawnTimer: 0, active: false, isBossWave: false, bossSpawned: false,
            scaling: null,
            computeScaling() {
                const w = this.wave | 0;
                const t = Math.max(0, w - 1);
                // NOTE: Linear scaling + caps để game không vỡ
                const hpMult = Math.min(4.0, 1 + 0.12 * t);
                const dmgMult = Math.min(3.0, 1 + 0.08 * t);
                const speedMult = Math.min(1.8, 1 + 0.02 * t);
                const fireRateMult = Math.min(1.8, 1 + 0.015 * t); // >1 nghĩa là bắn nhanh hơn

                const spawnInterval = Math.max(22, 60 - w * 2);
                const spawnCount = Math.min(60, 3 + Math.floor(w * 2) + Math.floor(w * w * 0.08));

                // Boss scale nhẹ hơn để không one-shot
                const bossHpMult = 1 + (w / 8);
                const bossDmgMult = 1 + (w / 12);

                return { hpMult, dmgMult, speedMult, fireRateMult, spawnInterval, spawnCount, bossHpMult, bossDmgMult };
            },
            startWave() {
                this.active = true; this.bossSpawned = false; this.isBossWave = (this.wave % 5 === 0); this.scaling = this.computeScaling(); Game.generateObstacles();
                if (this.isBossWave) { this.enemiesRemainingToSpawn = 1; createDamageText(Game.player.x, Game.player.y - 100, "BOSS BATTLE!", "#D50000"); document.getElementById('bossHealthContainer').style.display = 'block'; } 
                else { const count = (this.scaling ? this.scaling.spawnCount : (3 + Math.floor(this.wave * 1.5))); this.enemiesRemainingToSpawn = count; document.getElementById('bossHealthContainer').style.display = 'none'; }
                Game.ui.updateWave(this.wave);
            },
            update() {
                if (!this.active) return;
                if (this.enemiesRemainingToSpawn > 0) {
                    this.spawnTimer++;
                    if (this.spawnTimer > (this.scaling ? this.scaling.spawnInterval : 60)) {
                        this.spawnEnemy();
                        this.spawnTimer = 0;
                        this.enemiesRemainingToSpawn--;
                    }
                } else if (Game.enemies.length === 0) {
                    this.active = false;

                    // Victory: thắng Boss ở finalWave (mặc định 20). Muốn endless thì tăng finalWave.
                    if (!Game.endlessMode && this.isBossWave && (this.wave >= (this.finalWave || 20))) {
                        try { if (Game.player) createDamageText(Game.player.x, Game.player.y - 50, "CHIẾN THẮNG!", "#4CAF50"); } catch(e){}
                        if (Game && typeof Game.victory === 'function') Game.victory();
                        return;
                    }

                    this.wave++;
                    try { if (Game.player) createDamageText(Game.player.x, Game.player.y - 50, "WAVE COMPLETE!", "#FFD700"); } catch(e){}
                    Shop.show(this.wave, Game.gold, () => {
                        this.startWave();
                        if (Game.player) Game.player.heal(50);
                    });
                }
            },
            spawnEnemy() {
                let typeKey; if (this.isBossWave) { typeKey = 'BOSS'; } else { const pool = ['RED']; if (this.wave >= 2) pool.push('YELLOW'); if (this.wave >= 3) pool.push('YELLOW', 'BLACK'); if (this.wave >= 4) pool.push('BLACK', 'BLACK', 'PURPLE'); if (this.wave >= 5) pool.push('PURPLE', 'PURPLE'); typeKey = pool[Math.floor(Math.random() * pool.length)]; }
                let x, y, valid = false; let attempts = 0;
                while (!valid && attempts < 50) {
                    const edge = Math.floor(Math.random() * 4); const buffer = 100;
                    switch(edge) { case 0: x = Camera.x + Math.random() * canvas.width; y = Camera.y - buffer; break; case 1: x = Camera.x + canvas.width + buffer; y = Camera.y + Math.random() * canvas.height; break; case 2: x = Camera.x + Math.random() * canvas.width; y = Camera.y + canvas.height + buffer; break; case 3: x = Camera.x - buffer; y = Camera.y + Math.random() * canvas.height; break; }
                    x = Math.max(100, Math.min(WORLD_WIDTH - 100, x)); y = Math.max(100, Math.min(WORLD_HEIGHT - 100, y));
                    let hitObs = false; for(let obs of Game.obstacles) { if (checkCircleRect({x, y, radius: 80}, obs)) { hitObs = true; break; } }
                    if (!hitObs) valid = true; attempts++;
                }
                if (valid) { const sc = this.scaling || this.computeScaling(); const hpMult = this.isBossWave ? sc.bossHpMult : sc.hpMult; const dmgMult = this.isBossWave ? sc.bossDmgMult : sc.dmgMult; const speedMult = sc.speedMult; const fireRateMult = sc.fireRateMult; Game.enemies.push(new Enemy(x, y, typeKey, hpMult, dmgMult, speedMult, fireRateMult)); }
            }
        };

        // --- SHOP MANAGER (Wave Complete -> Shop) ---
        const Shop = {
            open: false,
            onContinue: null,
            els: {
                modal: null,
                gold: null,
                nextWave: null,
                btnContinue: null,

                btnBuyMaxHp: null,
                maxHpCost: null,
                maxHpLevel: null,

                btnBuyDmg: null,
                dmgCost: null,
                dmgLevel: null,

                btnBuyFireRate: null,
                fireRateCost: null,
                fireRateLevel: null,

                btnBuyMagnet: null,
                magnetCost: null,
                magnetLevel: null,

                btnBuyArmor: null,
                armorCost: null,
                armorLevel: null,
            },
            init() {
                this.els.modal = document.getElementById('shopModal');
                this.els.gold = document.getElementById('shopGold');
                this.els.nextWave = document.getElementById('shopNextWave');
                this.els.btnContinue = document.getElementById('btnShopContinue');

                
                
                // --- Step 3A: Random 3 upgrades mỗi lần mở shop ---
                this.cards = [];
                const grid = document.getElementById('shopCards');
                if (grid) {
                    const cards = Array.from(grid.querySelectorAll('.shopCard'));
                    for (const card of cards) {
                        const btn = card.querySelector('button[id^="btnBuy"]');
                        if (!btn) continue; // chỉ random các nâng cấp mua được
                        card.dataset.upKey = btn.id;
                        this.cards.push(card);
                    }
                }

                this._shuffle = (arr) => {
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = (Math.random() * (i + 1)) | 0;
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                };

this.els.btnBuyMaxHp = document.getElementById('btnBuyMaxHp');
                this.els.maxHpCost = document.getElementById('upMaxHpCost');
                this.els.maxHpLevel = document.getElementById('upMaxHpLevel');

                
                this.els.btnBuyDmg = document.getElementById('btnBuyDmg');
                this.els.dmgCost = document.getElementById('upDmgCost');
                this.els.dmgLevel = document.getElementById('upDmgLevel');

                
                this.els.btnBuyFireRate = document.getElementById('btnBuyFireRate');
                this.els.fireRateCost = document.getElementById('upFireRateCost');
                this.els.fireRateLevel = document.getElementById('upFireRateLevel');

                

                this.els.btnBuyMagnet = document.getElementById('btnBuyMagnet');
                this.els.magnetCost = document.getElementById('upMagnetCost');
                this.els.magnetLevel = document.getElementById('upMagnetLevel');
                if (this.els.btnBuyMagnet) {
                    this.els.btnBuyMagnet.addEventListener('click', () => this.buyMagnet());
                }

                this.els.btnBuyArmor = document.getElementById('btnBuyArmor');
                this.els.armorCost = document.getElementById('upArmorCost');
                this.els.armorLevel = document.getElementById('upArmorLevel');
                if (this.els.btnBuyArmor) {
                    this.els.btnBuyArmor.addEventListener('click', () => this.buyArmor());
                }
if (this.els.btnBuyFireRate) {
                    this.els.btnBuyFireRate.addEventListener('click', () => this.buyFireRate());
                }
if (this.els.btnBuyDmg) {
                    this.els.btnBuyDmg.addEventListener('click', () => this.buyDmg());
                }

if (this.els.btnBuyMaxHp) {
                    this.els.btnBuyMaxHp.addEventListener('click', () => this.buyMaxHp());
                }

if (this.els.btnContinue) {
                    this.els.btnContinue.addEventListener('click', () => this.continue());
                }

                window.addEventListener('keydown', (e) => {
                    if (!this.open) return;
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.continue();
                    }
                });
            },
            show(nextWaveNum, gold, cb) {
                this.open = true;
                this.onContinue = cb || null;
                if (this.els.gold) this.els.gold.textContent = String(gold || 0);
                if (this.els.nextWave) this.els.nextWave.textContent = String(nextWaveNum || 1);
                if (this.els.modal) this.els.modal.classList.remove('hidden');
                Game.paused = true;
            
                this.randomizeChoices();
                this.refresh();
            },
            maxHpCostForLevel(lv) {
                lv = Math.max(0, lv|0);
                // 50 -> 90 -> 140 -> 200 -> 270 ...
                return 50 + (40 * lv) + (5 * lv * (lv - 1));
            },
            dmgCostForLevel(lv) { lv = Math.max(0, lv|0); return 50 + (40 * lv) + (5 * lv * (lv - 1)); },
            fireRateCostForLevel(lv) { lv = Math.max(0, lv|0); return 50 + (40 * lv) + (5 * lv * (lv - 1)); },
            magnetCostForLevel(lv) { lv = Math.max(0, lv|0); return 50 + (40 * lv) + (5 * lv * (lv - 1)); },
            armorCostForLevel(lv) { lv = Math.max(0, lv|0); return 50 + (40 * lv) + (5 * lv * (lv - 1)); },
            getPlayerBaseCooldown() {
                // Ước tính cooldown cơ bản của vũ khí hiện tại (không tính buff/upgrade)
                try {
                    if (!Game.player || !Game.player.currentWeaponObj) return 999999;
                    const weaponObj = Game.player.currentWeaponObj();
                    const baseConfig = BULLET_TYPES[weaponObj.id];
                    if (!baseConfig) return 999999;

                    let level = weaponObj.level || 1;
                    let cooldown = baseConfig.cooldown;

                    // Đồng bộ với logic trong Player.shoot (phần cooldown)
                    if (weaponObj.id === 'NORMAL') cooldown = Math.max(100, baseConfig.cooldown - (level - 1) * 30);
                    else if (weaponObj.id === 'FIRE') cooldown = Math.max(80, baseConfig.cooldown - (level - 1) * 30);
                    else if (weaponObj.id === 'STUN') cooldown = Math.max(200, baseConfig.cooldown - (level - 1) * 50);

                    return cooldown;
                } catch (e) {
                    return 999999;
                }
            },

            isFireRateCapped(lvOverride = null) {
                const frMax = getFireRateMaxLv();
                const lv = (lvOverride !== null) ? (lvOverride|0) : ((Game.upgrades && Game.upgrades.fireRateLv) ? (Game.upgrades.fireRateLv|0) : 0);
                return lv >= frMax;
            },

            isUpgradeMaxed(upKey) {
                // Chỉ cap những upgrade có giới hạn rõ ràng để tránh mua "phí vàng"
                if (upKey === 'btnBuyArmor') {
                    const lv = (Game.upgrades && Game.upgrades.armorLv) ? (Game.upgrades.armorLv|0) : 0;
                    return lv >= 12; // 12 * 5% = 60% (đúng cap ở takeDamage)
                }
                if (upKey === 'btnBuyFireRate') { return this.isFireRateCapped(); }
                return false;
            },


            randomizeChoices() {
                if (!this.cards || this.cards.length === 0) return;

                let pool = this.cards.filter(c => !this.isUpgradeMaxed(c.dataset.upKey));
                if (pool.length === 0) pool = this.cards.slice();
                this._shuffle(pool);

                const pickN = Math.min(3, pool.length);
                const chosen = new Set();
                for (let i = 0; i < pickN; i++) chosen.add(pool[i].dataset.upKey);

                for (const c of this.cards) {
                    const show = chosen.has(c.dataset.upKey);
                    c.style.display = show ? "block" : "none";
                }
            },

            refresh() {
                // Update gold in header
                if (this.els.gold) this.els.gold.textContent = String(Game.gold || 0);

                // Max HP
                const hpLv = (Game.upgrades && Game.upgrades.maxHpLv) ? Game.upgrades.maxHpLv : 0;
                const hpCost = this.maxHpCostForLevel(hpLv);
                if (this.els.maxHpLevel) this.els.maxHpLevel.textContent = String(hpLv);
                if (this.els.maxHpCost) this.els.maxHpCost.textContent = String(hpCost);
                if (this.els.btnBuyMaxHp) {
                    const can = (Game.gold >= hpCost) && Game.player && Game.player.hp > 0;
                    this.els.btnBuyMaxHp.disabled = !can;
                    this.els.btnBuyMaxHp.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyMaxHp.style.cursor = can ? "pointer" : "not-allowed";
                }

                // Damage %
                const dmgLv = (Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0;
                const dmgCost = this.dmgCostForLevel(dmgLv);
                if (this.els.dmgLevel) this.els.dmgLevel.textContent = String(dmgLv);
                if (this.els.dmgCost) this.els.dmgCost.textContent = String(dmgCost);
                if (this.els.btnBuyDmg) {
                    const can = (Game.gold >= dmgCost) && Game.player && Game.player.hp > 0;
                    this.els.btnBuyDmg.disabled = !can;
                    this.els.btnBuyDmg.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyDmg.style.cursor = can ? "pointer" : "not-allowed";
                }

                // Fire Rate (-5% cooldown)
                const frMax = getFireRateMaxLv();
                let frLv = (Game.upgrades && Game.upgrades.fireRateLv) ? Game.upgrades.fireRateLv : 0;
                if (Game.upgrades && Game.upgrades.fireRateLv > frMax) { Game.upgrades.fireRateLv = frMax; frLv = frMax; }
                const frCost = this.fireRateCostForLevel(frLv);
                const frCapped = (frLv >= frMax);
                if (this.els.fireRateLevel) this.els.fireRateLevel.textContent = String(frLv);
                if (this.els.fireRateCost) this.els.fireRateCost.textContent = String(frCost);
                if (this.els.btnBuyFireRate) {
                    const can = (!frCapped) && (Game.gold >= frCost) && Game.player && Game.player.hp > 0;
                    this.els.btnBuyFireRate.disabled = !can || frCapped;
                    this.els.btnBuyFireRate.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyFireRate.style.cursor = can ? "pointer" : "not-allowed";
                }

                // Pickup Range (+10px magnet range)
                const mLv = (Game.upgrades && Game.upgrades.magnetLv) ? Game.upgrades.magnetLv : 0;
                const mCost = this.magnetCostForLevel(mLv);
                if (this.els.magnetLevel) this.els.magnetLevel.textContent = String(mLv);
                if (this.els.magnetCost) this.els.magnetCost.textContent = String(mCost);
                if (this.els.btnBuyMagnet) {
                    const can = (Game.gold >= mCost) && Game.player && Game.player.hp > 0;
                    this.els.btnBuyMagnet.disabled = !can;
                    this.els.btnBuyMagnet.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyMagnet.style.cursor = can ? "pointer" : "not-allowed";
                }

                // Armor (-5% damage taken)
                const aLv = (Game.upgrades && Game.upgrades.armorLv) ? Game.upgrades.armorLv : 0;
                const aCost = this.armorCostForLevel(aLv);
                const armorCapped = (aLv >= 12);
                if (this.els.armorLevel) this.els.armorLevel.textContent = String(aLv);
                if (this.els.armorCost) this.els.armorCost.textContent = String(aCost);
                if (this.els.btnBuyArmor) {
                    const can = (!armorCapped) && (Game.gold >= aCost) && Game.player && Game.player.hp > 0;
                    this.els.btnBuyArmor.disabled = !can || armorCapped;
                    this.els.btnBuyArmor.style.opacity = can ? "1" : "0.55";
                    this.els.btnBuyArmor.style.cursor = can ? "pointer" : "not-allowed";
                }
            },
            buyMaxHp() {
                if (!this.open) return;
                if (!Game.player) return;

                const lv = (Game.upgrades && Game.upgrades.maxHpLv) ? Game.upgrades.maxHpLv : 0;
                const cost = this.maxHpCostForLevel(lv);

                if (Game.gold < cost) {
                    createDamageText(Game.player.x, Game.player.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                // Pay
                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                // Apply
                Game.upgrades.maxHpLv = lv + 1;
                Game.player.maxHp += 20;
                Game.player.hp = Math.min(Game.player.hp + 20, Game.player.maxHp);
                Game.ui.updateHealth(Game.player.hp, Game.player.maxHp);

                createDamageText(Game.player.x, Game.player.y - 45, "MAX HP +20", "#FFD700");

                
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){};

                this.refresh();
            },
            buyDmg() {
                if (!this.open) return;
                if (!Game.player) return;

                const lv = (Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0;
                const cost = this.dmgCostForLevel(lv);

                if (Game.gold < cost) {
                    createDamageText(Game.player.x, Game.player.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                // Pay
                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                // Apply
                Game.upgrades.dmgLv = lv + 1;

                createDamageText(Game.player.x, Game.player.y - 45, "DMG +10%", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}

                this.refresh();
            },
            buyFireRate() {
                if (!this.open) return;
                if (!Game.player) return;

                const lv = (Game.upgrades && Game.upgrades.fireRateLv) ? Game.upgrades.fireRateLv : 0;
                                const frMax = getFireRateMaxLv();
                if (lv >= frMax) { createDamageText(Game.player.x, Game.player.y - 45, 'CD MAX', '#FFD700'); return; }
const cost = this.fireRateCostForLevel(lv);

                if (Game.gold < cost) {
                    createDamageText(Game.player.x, Game.player.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                // Pay
                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                // Apply
                Game.upgrades.fireRateLv = lv + 1;

                createDamageText(Game.player.x, Game.player.y - 45, "CD -5%", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}

                this.refresh();
            },
            buyMagnet() {
                if (!this.open) return;
                if (!Game.player) return;

                const lv = (Game.upgrades && Game.upgrades.magnetLv) ? Game.upgrades.magnetLv : 0;
                const cost = this.magnetCostForLevel(lv);
                if (Game.gold < cost) {
                    createDamageText(Game.player.x, Game.player.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                Game.upgrades.magnetLv = lv + 1;

                createDamageText(Game.player.x, Game.player.y - 45, "MAGNET +10px", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}
                this.refresh();
            },

            buyArmor() {
                if (!this.open) return;
                if (!Game.player) return;

                const lv = (Game.upgrades && Game.upgrades.armorLv) ? Game.upgrades.armorLv : 0;
                                if (lv >= 12) { createDamageText(Game.player.x, Game.player.y - 45, 'ARMOR MAX', '#FFD700'); return; }
const cost = this.armorCostForLevel(lv);
                if (Game.gold < cost) {
                    createDamageText(Game.player.x, Game.player.y - 45, "NOT ENOUGH GOLD", "#FFD700");
                    return;
                }

                Game.gold -= cost;
                Game.ui.updateGold(Game.gold);

                Game.upgrades.armorLv = lv + 1;

                createDamageText(Game.player.x, Game.player.y - 45, "ARMOR -5%", "#FFD700");
                try { if (typeof MAX !== 'undefined' && MAX.Audio && MAX.Audio.ting) MAX.Audio.ting(); } catch(e){}
                this.refresh();
            },








            hide() {
                this.open = false;
                this.onContinue = null;
                if (this.els.modal) this.els.modal.classList.add('hidden');
            },
            continue() {
                if (!this.open) return;
                const cb = this.onContinue;
                this.hide();
                Game.paused = false;
                // reset fps cap timer to avoid stutter after pause
                Game._fpsCapLast = performance.now();
                if (typeof cb === 'function') cb();
            }
        };


        const Game = {
            selectedSystemId: 'default',
            player: null, coins: [], gold: 0, upgrades: { maxHpLv: 0, dmgLv: 0, fireRateLv: 0, magnetLv: 0, armorLv: 0 }, enemies: [], clones: [], turrets: [], projectiles: [], particles: [], pickups: [], bossMines: [], texts: [], obstacles: [], score: 0, shake: 0, active: false,
            endlessMode: false,
            ui: {
                scoreVal: document.getElementById('scoreVal'), goldVal: document.getElementById('goldVal'), waveVal: document.getElementById('waveVal'), enemyCount: document.getElementById('enemyCount'), hpText: document.getElementById('hpText'), buffs: document.getElementById('buffsContainer'), healthBar: document.getElementById('healthBar'), weaponBar: document.getElementById('weaponBar'), ultiBar: document.getElementById('ultiBar'),
                updateScore(val) { this.scoreVal.innerText = val; }, updateGold(val) { if(this.goldVal) this.goldVal.innerText = val; }, updateWave(val) { this.waveVal.innerText = val; }, updateEnemies(val) { this.enemyCount.innerText = val; },
                updateHealth(curr, max) { if(isNaN(curr)) curr = 0; const pct = (curr/max)*100; this.healthBar.style.width = `${Math.max(0, pct)}%`; this.hpText.innerText = `${Math.ceil(curr)}/${max}`; if(pct < 30) this.healthBar.style.background = 'linear-gradient(90deg, #d32f2f, #f44336)'; else this.healthBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)'; },
                updateUltiBar(val) { this.ultiBar.style.width = `${val}%`; },
                addBuff(name, color) { const div = document.createElement('div'); div.className = 'buff-icon'; div.id = `buff-${name}`; div.style.borderColor = color; div.style.color = color; div.innerText = name; this.buffs.appendChild(div); },
                removeBuff(name) { const el = document.getElementById(`buff-${name}`); if (el) el.remove(); },
                updateWeaponInventory(inventory, currentIndex) {
                    this.weaponBar.innerHTML = '';
                    for(let i = 0; i < 6; i++) {
                        const slot = document.createElement('div'); slot.className = 'weapon-slot';
                        const keyNum = document.createElement('div'); keyNum.className = 'key-number'; keyNum.innerText = i + 1; slot.appendChild(keyNum);
                        if (inventory[i]) {
                            const weapon = BULLET_TYPES[inventory[i].id]; slot.style.color = weapon.color; slot.style.borderColor = weapon.color;
                            const icon = document.createElement('div'); icon.className = 'icon'; icon.innerText = weapon.name; slot.appendChild(icon);
                            const lvl = document.createElement('div'); lvl.className = 'level-indicator'; lvl.innerText = `Lv.${inventory[i].level}`; slot.appendChild(lvl);
                            if (i === currentIndex) { slot.classList.add('active'); slot.style.background = `rgba(${hexToRgb(weapon.color)}, 0.3)`; }
                        } else { slot.style.borderColor = '#333'; slot.innerText = '-'; }
                        this.weaponBar.appendChild(slot);
                    }
                },
                updateTankSystemUI(systemId) {
                    const sys = getTankSystem(systemId);
                    const map = [
                        { key: 'clone',     slotId: 'skill-clone' },
                        { key: 'stealth',   slotId: 'skill-stealth' },
                        { key: 'vampirism', slotId: 'skill-vampirism' }
                    ];
                    for (const it of map) {
                        const def = getSystemSkillDef(sys.id, it.key);
                        const slot = document.getElementById(it.slotId);
                        if (!slot || !def) continue;
                        slot.style.borderColor = def.color || '#fff';
                        slot.style.color = def.color || '#fff';
                        const icon = slot.querySelector('.icon');
                        if (icon) icon.innerHTML = def.labelHTML || it.key;
                        const keyNum = slot.querySelector('.key-number');
                        if (keyNum) keyNum.textContent = def.key || keyNum.textContent;
                    }
                    // Optional: show system name in world-info
                    try {
                        const wi = document.getElementById('world-info');
                        if (wi) wi.textContent = `Map Size: 3x | System: ${sys.name} | Bug Fixed | Cleaned`;
                    } catch(e) {}
                },
                updateSkillCooldown(skillName, lastUsed, cooldown) {
                    const overlay = document.getElementById(`cd-${skillName}`);
                    const txt = document.getElementById(`cdt-${skillName}`);
                    const remaining = Math.max(0, (lastUsed + cooldown) - Date.now());
                    const percent = (remaining / cooldown) * 100;

                    if (overlay) overlay.style.height = `${percent}%`;

                    if (txt) {
                        if (remaining <= 0) {
                            txt.textContent = '';
                            txt.style.opacity = 0;
                        } else {
                            // Hiển thị ms khi < 1s, còn lại hiển thị giây (1 chữ số thập phân)
                            txt.textContent = (remaining < 1000)
                                ? `${Math.ceil(remaining)}ms`
                                : `${(remaining / 1000).toFixed(1)}s`;
                            txt.style.opacity = 1;
                        }
                    }
                }
            },
            init() {
                WORLD_WIDTH = canvas.width * 3; WORLD_HEIGHT = canvas.height * 3;
                this.player = new Player(this.selectedSystemId); this.enemies = []; this.clones = []; this.turrets = []; this.projectiles = []; this.particles = []; this.pickups = []; this.texts = []; this.obstacles = []; this.score = 0; this.coins = []; this.gold = 0; this.upgrades = { maxHpLv: 0, dmgLv: 0, fireRateLv: 0, magnetLv: 0, armorLv: 0 }; this.active = true; this.paused = false;
                this.endlessMode = false;
                this.generateObstacles(); WaveManager.wave = 1; WaveManager.startWave();
                this.ui.updateScore(0); this.ui.updateGold(0); this.ui.updateHealth(100, 100); this.ui.updateUltiBar(0); this.ui.updateWeaponInventory(this.player.inventory, this.player.currentWeaponIndex); this.ui.updateTankSystemUI(this.selectedSystemId); this.ui.buffs.innerHTML = '';
                Admin.init();
                Input.init(); requestAnimationFrame(loop);
            },
            generateObstacles() {
                this.obstacles = [];
                for (let i = 0; i < 30; i++) {
                    const w = 100 + Math.random() * 150; const h = 100 + Math.random() * 150; const x = Math.random() * (WORLD_WIDTH - w); const y = Math.random() * (WORLD_HEIGHT - h); const distToCenter = Math.hypot(x - WORLD_WIDTH/2, y - WORLD_HEIGHT/2);
                    if (distToCenter < 400) continue;
                    if(Game.player && checkCircleRect({x: Game.player.x, y: Game.player.y, radius: 150}, {x, y, width: w, height: h})) continue;
                    this.obstacles.push(new Obstacle(x, y, w, h));
                }
            },
            gameOver() {
                this.active = false;
                this.paused = true;

                // Hide shop / boss UI (an toàn)
                try { const shop = document.getElementById('shopModal'); if (shop) shop.classList.add('hidden'); } catch(e){}
                try { const bh = document.getElementById('bossHealthContainer'); if (bh) bh.style.display = 'none'; } catch(e){}

                // Update end screen values
                try { document.getElementById('finalScore').innerText = this.score; } catch(e){}
                try { document.getElementById('finalWave').innerText = WaveManager.wave; } catch(e){}

                // Update best + sync UI
                try { if (typeof MAX !== 'undefined') MAX.State.updateBest(this.score, WaveManager.wave); } catch(e){}

                // Show screen
                try { document.getElementById('gameOverScreen').classList.remove('hidden'); } catch(e){}
            },
            victory() {
                this.active = false;
                this.paused = true;

                try { const shop = document.getElementById('shopModal'); if (shop) shop.classList.add('hidden'); } catch(e){}
                try { const bh = document.getElementById('bossHealthContainer'); if (bh) bh.style.display = 'none'; } catch(e){}

                const wave = WaveManager.wave;
                try { document.getElementById('victoryWave').innerText = wave; } catch(e){}
                try { document.getElementById('victoryScore').innerText = this.score; } catch(e){}

                // Update best + show best on victory screen
                try { if (typeof MAX !== 'undefined') MAX.State.updateBest(this.score, wave); } catch(e){}
                try {
                    const bs = (typeof MAX !== 'undefined' && MAX.State && MAX.State.save) ? MAX.State.save.bestScore : 0;
                    const bw = (typeof MAX !== 'undefined' && MAX.State && MAX.State.save) ? MAX.State.save.bestWave : 0;
                    const elBS = document.getElementById('victoryBestScore');
                    const elBW = document.getElementById('victoryBestWave');
                    if (elBS) elBS.innerText = bs;
                    if (elBW) elBW.innerText = bw;
                } catch(e){}

                try { document.getElementById('victoryScreen').classList.remove('hidden'); } catch(e){}
            }
        };

        // --- 5. UTILS ---
        function checkCollision(c1, c2) { if(!c1 || !c2 || isNaN(c1.x) || isNaN(c2.x)) return false; const dist = Math.hypot(c1.x - c2.x, c1.y - c2.y); return dist < c1.radius + c2.radius; }
        function checkCircleRect(circle, rect) {
            if(isNaN(circle.x) || isNaN(circle.y)) return false; let testX = circle.x; let testY = circle.y;
            if (circle.x < rect.x) testX = rect.x; else if (circle.x > rect.x + rect.width) testX = rect.x + rect.width;
            if (circle.y < rect.y) testY = rect.y; else if (circle.y > rect.y + rect.height) testY = rect.y + rect.height;
            let distX = circle.x - testX; let distY = circle.y - testY; return (distX*distX + distY*distY) <= (circle.radius*circle.radius);
        }
        function isLineBlocked(x1, y1, x2, y2, obstacles) {
            const steps = 10; for(let i=0; i<=steps; i++) { const px = x1 + (x2-x1) * (i/steps); const py = y1 + (y2-y1) * (i/steps); for(let obs of obstacles) { if (px > obs.x && px < obs.x + obs.width && py > obs.y && py < obs.y + obs.height) return true; } } return false;
        }
        function hexToRgb(hex) {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : "255, 255, 255";
        }
        
        function createComplexExplosion(x, y, color) {
            if(isNaN(x) || isNaN(y)) return;
            const mult = 1;

            if (typeof MAX !== 'undefined') MAX.Audio.boom();

            // Shockwave
            Game.particles.push(new Particle(x, y, {type: 'shockwave', color: color, size: 5, maxRadius: 50, life: 0.5, decay: 0.1}));

            // Debris
            const debrisCount = Math.round(6 * mult);
            for(let i=0; i<debrisCount; i++) Game.particles.push(new Particle(x, y, {
                type: 'debris', color: color, size: 4 + Math.random()*4, life: 1.0, decay: 0.03,
                velocity: {x: (Math.random()-0.5)*10, y: (Math.random()-0.5)*10}
            }));

            // Smoke
            const smokeCount = Math.round(4 * mult);
            for(let i=0; i<smokeCount; i++) Game.particles.push(new Particle(x, y, {
                type: 'smoke', color: '#555', size: 10, life: 1.5, decay: 0.01,
                velocity: {x: (Math.random()-0.5)*2, y: (Math.random()-0.5)*2}
            }));

            // Sparks
            const sparkCount = Math.round(10 * mult);
            for(let i=0; i<sparkCount; i++) Game.particles.push(new Particle(x, y, {
                type: 'spark', color: color, size: 2, life: 0.25, decay: 0.08,
                velocity: {x: (Math.random()-0.5)*12, y: (Math.random()-0.5)*12}
            }));
        }
        function createExplosion(x, y, color, count) { // Legacy wrapper
            createComplexExplosion(x, y, color);
        }

        function createMuzzleFlash(x, y, color, count) { // Legacy wrapper
            createComplexExplosion(x, y, color);
        }
        function createMuzzleFlash(x, y, angle, color) {
            if (typeof MAX !== 'undefined') MAX.Audio.shoot();
            Game.particles.push(new Particle(x + Math.cos(angle)*10, y + Math.sin(angle)*10, {type: 'spark', color: color, size: 3, life: 0.1, decay: 0.5}));
        }
        function createDamageText(x, y, text, color) { if(isNaN(x)) return; Game.texts.push({ x, y, text, color, life: 1.0, dy: -1 }); }
        function chainLightning(startEnemy, baseDamage, count, range) {
            if (count <= 0) return;
            let nearest = null; let minDst = Infinity;
            Game.enemies.forEach(e => { if (e === startEnemy) return; const d = Math.hypot(e.x - startEnemy.x, e.y - startEnemy.y); if (d < range && d < minDst) { nearest = e; minDst = d; } });
            if (nearest) {
                nearest.hp -= baseDamage; createDamageText(nearest.x, nearest.y, Math.floor(baseDamage), '#FFEB3B');
                const steps = 10; const dx = (nearest.x - startEnemy.x) / steps; const dy = (nearest.y - startEnemy.y) / steps;
                for(let i=0; i<steps; i++) Game.particles.push(new Particle(startEnemy.x + dx*i, startEnemy.y + dy*i, {type: 'spark', color: '#FFEB3B', size: 2, life: 0.2}));
                chainLightning(nearest, baseDamage * 0.7, count - 1, range);
            }
        }

        function dropGold(x, y, amount, scatter = true) {
            if (isNaN(x) || isNaN(y)) return;
            const val = Math.max(0, Math.floor(amount || 0));
            if (val <= 0) return;
            const c = new Coin(x, y, val);
            if (scatter) { c.x += (Math.random()-0.5)*14; c.y += (Math.random()-0.5)*14; }
            Game.coins.push(c);
        }

        function dropPickup(x, y) {
            if(isNaN(x)) return;
            if (Math.random() > 0.35) return; // Tang len 35%
            const lootTable = [{id: 'HP_PACK', weight: 20}, {id: 'SHIELD', weight: 10}, {id: 'RAPID_FIRE', weight: 10}, {id: 'AMMO_NORMAL', weight: 15}, {id: 'AMMO_FIRE', weight: 10}, {id: 'AMMO_STUN', weight: 10}, {id: 'AMMO_PIERCE', weight: 10}, {id: 'AMMO_LIGHTNING', weight: 10}, {id: 'AMMO_HOMING', weight: 5}];
            const totalWeight = lootTable.reduce((sum, item) => sum + item.weight, 0);
            let random = Math.random() * totalWeight; let selectedItemKey = 'HP_PACK';
            for (const item of lootTable) { if (random < item.weight) { selectedItemKey = item.id; break; } random -= item.weight; }
            if (ITEM_TYPES[selectedItemKey]) Game.pickups.push(new Pickup(x, y, ITEM_TYPES[selectedItemKey]));
        }

        function dropBossWeapon(x, y) {
            if (isNaN(x) || isNaN(y)) return;
            const weapons = ['AMMO_FIRE', 'AMMO_STUN', 'AMMO_PIERCE', 'AMMO_LIGHTNING', 'AMMO_HOMING'];
            const key = weapons[(Math.random() * weapons.length) | 0];
            if (ITEM_TYPES[key]) {
                const px = x + (Math.random() - 0.5) * 18;
                const py = y + (Math.random() - 0.5) * 18;
                Game.pickups.push(new Pickup(px, py, ITEM_TYPES[key]));
            }
        }

        function drawMiniMap() {
            const mapSize = MINIMAP_SIZE; const mapX = canvas.width - mapSize - 20; const mapY = canvas.height - mapSize - 20;
            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(mapX, mapY, mapSize, mapSize);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(mapX, mapY, mapSize, mapSize);
            const scaleX = mapSize / WORLD_WIDTH; const scaleY = mapSize / WORLD_HEIGHT;
            if (Game.player) { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(mapX + Game.player.x * scaleX, mapY + Game.player.y * scaleY, 3, 0, Math.PI*2); ctx.fill(); }
            Game.enemies.forEach(e => { ctx.fillStyle = e.typeKey === 'BOSS' ? '#D50000' : '#f00'; const r = e.typeKey === 'BOSS' ? 6 : 2; ctx.beginPath(); ctx.arc(mapX + e.x * scaleX, mapY + e.y * scaleY, r, 0, Math.PI*2); ctx.fill(); });
            ctx.fillStyle = '#FFD700'; Game.pickups.forEach(p => { ctx.fillRect(mapX + p.x * scaleX - 1, mapY + p.y * scaleY - 1, 2, 2); });
            ctx.restore();
        }

        function loop() {
            if (!Game.active) return;
            requestAnimationFrame(loop);
            if (Game.paused) return;

            // FPS CAP (30..120). Note: requestAnimationFrame cannot exceed monitor refresh rate.
            if (typeof MAX !== 'undefined' && MAX.State && MAX.State.save && MAX.State.save.settings) {
                const cap = Math.max(30, Math.min(120, MAX.State.save.settings.fpsCap || 60));
                const frameMs = 1000 / cap;
                const now = performance.now();
                if (!Game._fpsCapLast) Game._fpsCapLast = now;
                if (now - Game._fpsCapLast < frameMs) return;
                Game._fpsCapLast = now;
            }

            try {
                // --- SELF-HEALING CHECK ---
                if (!Game.player || typeof Game.player.takeDamage !== 'function') {
                     console.warn("Player integrity lost. Respawning...");
                     Game.player = new Player(Game.selectedSystemId || 'default');
                }

                WaveManager.update();
                if(Game.player) Camera.update(Game.player);
                if(canvas.width > 0 && canvas.height > 0) { ctx.fillStyle = '#121212'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                ctx.save();
                let shakeX = 0, shakeY = 0; if (typeof MAX !== 'undefined' && MAX.State && MAX.State.save && !MAX.State.save.settings.shake) { Game.shake = 0; }
                if (!isNaN(Game.shake) && Game.shake > 0) { shakeX = Math.random() * Game.shake - Game.shake/2; shakeY = Math.random() * Game.shake - Game.shake/2; Game.shake *= 0.9; if(Game.shake < 0.5) Game.shake = 0; }
                if(!isNaN(Camera.x) && !isNaN(Camera.y)) { ctx.translate(-Camera.x + shakeX, -Camera.y + shakeY); }
                ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
                for (let y = 0; y <= WORLD_HEIGHT; y += 100) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD_WIDTH, y); ctx.stroke(); }
                for (let x = 0; x <= WORLD_WIDTH; x += 100) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD_HEIGHT); ctx.stroke(); }
                ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 5; ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

                Game.obstacles.forEach(obs => obs.draw());
                
                if (Game.player) { Game.player.update(Game.obstacles); Game.player.draw(); }

                Game.clones.forEach(c => { c.update(Game.enemies, Game.obstacles, Game.projectiles); c.draw(); });
                Game.clones = Game.clones.filter(c => !c.markedForDeletion);

                // --- ENGINEER TURRETS ---
                if (Game.turrets && Game.turrets.length) {
                    Game.turrets.forEach(t => { t.update(Game.obstacles); t.draw(); });
                    Game.turrets = Game.turrets.filter(t => !t.markedForDeletion);
                }

                Game.pickups.forEach((p) => {
                    p.update(); p.draw();
                    if (Game.player && checkCollision(Game.player, p)) {
                        if (p.config.type === 'HEAL') Game.player.heal(p.config.value);
                        else if (p.config.type === 'BUFF') Game.player.addBuff(p.config.buffType, p.config.duration);
                        else if (p.config.type === 'WEAPON') Game.player.addWeapon(p.config.weaponId); 
                        createDamageText(Game.player.x, Game.player.y - 30, p.config.label, p.config.color); p.markedForDeletion = true;
                    }
                });

                

                // --- COINS (Gold) ---
                Game.coins.forEach((c) => {
                    c.update(); c.draw();

                    if (!Game.player) return;

                    const dx = (Game.player.x - c.x);
                    const dy = (Game.player.y - c.y);
                    const dist = Math.hypot(dx, dy) || 0.0001;

                    const pr = (Game.player.radius || 20);
                    const cr = (c.radius || 10);

                    // Nam châm hút vàng: trong phạm vi +40px (ngoài va chạm), coin sẽ bay về phía player
                    const magnetRange = pr + cr + 40 + 10 * ((Game.upgrades && Game.upgrades.magnetLv) ? Game.upgrades.magnetLv : 0);  // bắt đầu hút
                    const pickupRange = pr + cr + 6;   // nhặt thật sự (gần sát)

                    if (dist < magnetRange) {
                        // kéo càng gần càng mạnh (mượt + đã tay)
                        const tPull = 1 - (dist / magnetRange); // 0..1
                        const pull = 0.45 + tPull * 1.35;       // lực hút
                        const ux = dx / dist;
                        const uy = dy / dist;

                        // tăng tốc về phía player
                        c.vx = (c.vx || 0) + ux * pull;
                        c.vy = (c.vy || 0) + uy * pull;

                        // giới hạn tốc độ để không \"dị\" (px/frame-ish)
                        const v = Math.hypot(c.vx, c.vy);
                        const vmax = 10 + tPull * 10; // càng gần càng nhanh
                        if (v > vmax) { c.vx = (c.vx / v) * vmax; c.vy = (c.vy / v) * vmax; }

                        // nếu đã đủ gần thì nhặt
                        if (dist < pickupRange) {
                            Game.gold += c.value;
                            Game.ui.updateGold(Game.gold);
                            createDamageText(Game.player.x, Game.player.y - 30, `+${c.value}`, '#FFD700');
                            c.markedForDeletion = true;
                        }
                    }
                });



                // --- BOSS MINES (mìn nổ chậm) ---
                if (Game.bossMines && Game.bossMines.length) {
                    const nowM = Date.now();
                    for (let i = Game.bossMines.length - 1; i >= 0; i--) {
                        const m = Game.bossMines[i];
                        const t = m.detonateAt - nowM;
                        const pct = Math.max(0, Math.min(1, t / (m.delay || 1500)));

                        // Draw warning
                        ctx.save();
                        ctx.fillStyle = 'rgba(255,152,0,0.10)';
                        ctx.beginPath(); ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = 'rgba(255,152,0,0.95)';
                        ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(m.x, m.y, m.radius * (0.35 + 0.65 * pct), 0, Math.PI * 2); ctx.stroke();
                        ctx.restore();

                        if (nowM >= m.detonateAt) {
                            createComplexExplosion(m.x, m.y, '#FF9800');

                            if (Game.player && typeof Game.player.takeDamage === 'function') {
                                const dP = Math.hypot(Game.player.x - m.x, Game.player.y - m.y);
                                if (dP <= m.radius + Game.player.radius) Game.player.takeDamage(m.damage);
                            }
                            if (Game.clones && Game.clones.length) {
                                Game.clones.forEach(c => {
                                    const dC = Math.hypot(c.x - m.x, c.y - m.y);
                                    if (dC <= m.radius + c.radius) c.takeDamage(m.damage);
                                });
                            }

                            Game.bossMines.splice(i, 1);
                        }
                    }
                }

                Game.projectiles.forEach(p => { p.update(); p.draw(); });

                Game.enemies.forEach(e => {
                    e.update(Game.player, Game.clones, Game.obstacles); e.draw();
                    if (Game.player && checkCollision(Game.player, e)) {
                        if (typeof Game.player.takeDamage === 'function') Game.player.takeDamage(e.contactDamage || 5); 
                        const angle = Math.atan2(e.y - Game.player.y, e.x - Game.player.x); e.x += Math.cos(angle) * 10; e.y += Math.sin(angle) * 10;
                    }
                    Game.clones.forEach(c => {
                        if (checkCollision(c, e)) { c.takeDamage(e.contactDamage || 5); const angle = Math.atan2(e.y - c.y, e.x - c.x); e.x += Math.cos(angle) * 10; e.y += Math.sin(angle) * 10; }
                    });
                });

                Game.projectiles.forEach(b => {
                    if (b.markedForDeletion) return;
                    let wallHit = false;
                    for(let obs of Game.obstacles) { 
                        if (checkCircleRect({x: b.x, y: b.y, radius: b.radius}, obs)) { 
                            if (b.config.special === 'PIERCE' || b.typeKey === 'PIERCING') { if(Math.random() < 0.2) createComplexExplosion(b.x, b.y, '#ccc'); } 
                            else { b.markedForDeletion = true; createComplexExplosion(b.x, b.y, '#aaa'); wallHit = true; break; }
                        } 
                    }
                    if(wallHit) return;

                    if (b.owner !== 'PLAYER') {
                        if (Game.player && checkCollision(b, Game.player)) { 
                             if (typeof Game.player.takeDamage === 'function') Game.player.takeDamage(b.config.damage); 
                             b.markedForDeletion = true; createComplexExplosion(b.x, b.y, '#E040FB'); 
                        }
                        Game.clones.forEach(c => {
                            if (checkCollision(b, c)) { c.takeDamage(b.config.damage); b.markedForDeletion = true; createComplexExplosion(b.x, b.y, '#E040FB'); }
                        });
                        return;
                    }
                    Game.enemies.forEach(e => {
                        if (b.markedForDeletion) return; if (b.hitList.includes(e.id)) return;
                        if (checkCollision(b, e)) {
                            const dmgMult = (b.owner === 'PLAYER') ? (1 + 0.1 * ((Game.upgrades && Game.upgrades.dmgLv) ? Game.upgrades.dmgLv : 0)) : 1;
                            const dmg = b.config.damage * dmgMult;
                            e.hp -= dmg;
if (b.owner === 'PLAYER' && Game.player && typeof Game.player.gainUltiCharge === 'function') Game.player.gainUltiCharge(0.5);
                            if (Game.player && Game.player.systemId === 'default' && Game.player.skills.vampirism.active && b.owner === 'PLAYER') {
                                // Lifesteal with cap per second
                                const now2 = Date.now();
                                if (!Game.player.vampHeal) Game.player.vampHeal = { windowStart: now2, healed: 0 };
                                if (now2 - Game.player.vampHeal.windowStart >= 1000) { Game.player.vampHeal.windowStart = now2; Game.player.vampHeal.healed = 0; }
                                const cap = (SKILL_CONFIG.VAMPIRISM.capPerSecond || 0);
                                const want = dmg * (SKILL_CONFIG.VAMPIRISM.leechPercent || 0);
                                const remain = (cap > 0) ? Math.max(0, cap - Game.player.vampHeal.healed) : want;
                                const healAmount = (cap > 0) ? Math.min(want, remain) : want;
                                if (healAmount > 0) { Game.player.vampHeal.healed += healAmount; Game.player.heal(healAmount); }
                            }
                            createDamageText(e.x, e.y, Math.round(dmg), b.config.color); createComplexExplosion(b.x, b.y, b.config.color);
                            if (b.config.effect) {
                                let eff = b.config.effect;
                                if (b.owner === 'PLAYER' && eff.type === 'BURN' && typeof eff.tickDamage === 'number') {
                                    eff = { ...eff, tickDamage: eff.tickDamage * dmgMult };
                                }
                                e.applyEffect(eff);
                            }
if (b.config.special === 'CHAIN') chainLightning(e, (dmg * b.config.chainDmgFactor), b.config.chainCount, b.config.chainRange);
                            if (b.config.special === 'PIERCE') { b.pierceCount--; b.hitList.push(e.id); if (b.pierceCount <= 0) b.markedForDeletion = true; } else { b.markedForDeletion = true; }
                        }
                    });
                });

                Game.enemies = Game.enemies.filter(e => {
                    if (e.hp <= 0) {
                        createComplexExplosion(e.x, e.y, e.config.color); Game.score += e.config.score; Game.ui.updateScore(Game.score); if (e.typeKey === 'BOSS') dropBossWeapon(e.x, e.y); else dropPickup(e.x, e.y); dropGold(e.x, e.y, (e.config && !isNaN(e.config.gold)) ? e.config.gold : 0); 
                        if(Game.player && typeof Game.player.gainUltiCharge === 'function') Game.player.gainUltiCharge(2);
                        return false;
                    } return !e.markedForDeletion;
                });
                Game.projectiles = Game.projectiles.filter(p => !p.markedForDeletion);
                Game.pickups = Game.pickups.filter(p => !p.markedForDeletion);
                Game.coins = Game.coins.filter(c => !c.markedForDeletion);
                Game.particles.forEach(p => p.update()); Game.particles.forEach(p => p.draw()); Game.particles = Game.particles.filter(p => !p.markedForDeletion);
                Game.texts.forEach((t, i) => { ctx.fillStyle = t.color; ctx.font = 'bold 16px Arial'; ctx.globalAlpha = t.life; ctx.fillText(t.text, t.x, t.y); t.y += t.dy; t.life -= 0.02; if(t.life <= 0) Game.texts.splice(i, 1); ctx.globalAlpha = 1; });
                if (typeof MAX !== 'undefined' && MAX.State.save.settings.minimap) drawMiniMap();
                ctx.restore();
                Game.ui.updateEnemies(Game.enemies.length);
                // FPS Counter
                if (typeof MAX !== 'undefined') {
                    const now = performance.now();
                    MAX.State.fps.frames++;
                    if (now - MAX.State.fps.last >= 500) {
                        MAX.State.fps.value = Math.round((MAX.State.fps.frames * 1000) / (now - MAX.State.fps.last));
                        MAX.State.fps.last = now;
                        MAX.State.fps.frames = 0;
                        const fpsVal = document.getElementById('fpsVal');
                        if (fpsVal && MAX.State.save.settings.fps) fpsVal.textContent = MAX.State.fps.value;
                    }
                }
                if (Game.player && Game.player.hp <= 0) Game.gameOver();
            } catch (err) { console.error("Game Loop Error:", err); }
        }

        
        // Load saved tank system selection (optional)
        try {
            const savedSys = localStorage.getItem('tankSystem');
            if (savedSys && document.querySelector(`input[name="tankSystem"][value="${savedSys}"]`)) {
                document.querySelector(`input[name="tankSystem"][value="${savedSys}"]`).checked = true;
                Game.selectedSystemId = savedSys;
            }
        } catch(e) {}

MAX.UI.init();

        Shop.init();

        
        const startGame = () => {

            try {
                const selected = document.querySelector('input[name="tankSystem"]:checked');
                const sysId = selected ? selected.value : 'default';
                Game.selectedSystemId = sysId || 'default';
                try { localStorage.setItem('tankSystem', Game.selectedSystemId); } catch(e){}
            } catch(e) {}

            try { if (typeof MAX !== 'undefined') { MAX.Audio.init(); } } catch(e){}
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            Game.init();
        
        };

        const openVietkeyConfirm = () => {
            const m = document.getElementById('vietkeyModal');
            if (!m) return startGame();
            m.classList.remove('hidden');

            const yes = document.getElementById('vkYes');
            const no = document.getElementById('vkNo');

            const close = () => m.classList.add('hidden');

            const onYes = () => { cleanup(); close(); startGame(); };
            const onNo  = () => { cleanup(); close(); /* stay on start screen */ };

            const onKey = (e) => {
                if (e.key === 'Enter') { e.preventDefault(); onYes(); }
                if (e.key === 'Escape') { e.preventDefault(); onNo(); }
            };

            const cleanup = () => {
                try {
                    yes && yes.removeEventListener('click', onYes);
                    no && no.removeEventListener('click', onNo);
                    window.removeEventListener('keydown', onKey, true);
                } catch(e) {}
            };

            yes && yes.addEventListener('click', onYes);
            no  && no.addEventListener('click', onNo);
            window.addEventListener('keydown', onKey, true);
        };

        document.getElementById('startBtn').addEventListener('click', () => {
            openVietkeyConfirm();
        });

        const hideEndScreens = () => {
            try { document.getElementById('gameOverScreen').classList.add('hidden'); } catch(e){}
            try { document.getElementById('victoryScreen').classList.add('hidden'); } catch(e){}
        };

        const returnToMenu = () => {
            hideEndScreens();
            try { const bh = document.getElementById('bossHealthContainer'); if (bh) bh.style.display = 'none'; } catch(e){}
            try { const shop = document.getElementById('shopModal'); if (shop) shop.classList.add('hidden'); } catch(e){}
            try { document.getElementById('gameUI').classList.add('hidden'); } catch(e){}
            try { document.getElementById('startScreen').classList.remove('hidden'); } catch(e){}
            try { Game.active = false; Game.paused = false; } catch(e){}
            try { WaveManager.active = false; } catch(e){}
        };

        const restartRun = () => {
            try { Game.paused = false; } catch(e){}

            hideEndScreens();
            try { document.getElementById('startScreen').classList.add('hidden'); } catch(e){}
            try { document.getElementById('gameUI').classList.remove('hidden'); } catch(e){}
            try { Game.init(); } catch(e){}
        };
        
        const continueEndless = () => {
            // Close victory screen and keep playing from next wave
            hideEndScreens();
            try { Game.paused = false; Game.active = true; Game.endlessMode = true; } catch(e){}
            try { WaveManager.wave = (WaveManager.wave || 1) + 1; WaveManager.startWave(); } catch(e){}
        };
// End screens buttons
        document.getElementById('restartBtn').addEventListener('click', restartRun);
        document.getElementById('menuBtnGO').addEventListener('click', returnToMenu);
        document.getElementById('victoryRestartBtn').addEventListener('click', restartRun);
        document.getElementById('victoryMenuBtn').addEventListener('click', returnToMenu);

        
        document.getElementById('victoryEndlessBtn').addEventListener('click', continueEndless);
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

    </script>

    <!-- Hidden Admin Code Modal -->
    <div id="adminCodeModal" class="hidden">
        <div id="adminCodePanel">
            <h3>ADMIN</h3>
            <input id="adminCodeInput" type="password" autocomplete="off" spellcheck="false" placeholder="Nhập code..." />
            <div id="adminCodeMsg"></div>
        </div>
    </div>


    <div id="copyrightBadge">Bản quyền: Cuongdz © 2026</div>


    <!-- VietKey confirmation (pre-game) -->
    <div id="vietkeyModal" class="hidden">
        <div id="vietkeyPanel">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                <div style="font-weight:900; color:#18ff6a; letter-spacing:2px;">LƯU Ý</div>
                <div style="opacity:0.8; font-size:12px;">(Enter = Rồi, Esc = Chưa)</div>
            </div>
            <div style="margin-top:10px; color:#ddd; line-height:1.4;">
                VietKey/bộ gõ tiếng Việt có thể làm <b>lag phím</b>. Bạn đã tắt VietKey (chuyển EN) chưa?
            </div>
            <div style="margin-top:14px; display:flex; gap:10px; justify-content:flex-end;">
                <button class="btn" id="vkNo" style="background:#333;">Chưa</button>
                <button class="btn" id="vkYes" style="background:#18ff6a; color:#041a0c;">Rồi</button>
            </div>
        </div>
    </div>

</body>
</html>
